<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-AutoRaider - Degen Command Center</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

    <style>
        /* Light Theme (Default) */
        :root {
            --primary-color: #1da1f2;
            --primary-dark: #1991db;
            --secondary-color: #14171a;
            --accent-color: #1da1f2;
            --success-color: #17bf63;
            --warning-color: #ffad1f;
            --danger-color: #e0245e;
            
            /* Adaptive colors for theme switching */
            --bg-primary: #ffffff;
            --bg-secondary: #f7f9fa;
            --bg-tertiary: #e1e8ed;
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            
            --text-primary: #14171a;
            --text-secondary: #657786;
            --text-muted: #8899a6;
            --text-inverse: #ffffff;
            
            --border-color: #e1e8ed;
            --border-hover: #ccd6dd;
            
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 16px rgba(0, 0, 0, 0.15);
            --shadow-dark: 0 2px 8px rgba(0, 0, 0, 0.3);
            
            --border-radius: 12px;
            --transition: all 0.3s ease;
        }
        
        /* Dark Theme */
        [data-theme="dark"] {
            --primary-color: #1da1f2;
            --primary-dark: #1991db;
            --secondary-color: #ffffff;
            --accent-color: #1da1f2;
            --success-color: #00d084;
            --warning-color: #ffb347;
            --danger-color: #ff6b6b;
            
            /* Dark theme adaptive colors */
            --bg-primary: #15202b;
            --bg-secondary: #192734;
            --bg-tertiary: #22303c;
            --bg-gradient-start: #2c3e50;
            --bg-gradient-end: #34495e;
            
            --text-primary: #ffffff;
            --text-secondary: #8899a6;
            --text-muted: #6c7b7f;
            --text-inverse: #14171a;
            
            --border-color: #38444d;
            --border-hover: #4a5568;
            
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            --shadow-hover: 0 4px 16px rgba(0, 0, 0, 0.6);
            --shadow-dark: 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        /* ANIMATIONS FUN POUR LES LOGS */
        @keyframes slideInBounce {
            0% { transform: translateX(-100px); opacity: 0; }
            60% { transform: translateX(10px); opacity: 0.8; }
            100% { transform: translateX(0); opacity: 1; }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(5deg); }
            75% { transform: rotate(-5deg); }
        }

        @keyframes glow {
            0% { box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 4px 20px rgba(0,0,0,0.4), 0 0 20px rgba(255,255,255,0.1); }
        }

        @keyframes twitterPulse {
            0%, 100% { box-shadow: 0 3px 10px rgba(29,161,242,0.3); }
            50% { box-shadow: 0 5px 25px rgba(29,161,242,0.6), 0 0 30px rgba(29,161,242,0.2); }
        }

        /* Automation Progress Card Styles */
        .automation-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .automation-section:last-of-type {
            border-bottom: none;
            margin-bottom: 0;
        }

        .automation-status-item {
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 3px solid var(--primary-color);
            font-size: 0.9em;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .automation-status-item:hover {
            background: var(--bg-tertiary);
            transform: translateX(2px);
        }

        .automation-status-item.success {
            border-left-color: var(--success-color);
        }

        .automation-status-item.warning {
            border-left-color: var(--warning-color);
        }

        .automation-status-item.error {
            border-left-color: var(--danger-color);
        }

        /* Animation pour les icônes actives */
        .automation-status-item.active .icon,
        .automation-status-item.success .icon {
            animation: iconPulse 1.5s ease-in-out infinite;
        }

        .automation-status-item.warning .icon {
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { 
                transform: scale(1); 
                filter: drop-shadow(0 0 5px #22c55e);
            }
            50% { 
                transform: scale(1.1); 
                filter: drop-shadow(0 0 10px #22c55e);
            }
        }

        /* Couleurs spécifiques pour les différents états */
        .automation-status-item.success .icon {
            filter: drop-shadow(0 0 5px #22c55e);
        }

        .automation-status-item.warning .icon {
            filter: drop-shadow(0 0 5px #f59e0b);
        }

        .automation-status-item.error .icon {
            filter: drop-shadow(0 0 5px #ef4444);
        }

        @keyframes cryptoGlow {
            0% { 
                box-shadow: 0 6px 20px rgba(29, 161, 242, 0.3), 0 0 0 rgba(255, 215, 0, 0);
                background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 100%);
            }
            25% { 
                box-shadow: 0 8px 25px rgba(29, 161, 242, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
                background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 50%, #ffd700 100%);
            }
            50% { 
                box-shadow: 0 10px 30px rgba(29, 161, 242, 0.6), 0 0 30px rgba(255, 215, 0, 0.5);
                background: linear-gradient(135deg, #ffd700 0%, #1da1f2 50%, #0d8bd9 100%);
            }
            75% { 
                box-shadow: 0 8px 25px rgba(29, 161, 242, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
                background: linear-gradient(135deg, #0d8bd9 0%, #ffd700 50%, #1da1f2 100%);
            }
            100% { 
                box-shadow: 0 6px 20px rgba(29, 161, 242, 0.3), 0 0 0 rgba(255, 215, 0, 0);
                background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 100%);
            }
        }

        @keyframes cryptoShimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        @keyframes cryptoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .crypto-dashboard-btn {
            position: relative;
            overflow: hidden;
            animation: cryptoGlow 3s ease-in-out infinite;
        }

        .crypto-dashboard-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            transition: left 0.5s;
        }

        .crypto-dashboard-btn:hover::before {
            left: 100%;
        }

        .crypto-dashboard-btn:hover {
            animation: cryptoPulse 0.6s ease-in-out infinite;
        }

        .crypto-icon {
            display: inline-block;
            animation: bounce 2s ease-in-out infinite;
        }

        .crypto-text {
            background: linear-gradient(45deg, #ffffff, #ffd700, #ffffff);
            background-size: 200% 200%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: cryptoShimmer 2s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .dashboard-container {
            padding: 20px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .card.actions-total .card-icon { background: linear-gradient(45deg, #9C27B0, #7B1FA2); }
        .card.recent-activity .card-icon { background: linear-gradient(45deg, #F44336, #D32F2F); }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .metric-label {
            font-weight: 500;
            color: var(--text-secondary);
        }

        .metric-value {
            font-weight: 700;
            font-size: 1.1em;
            color: var(--text-primary);
        }
        .metric-value.info { color: var(--primary-color); }

        #recent-activity-list .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .activity-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            transition: var(--transition);
        }

        .activity-item:hover {
            transform: translateX(5px);
            box-shadow: var(--shadow-hover);
        }

        .tweet-link-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: #1da1f2;
            color: white;
            border-radius: 50%;
            text-decoration: none;
            font-size: 12px;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .tweet-link-btn:hover {
            background: #0d8bd9;
            color: white;
            transform: scale(1.1);
        }

        /* Floating buttons - unified styling */
        .floating-btn {
            position: fixed;
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 999;
            backdrop-filter: blur(10px);
        }

        .floating-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .refresh-btn {
            bottom: 30px;
            right: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .dashboard-btn {
            bottom: 30px;
            left: 90px;
            background: linear-gradient(45deg, #FF9800, #FFC107);
            color: white;
        }

        @media (max-width: 768px) {
            .floating-btn {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
            
            .refresh-btn {
                bottom: 20px;
                right: 20px;
            }
            
            .dashboard-btn {
                bottom: 20px;
                left: 75px;
            }
            
            .scroll-to-top {
                bottom: 20px;
                left: 20px;
            }
        }

        .activity-icon {
            margin-right: 15px;
            font-size: 1.2em;
            width: 30px;
            text-align: center;
        }

        .activity-like .activity-icon { color: #e91e63; }
        .activity-reply .activity-icon { color: #2196f3; }
        .activity-retweet .activity-icon { color: #4caf50; }

        .activity-details {
            flex-grow: 1;
        }

        .activity-user {
            font-weight: 600;
            color: var(--text-primary);
        }

        .activity-action {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .activity-time {
            font-size: 0.85em;
            color: var(--text-muted);
            white-space: nowrap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
            transition: var(--transition);
        }

        .pulse-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            animation: pulseGlow 2s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }

        @keyframes pulseGlow {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 16px rgba(40, 167, 69, 0.6);
            }
        }

        .progress-bar-container {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            border-radius: 2px;
            transition: width 1s ease;
            width: 0%;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: var(--text-inverse);
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        /* Theme Toggle Button Styles */
        .theme-toggle-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(10px);
            color: var(--text-inverse);
            font-size: 1.2em;
        }
        
        .theme-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        
        .theme-toggle-btn:active {
            transform: scale(0.95);
        }
        

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            transition: box-shadow 0.19s cubic-bezier(.36, 1.5, .64, 1), transform 0.17s cubic-bezier(.36, 1.5, .64, 1);
            opacity: 0;
            animation: card-pop 0.35s cubic-bezier(.36, 1.5, .64, 1) 1 forwards;
        }

        @keyframes card-pop {
            0% {
                opacity: 0;
                transform: scale(0.97) translateY(8px);
            }
            70% {
                opacity: 1;
                transform: scale(1.03) translateY(-2px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .card:hover {
            box-shadow: 0 8px 32px rgba(29, 161, 242, 0.13), var(--shadow-hover);
            transform: scale(1.02) translateY(-3px) rotate(-0.7deg);
            transition: box-shadow 0.14s cubic-bezier(.36, 1.5, .64, 1), transform 0.14s cubic-bezier(.36, 1.5, .64, 1);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light-gray);
        }

        .card-header i {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-right: 12px;
            filter: drop-shadow(0 0 4px #1da1f2cc);
            transition: filter 0.15s, color 0.15s;
        }

        .card-header i.pulse {
            animation: icon-pulse 1.2s cubic-bezier(.36, 1.5, .64, 1) infinite;
        }

        @keyframes icon-pulse {
            0% {
                filter: drop-shadow(0 0 4px #1da1f2cc);
                color: var(--primary-color);
            }
            50% {
                filter: drop-shadow(0 0 14px #1da1f2);
                color: #17bf63;
            }
            100% {
                filter: drop-shadow(0 0 4px #1da1f2cc);
                color: var(--primary-color);
            }
        }

        .card-header h3 {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--secondary-color);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--secondary-color);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: box-shadow 0.19s cubic-bezier(.36, 1.5, .64, 1), background 0.18s, color 0.18s, transform 0.18s;
            text-decoration: none;
            gap: 8px;
            min-height: 44px;
            box-shadow: 0 2px 6px rgba(29, 161, 242, 0.06);
        }

        .btn-primary {
            background: var(--primary-color);
            color: var(--white);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: scale(1.07) translateY(-2px) rotate(-1deg);
            box-shadow: 0 8px 32px rgba(29, 161, 242, 0.13);
            animation: btn-bounce 0.18s cubic-bezier(.36, 1.5, .64, 1) 1;
        }

        @keyframes btn-bounce {
            0% {
                transform: scale(1) translateY(0);
            }
            60% {
                transform: scale(1.12) translateY(-3px);
            }
            100% {
                transform: scale(1.07) translateY(-2px) rotate(-1deg);
            }
        }

        .btn-full {
            width: 100%;
            margin-bottom: 10px;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: var(--transition);
            background: var(--white);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(29, 161, 242, 0.1);
        }

        .form-control::placeholder {
            color: var(--medium-gray);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 24px;
            padding: 6px 16px;
            background: #e1e8ed;
            color: #444;
            margin-right: 8px;
            margin-bottom: 4px;
            transition: background 0.18s, color 0.18s, box-shadow 0.18s;
        }
        
        .status-badge.active {
            background: #17bf63;
            color: #fff;
            box-shadow: 0 0 0 0 #17bf6344;
            animation: badge-pulse 1.1s cubic-bezier(.36, 1.5, .64, 1) infinite, badge-shake 0.7s cubic-bezier(.36, 1.5, .64, 1) infinite alternate;
        }

        @keyframes badge-pulse {
            0% {
                box-shadow: 0 0 0 0 #17bf6344;
            }
            70% {
                box-shadow: 0 0 0 7px #17bf6322;
            }
            100% {
                box-shadow: 0 0 0 0 #17bf6344;
            }
        }

        @keyframes badge-shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
            100% { transform: translateX(0); }
        }

        @keyframes electric-bolt {
            0% { transform: rotate(-6deg) scale(1.05) skewX(-6deg); filter: drop-shadow(0 0 6px #fff700) brightness(1.3); }
            10% { transform: rotate(7deg) scale(1.07) skewX(8deg); filter: drop-shadow(0 0 18px #fff700) brightness(1.5); }
            20% { transform: rotate(-8deg) scale(1.05) skewX(-8deg); filter: drop-shadow(0 0 10px #ffe066) brightness(1.2); }
            30% { transform: rotate(8deg) scale(1.11) skewX(9deg); filter: drop-shadow(0 0 24px #fff700) brightness(1.7); }
            40% { transform: rotate(-5deg) scale(1.09) skewX(-5deg); filter: drop-shadow(0 0 12px #fff700) brightness(1.3); }
            50% { transform: rotate(0deg) scale(1.13) skewX(0deg); filter: drop-shadow(0 0 30px #fff700) brightness(2); }
            60% { transform: rotate(6deg) scale(1.09) skewX(6deg); filter: drop-shadow(0 0 14px #ffe066) brightness(1.3); }
            70% { transform: rotate(-7deg) scale(1.08) skewX(-7deg); filter: drop-shadow(0 0 22px #fff700) brightness(1.5); }
            80% { transform: rotate(7deg) scale(1.12) skewX(7deg); filter: drop-shadow(0 0 19px #fff700) brightness(1.7); }
            90% { transform: rotate(-6deg) scale(1.07) skewX(-6deg); filter: drop-shadow(0 0 13px #ffe066) brightness(1.2); }
            100% { transform: rotate(0deg) scale(1.09) skewX(0deg); filter: drop-shadow(0 0 16px #fff700) brightness(1.4); }
        }

        .electric-bolt {
            animation: electric-bolt 0.85s cubic-bezier(.36, 1.5, .64, 1) infinite;
            color: #fff700 !important;
            text-shadow: 0 0 8px #fff700, 0 0 16px #ffe066;
            filter: drop-shadow(0 0 12px #fff700);
        }

        .status-inactive {
            background: rgba(224, 36, 94, 0.1);
            color: var(--danger-color);
        }

        .accounts-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--light-gray);
        }

        .account-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
        }

        .account-item:last-child {
            border-bottom: none;
        }

        .account-item:hover {
            background: var(--white);
        }

        .account-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .account-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-weight: bold;
        }
        
        .btn-danger {
            background: var(--danger-color);
            color: var(--white);
        }
        .btn-danger:hover {
            background: #c91e4a;
        }
        
        .btn-icon {
            padding: 6px 8px;
            border-radius: 50%;
            min-width: 0;
            min-height: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            box-shadow: none;
        }
        .btn-icon i {
            margin: 0;
            font-size: 1.1em;
        }

        .table-container {
            background: var(--white);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        .table-header {
            background: var(--light-gray);
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .table-header h3 {
            color: var(--secondary-color);
            font-size: 1.2rem;
            font-weight: 600;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: var(--light-gray);
            font-weight: 600;
            color: var(--secondary-color);
        }

        tr:hover {
            background: rgba(29, 161, 242, 0.05);
        }

        .alert {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .alert-info {
            background: rgba(29, 161, 242, 0.1);
            border-color: var(--primary-color);
            color: var(--primary-dark);
        }
        
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* Utility classes */
        .text-center { text-align: center; }
        .text-muted { color: var(--text-secondary); }
        .mb-2 { margin-bottom: 16px; }
        .mb-3 { margin-bottom: 24px; }
        .mt-2 { margin-top: 16px; }
        .mt-3 { margin-top: 24px; }
        
        /* Mobile-specific utility classes */
        @media (max-width: 768px) {
            .mobile-stack {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            .mobile-full-width {
                width: 100% !important;
            }
            
            .mobile-center {
                text-align: center !important;
            }
            
            .mobile-hide {
                display: none !important;
            }
        }

        /* ===== RESPONSIVE DESIGN ===== */
        
        /* Large tablets and small desktops (768px - 1024px) */
        @media (max-width: 1024px) {
            .main-container {
                max-width: 95%;
                padding: 15px;
            }
            
            .dashboard {
                gap: 15px;
            }
            
            .grid-2 {
                gap: 15px;
            }
        }
        
        /* Tablets (768px - 1023px) */
        @media (max-width: 768px) {
            .dashboard, .grid-2 {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .main-container {
                padding: 12px;
            }
            
            .header {
                margin-bottom: 20px;
                padding: 0 10px;
            }
            
            .header h1 {
                font-size: 2.2rem;
                margin-bottom: 8px;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            
            .card {
                padding: 20px;
                margin-bottom: 15px;
            }
            
            .card-header {
                margin-bottom: 15px;
                padding-bottom: 12px;
            }
            
            .card-header h3 {
                font-size: 1.3rem;
            }
        }
        
        /* Mobile phones (480px - 767px) */
        @media (max-width: 480px) {
            .main-container {
                padding: 8px;
            }
            
            /* Mobile logs optimization */
            #liveLogs {
                font-size: 0.75em !important;
                padding: 8px !important;
                line-height: 1.3 !important;
                word-break: break-all !important;
                overflow-wrap: break-word !important;
            }
            
            #liveLogsCard .card-header {
                flex-direction: column !important;
                gap: 8px !important;
                align-items: stretch !important;
            }
            
            #liveLogsCard .card-header h3 {
                font-size: 1rem !important;
                margin: 0 !important;
            }
            
            #logsControls {
                padding: 8px !important;
            }
            
            #logsControls > div {
                flex-direction: column !important;
                gap: 8px !important;
            }
            
            #logsControls select {
                width: 100% !important;
                padding: 6px !important;
            }
            
            /* Compact log buttons */
            #pauseLogsBtn, #downloadLogsBtn {
                padding: 6px 10px !important;
                font-size: 0.8em !important;
                width: 100% !important;
            }
            
            #logsStatus {
                font-size: 0.8em !important;
                text-align: center !important;
            }
            
            .header {
                margin-bottom: 15px;
                padding: 0 5px;
            }
            
            .header h1 {
                font-size: 1.8rem;
                margin-bottom: 6px;
            }
            
            .header p {
                font-size: 0.9rem;
            }
            
            
            .card {
                padding: 15px;
                margin-bottom: 12px;
                border-radius: 8px;
            }
            
            .card-header {
                margin-bottom: 12px;
                padding-bottom: 10px;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .card-header h3 {
                font-size: 1.2rem;
                margin: 0;
            }
            
            .card-header i {
                margin-right: 8px;
            }
            
            /* Button optimizations for mobile */
            .btn {
                padding: 12px 16px;
                font-size: 0.95rem;
                min-height: 44px; /* iOS recommended touch target */
                border-radius: 8px;
            }
            
            .btn-full {
                width: 100%;
                margin-bottom: 10px;
            }
            
            /* Form controls for mobile */
            .form-control, select, input, textarea {
                padding: 12px;
                font-size: 16px; /* Prevents zoom on iOS */
                border-radius: 8px;
                min-height: 44px;
            }
            
            .input-group {
                margin-bottom: 15px;
            }
            
            .input-group label {
                font-size: 0.9rem;
                margin-bottom: 6px;
                display: block;
            }
            
            /* Analytics cards mobile optimization */
            .stat-card {
                padding: 12px !important;
                margin-bottom: 10px;
            }
            
            .stat-card h4 {
                font-size: 1rem !important;
                margin-bottom: 8px !important;
            }
            
            /* Logs section mobile */
            #liveLogsCard .card-header {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            #liveLogsCard .card-header > div {
                justify-content: center;
            }
            
            #logsControls {
                padding: 8px !important;
            }
            
            #logsControls > div {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            #logsControls select {
                width: 100%;
            }
            
            /* Smart Scheduling mobile */
            #recommendedTimeSlots {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            
            .time-slot {
                padding: 8px !important;
                font-size: 0.85rem !important;
            }
        }
        
        /* Small mobile phones (320px - 479px) */
        @media (max-width: 320px) {
            .header h1 {
                font-size: 1.6rem;
            }
            
            /* Extra small mobile logs */
            #liveLogs {
                font-size: 0.7em !important;
                padding: 6px !important;
                max-height: 250px !important;
            }
            
            #liveLogsCard .card-header h3 {
                font-size: 0.9rem !important;
            }
            
            #pauseLogsBtn, #downloadLogsBtn {
                padding: 4px 8px !important;
                font-size: 0.75em !important;
            }
            
            .card {
                padding: 12px;
            }
            
            .btn {
                padding: 10px 12px;
                font-size: 0.9rem;
            }
            
            #recommendedTimeSlots {
                grid-template-columns: 1fr;
            }
            
        }
        
        /* Landscape orientation optimizations */
        @media (max-height: 500px) and (orientation: landscape) {
            .header {
                margin-bottom: 10px;
            }
            
            .header h1 {
                font-size: 1.5rem;
                margin-bottom: 4px;
            }
            
            .header p {
                font-size: 0.85rem;
            }
            
            .card {
                padding: 12px;
                margin-bottom: 8px;
            }
        }
        
        /* ===== QUICK START GUIDE STYLES ===== */
        
        .quick-start-guide {
            transition: all 0.3s ease;
        }
        
        .quick-start-header:hover {
            background-color: rgba(29, 161, 242, 0.03) !important;
        }
        
        .quick-start-badge {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .guide-step {
            margin-bottom: 15px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(29, 161, 242, 0.1);
            transition: all 0.2s ease;
        }
        
        .guide-step:last-child {
            border-bottom: none;
        }
        
        .guide-step:hover {
            background-color: rgba(29, 161, 242, 0.02);
            padding-left: 8px;
            border-radius: 4px;
        }
        
        .step-detail {
            color: #666;
            font-size: 0.9em;
            line-height: 1.5;
            margin-top: 4px;
            display: block;
        }
        
        .pro-tips {
            animation: fadeInUp 0.5s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* CSS pour la validation de l'automation */
        .validation-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 12px 15px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.8);
            border-left: 4px solid #ffc107;
            font-size: 0.95em;
        }
        
        .clickable-validation {
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .clickable-validation:hover {
            background: rgba(0, 123, 255, 0.1);
            border: 1px solid #007bff;
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }
        
        .clickable-validation:active {
            transform: translateX(3px);
        }
        
        .validation-item i {
            margin-right: 10px;
            font-size: 1.1em;
            min-width: 20px;
        }
        
        .validation-item.valid {
            background: rgba(40, 167, 69, 0.1);
            border-left: 4px solid #28a745;
        }
        
        .validation-item.valid i {
            color: #28a745 !important;
        }
        
        .validation-item.invalid {
            background: rgba(220, 53, 69, 0.1);
            border-left: 4px solid #dc3545;
        }
        
        .validation-item.invalid i {
            color: #dc3545 !important;
        }
        
        .btn-automation-ready {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            border: none !important;
            color: white !important;
            cursor: pointer !important;
            opacity: 1 !important;
            transform: scale(1);
            transition: all 0.3s ease;
        }
        
        .btn-automation-ready:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4) !important;
        }
        
        .btn-automation-ready:active {
            transform: scale(0.98);
        }
        
        .automation-pulse {
            animation: automation-ready-pulse 2s infinite;
        }
        
        @keyframes automation-ready-pulse {
            0% {
                box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            }
            50% {
                box-shadow: 0 6px 25px rgba(40, 167, 69, 0.6);
            }
            100% {
                box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            }
        }
        
        /* Mobile optimizations for Quick Start Guide */
        @media (max-width: 768px) {
            .quick-start-header {
                padding: 15px 20px !important;
            }
            
            .quick-start-header h3 {
                font-size: 1rem !important;
            }
            
            .quick-start-badge {
                font-size: 0.65em !important;
                padding: 1px 6px !important;
            }
            
            .quick-start-status {
                font-size: 0.8em !important;
            }
            
            #quickStartChevron {
                font-size: 1em !important;
            }
        }
        
        @media (max-width: 480px) {
            .quick-start-header {
                padding: 12px 15px !important;
            }
        }

        /* Animation pour la section Upcoming Tasks */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Styles pour les badges de comptes actifs */
        .account-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 500;
            margin: 2px;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }

        .account-badge.working {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 2px 4px rgba(40,167,69,0.3); }
            50% { box-shadow: 0 2px 8px rgba(40,167,69,0.6); }
            100% { box-shadow: 0 2px 4px rgba(40,167,69,0.3); }
        }
        
        .quick-start-header > div {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 8px !important;
            }
            
            .quick-start-header > div:last-child {
                align-self: flex-end !important;
                flex-direction: row !important;
            }
            
            .guide-step {
                margin-bottom: 12px;
                padding: 6px 0;
            }
            
            .guide-step b {
                font-size: 0.95em;
            }
            
            .step-detail {
                font-size: 0.85em;
                margin-top: 6px;
            }
            
            .pro-tips {
                padding: 12px !important;
                margin-top: 15px !important;
            }
            
            .pro-tips ul {
                font-size: 0.85em !important;
            }
            
            #quickStartContent {
                padding: 0 15px !important;
            }
        }

        
        /* Influencer notification animations */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        /* Influencer section responsive styles */
        @media (max-width: 768px) {
            .card .grid-2.mobile-stack {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            #recentInteractions {
                max-height: 150px !important;
            }
            
            .card .card-header div {
                flex-direction: column;
                align-items: flex-start !important;
                gap: 10px;
            }
            
            .card .card-header div > div {
                width: 100%;
                justify-content: space-between;
            }
        }
        
        /* Sticky message styles */
        .sticky-automation-msg {
            background: linear-gradient(90deg, #e3f6ff 0%, #e9f9e7 100%);
            border: 1.5px solid #1da1f2;
            border-radius: 9px;
            box-shadow: 0 2px 12px rgba(29, 161, 242, 0.07);
            color: #14619c;
            font-size: 1.07em;
            font-weight: 500;
            padding: 12px 20px 12px 18px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 13px;
            justify-content: center;
            animation: stickyAppear 0.7s cubic-bezier(.39, .58, .57, 1.13);
        }

        .sticky-automation-msg .spinner {
            width: 22px;
            height: 22px;
            border: 3px solid #1da1f2;
            border-top: 3px solid #e3f6ff;
            border-radius: 50%;
            display: inline-block;
            animation: spin 1s linear infinite;
            margin-right: 7px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes stickyAppear {
            0% { opacity: 0; transform: translateY(-18px) scale(0.96); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Queue tabs styles */
        .queue-tab {
            transition: all 0.3s ease;
        }
        
        .queue-tab:hover {
            color: #1da1f2 !important;
            background: rgba(29, 161, 242, 0.05);
        }
        
        .queue-tab.active {
            color: #1da1f2 !important;
            border-bottom-color: #1da1f2 !important;
            background: rgba(29, 161, 242, 0.05);
        }
        
        .queue-tab-content {
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Account status indicators */
        .account-status-card {
            transition: all 0.3s ease;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid;
        }
        
        .account-status-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .account-status-card.active {
            border-left-color: #28a745;
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
        }
        
        .account-status-card.paused {
            border-left-color: #ffc107;
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        }
        
        .account-status-card.error {
            border-left-color: #dc3545;
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        }
        
        /* Countdown timer animation */
        .countdown-timer {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Navigation styles removed - using navbar.js component */

        /* Adjust main content for fixed navbar */
        .main-container {
            margin-top: 80px;
        }

        /* Scroll to Top Button */
        .scroll-to-top {
            bottom: 30px;
            left: 30px;
            background: rgba(29, 161, 242, 0.9);
            color: white;
            display: none;
        }

        .scroll-to-top:hover {
            background: rgba(29, 161, 242, 1);
        }

        .scroll-to-top.show {
            display: flex;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
    
    <!-- Include Navbar Component -->
    <script src="components/navbar.js"></script>
</head>

<body>

    <!-- Navbar sera injectée par navbar.js -->

    <!-- Scroll to Top Button -->
    <button class="floating-btn scroll-to-top" id="scrollToTopBtn" onclick="scrollToTop()" title="Remonter en haut">
        <i class="fas fa-chevron-up"></i>
    </button>
    
    <button class="floating-btn dashboard-btn" onclick="window.open('dashboard.html', '_blank')" title="Open Dashboard">
        <i class="fas fa-tachometer-alt"></i>
    </button>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Header remplacé par navbar.js -->

        <!-- Quick Start Guide - Collapsible -->
        <div class="card mb-3 quick-start-guide" style="background: linear-gradient(135deg, #f7f9fa 0%, #e8f4f8 100%); border-left: 5px solid #1da1f2; overflow: hidden;">
            <div class="card-header quick-start-header" style="border-bottom: none; margin-bottom: 0; cursor: pointer; user-select: none; transition: all 0.3s ease;" onclick="toggleQuickStartGuide()">
                <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                    <div style="display: flex; align-items: center;">
                        <i class="fas fa-rocket" style="color: #1da1f2; margin-right: 10px; font-size: 1.2em;"></i>
                        <h3 style="font-size: 1.1rem; color: #1da1f2; margin: 0;">Quick Start Guide</h3>
                        <span class="quick-start-badge" style="
                            background: #1da1f2;
                            color: white;
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 0.7em;
                            font-weight: bold;
                            margin-left: 10px;
                            text-transform: uppercase;
                        ">7 Steps</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span class="quick-start-status" style="font-size: 0.85em; color: #666;">Click to expand</span>
                        <i id="quickStartChevron" class="fas fa-chevron-down" style="
                            color: #1da1f2;
                            transition: transform 0.3s ease;
                            font-size: 1.1em;
                        "></i>
                    </div>
                </div>
            </div>
            
            <div id="quickStartContent" class="quick-start-content" style="
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), padding 0.3s ease;
                padding: 0 25px;
            ">
                <div class="quick-start-inner" style="padding-bottom: 20px;">
                    <ol style="margin: 20px 0 0 18px; color: #222; line-height: 1.6;">
                        <li class="guide-step"><b>Connect X Accounts</b>:<br>
                            <span class="step-detail">- Click <b>"Generate X invitation link"</b> to connect accounts via OAuth<br>
                            - Send the invitation link to team members to onboard multiple raid accounts<br>
                            - <span style="background:#fff3cd;padding:2px 6px;border-radius:4px;color:#856404;font-weight:bold;">⚠️ IMPORTANT:</span> After adding accounts, refresh the page to sync account data immediately</span>
                        </li>
                        <li class="guide-step"><b>Configure AI Token Settings</b>:<br>
                            <span class="step-detail">- Fill in your token's symbol (ex: <b>$PICA</b>), name, X handle, and blockchain<br>
                            - These details power all AI-generated alpha replies<br>
                            - <span style="background:#fff3cd;padding:2px 6px;border-radius:4px;color:#856404;font-weight:bold;">⚠️ CRITICAL:</span> After changing settings, STOP automation and restart it to apply changes</span>
                        </li>
                        <li class="guide-step"><b>Add Degen Targets to Raid</b>:<br>
                            <span class="step-detail">- Enter X usernames (without @) of alpha accounts to monitor<br>
                            - System detects new tweets from these targets automatically<br>
                            - Use "Add Raid Target" to add without overwriting existing list<br>
                            - <span style="background:#fff3cd;padding:2px 6px;border-radius:4px;color:#856404;font-weight:bold;">⚠️ TIP:</span> Refresh page after adding targets to see them immediately</span>
                        </li>
                        <li class="guide-step"><b>Setup Auto-Reply Images (Optional)</b>:<br>
                            <span class="step-detail">- Upload up to 20 images (max 3MB each) for automatic replies<br>
                            - Enable "automatic image replies" for 10% chance of image attachment<br>
                            - Supports JPG, PNG, GIF, WEBP formats</span>
                        </li>
                        <li class="guide-step"><b>Configure Global Quotas</b>:<br>
                            <span class="step-detail">- Set daily limits for likes, retweets, and replies<br>
                            - Monitor real-time quota usage in the dashboard<br>
                            - <span style="background:#fff3cd;padding:2px 6px;border-radius:4px;color:#856404;font-weight:bold;">⚠️ IMPORTANT:</span> Quota changes require automation restart to take effect</span>
                        </li>
                        <li class="guide-step"><b>Launch Automation</b>:<br>
                            <span class="step-detail">- Verify all criteria are met (green checkmarks)<br>
                            - Click <b>"LAUNCH AUTOMATION"</b> button<br>
                            - <span style="color:#28a745;font-weight:bold;">Green animated status</span> indicates active engine<br>
                            - <span style="background:#d1ecf1;padding:2px 6px;border-radius:4px;color:#0c5460;font-weight:bold;">💡 PRO TIP:</span> Always restart automation after configuration changes</span>
                        </li>
                        <li class="guide-step"><b>Monitor Activity</b>:<br>
                            <span class="step-detail">- <b>Dashboard Analytics</b>: Real-time metrics and performance graphs<br>
                            - <b>Live Action Log</b>: Real-time feed of all automated actions<br>
                            - <b>Actions History</b>: Complete log with filtering and export options<br>
                            - <span style="background:#fff3cd;padding:2px 6px;border-radius:4px;color:#856404;font-weight:bold;">⚠️ SYNC TIP:</span> Refresh page if data seems outdated</span>
                        </li>
                    </ol>
                    
                    <div class="pro-tips" style="
                        background: linear-gradient(135deg, #fff9e6 0%, #f0f8ff 100%);
                        border: 1px solid #ffc107;
                        border-radius: 8px;
                        padding: 15px;
                        margin-top: 20px;
                    ">
                        <div style="margin-bottom: 10px; display: flex; align-items: center;">
                            <i class="fas fa-lightbulb" style="color: #ffc107; margin-right: 8px; font-size: 1.1em;"></i>
                            <b style="color: #333;">Alpha Tips:</b>
                        </div>
                        <ul style="margin: 0 0 0 20px; font-size: 0.9em; color: #555; line-height: 1.5;">
                            <li><b>Page Refresh:</b> Always refresh the page after major configuration changes to ensure data sync</li>
                            <li><b>Automation Restart:</b> Stop and restart automation after changing AI settings, quotas, or targets</li>
                            <li><b>Target Selection:</b> Add 3-5 high-activity alpha accounts for best raid results</li>
                            <li><b>Image Replies:</b> Upload diverse memes/reactions for more engaging automated responses</li>
                            <li><b>Quota Management:</b> Start conservative and increase limits based on performance metrics</li>
                            <li><b>Real-time Monitoring:</b> Use dashboard analytics to optimize your raid strategy continuously</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>



        <div class="dashboard">

            <!-- 🚀 SECTION AUTOMATION SÉCURISÉE -->
            <div class="card" style="border: 2px solid #1da1f2; box-shadow: 0 4px 20px rgba(29, 161, 242, 0.15);">
                <div class="card-header">
                    <i class="fas fa-rocket"></i>
                    <h3>🔐 Secure Raid Engine Launch</h3>
                </div>
                
                <!-- Statut actuel -->
                <div class="mb-3" style="padding: 15px; background: #f8f9fa; border-radius: 8px; margin: 15px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                        <span id="automationStatus" class="status-badge"></span>
                        <div id="automationActivityIndicator" style="display: none;">
                            <div class="pulse-badge">
                                <i class="fas fa-bolt"></i>
                                <span>SCANNING</span>
                            </div>
                        </div>
                    </div>
                    
                    
                
                <!-- Validation des critères -->
                <div id="automationValidation" style="margin: 15px; padding: 15px; border-radius: 8px; border: 2px solid #ffc107; background: #fff3cd;">
                    <h4 style="color: #856404; margin: 0 0 15px 0; font-size: 1.1em;">
                        <i class="fas fa-shield-alt"></i> Raid Criteria Verification
                    </h4>
                    <div id="validationResults">
                        <div class="validation-item clickable-validation" data-criterion="accounts" onclick="scrollToSection('raidWalletsSection')" title="Cliquez pour aller à la gestion des comptes">
                            <i class="fas fa-times-circle" style="color: #dc3545;"></i>
                            <span>Verifying connected raid X Accounts...</span>
                            <i class="fas fa-external-link-alt" style="color: #007bff; margin-left: 8px; font-size: 0.8em;"></i>
                        </div>
                        <div class="validation-item clickable-validation" data-criterion="token" onclick="scrollToSection('tokenSettingsSection')" title="Cliquez pour aller aux paramètres de token">
                            <i class="fas fa-times-circle" style="color: #dc3545;"></i>
                            <span>Verifying alpha token information...</span>
                            <i class="fas fa-external-link-alt" style="color: #007bff; margin-left: 8px; font-size: 0.8em;"></i>
                        </div>
                        <div class="validation-item clickable-validation" data-criterion="watchlist" onclick="scrollToSection('watchAccountsSection')" title="Cliquez pour aller à la liste de surveillance">
                            <i class="fas fa-times-circle" style="color: #dc3545;"></i>
                            <span>Verifying target watchlist...</span>
                            <i class="fas fa-external-link-alt" style="color: #007bff; margin-left: 8px; font-size: 0.8em;"></i>
                        </div>
                    </div>
                </div>
                
                <!-- Bouton d'automation (désactivé par défaut) -->
                <div style="margin: 15px; text-align: center;">
                    <button id="toggleAutomationBtn" class="btn btn-danger btn-full" disabled 
                            data-automation-status="disabled" style="
                        font-size: 1.2em;
                        padding: 15px 25px;
                        border-radius: 10px;
                        font-weight: 600;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                        transition: all 0.3s ease;
                        cursor: not-allowed;
                        opacity: 0.6;
                    " onclick="validateAndToggleAutomation()">
                        <i class="fas fa-lock" style="margin-right: 10px;"></i>
                        RAID ENGINE LOCKED
                    </button>
                    
                    <!-- Important automation restart notice -->
                    <div style="
                        margin-top: 12px;
                        padding: 10px;
                        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
                        border: 1px solid #ffc107;
                        border-radius: 6px;
                        font-size: 0.85em;
                        color: #856404;
                        text-align: left;
                    ">
                        <div style="display: flex; align-items: center; margin-bottom: 5px;">
                            <i class="fas fa-exclamation-triangle" style="color: #ffc107; margin-right: 8px;"></i>
                            <b>Critical Configuration Notice:</b>
                        </div>
                        <div style="line-height: 1.4;">
                            After modifying <b>AI Token Settings</b>, <b>Global Quotas</b>, or <b>Target Lists</b>, 
                            always <b>STOP</b> the automation and <b>RESTART</b> it to ensure all changes are properly applied.
                            Configuration changes may not take effect on a running automation engine.
                        </div>
                    </div>
                </div>

                


                    
                    <div id="automationError" style="
                        margin-top: 15px;
                        padding: 12px;
                        background: #f8d7da;
                        border: 1px solid #f5c6cb;
                        border-radius: 6px;
                        color: #721c24;
                        font-weight: 500;
                        display: none;
                    ">
                        <i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                        <span id="automationErrorText">Criteria not met</span>
                    </div>
                </div>
            </div>

            <!-- 📊 AUTOMATION PROGRESS CARD -->
            <div class="card" style="border: 2px solid #28a745; box-shadow: 0 4px 20px rgba(40, 167, 69, 0.15); margin-top: 20px;">
                <div class="card-header">
                    <i class="fas fa-chart-line"></i>
                    <h3>📊 Automation Progress</h3>
                </div>
                
                <div style="margin: 15px;">
                    <!-- Current Step -->
                    <div class="automation-section">
                        <h4 style="color: #495057; margin: 0 0 10px 0; font-size: 1em; font-weight: 600;">
                            <i class="fas fa-cog" style="color: #6c757d; margin-right: 8px;"></i>Current Step
                        </h4>
                        <div id="currentStepStatus" class="automation-status-item">
                            🛠️ <span>Waiting for automation to start...</span>
                        </div>
                    </div>

                    <!-- Last Success -->
                    <div class="automation-section">
                        <h4 style="color: #495057; margin: 15px 0 10px 0; font-size: 1em; font-weight: 600;">
                            <i class="fas fa-check-circle" style="color: #28a745; margin-right: 8px;"></i>Last Success
                        </h4>
                        <div id="lastSuccessStatus" class="automation-status-item">
                            ✅ <span>No recent activity</span>
                        </div>
                    </div>

                    <!-- Errors / Warnings -->
                    <div class="automation-section">
                        <h4 style="color: #495057; margin: 15px 0 10px 0; font-size: 1em; font-weight: 600;">
                            <i class="fas fa-exclamation-triangle" style="color: #ffc107; margin-right: 8px;"></i>Errors / Warnings
                        </h4>
                        <div id="errorsStatus" class="automation-status-item">
                            ✅ <span>No errors detected</span>
                        </div>
                    </div>

                    <!-- Token Events -->
                    <div class="automation-section">
                        <h4 style="color: #495057; margin: 15px 0 10px 0; font-size: 1em; font-weight: 600;">
                            <i class="fas fa-key" style="color: #17a2b8; margin-right: 8px;"></i>Token Events
                        </h4>
                        <div id="tokenStatus" class="automation-status-item">
                            🔑 <span>Tokens are healthy</span>
                        </div>
                    </div>

                    <!-- Mute / Unmute -->
                    <div class="automation-section">
                        <h4 style="color: #495057; margin: 15px 0 10px 0; font-size: 1em; font-weight: 600;">
                            <i class="fas fa-volume-mute" style="color: #fd7e14; margin-right: 8px;"></i>Mute / Unmute
                        </h4>
                        <div id="muteStatus" class="automation-status-item">
                            🔓 <span>All accounts active</span>
                        </div>
                    </div>

                    <!-- Quota / System -->
                    <div class="automation-section">
                        <h4 style="color: #495057; margin: 15px 0 10px 0; font-size: 1em; font-weight: 600;">
                            <i class="fas fa-database" style="color: #6f42c1; margin-right: 8px;"></i>Quota / System
                        </h4>
                        <div id="quotaSystemStatus" class="automation-status-item">
                            🧮 <span>System ready</span>
                        </div>
                    </div>

                    <!-- Auto-refresh indicator -->
                    <div style="text-align: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <small style="color: #6c757d;">
                            <i class="fas fa-sync-alt" style="margin-right: 5px;"></i>
                            Auto-refreshes every 10 seconds
                        </small>
                    </div>
                </div>
            </div>

        <!-- Quotas Globaux Card -->
        <div class="card quota-overview" style="margin-top: 20px;">
            <div class="card-header">
                <i class="fas fa-battery-three-quarters" style="color: #FF9800; font-size: 1.8em; margin-right: 15px;"></i>
                <div>
                    <h3 style="margin: 0; color: var(--text-primary);">⚡ Global Quota</h3>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px; border-radius: 12px; margin: 10px 0; border-left: 4px solid #FF9800; width: 100%; box-sizing: border-box;">
                        <h4 style="margin: 0 0 8px 0; color: white; font-size: 1.1em;">
                            <i class="fas fa-brain" style="color: #FFD700; margin-right: 8px;"></i>
                            Smart AI Quota System
                        </h4>
                        <p style="margin: 0 0 8px 0; color: rgba(255,255,255,0.9); font-size: 0.95em; line-height: 1.4;">
                            <strong>🎯 AI-Driven Action Distribution!</strong><br>
                            Quotas represent total actions performed by all connected accounts (likes, retweets, replies).
                        </p>
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 8px 0;">
                            <div style="color: rgba(255,255,255,0.8); font-size: 0.85em; line-height: 1.4;">
                                <strong style="color: #FFD700;">AI Strategy:</strong><br>
                                → Every valuable tweet gets a reply (AI-generated)<br>
                                → Only 10% get liked (quality over quantity)<br>
                                → Only 5% get retweeted (strategic amplification)<br>
                                → Replies are the most impactful for raids!
                            </div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 8px 0;">
                            <div style="color: rgba(255,255,255,0.8); font-size: 0.85em; line-height: 1.4;">
                                <strong style="color: #FF6B6B;">Smart Protection:</strong><br>
                                → Daily quotas prevent X rate limits & shadowbans<br>
                                → AI automatically mutes accounts detecting risky activity<br>
                                → Everything is dynamic and adaptive<br>
                                → Daily quotas reset at 00:00 UTC+1 (24h cycle)
                            </div>
                        </div>
                        <p style="margin: 8px 0 0 0; color: #FFD700; font-size: 0.9em; font-weight: bold;">
                            <i class="fas fa-shield-alt" style="margin-right: 5px;"></i>
                            AI manages everything to maximize impact while staying safe!
                        </p>
                    </div>
                </div>
            </div>
            <div class="metric-row">
                <span class="metric-label">Global Quota Total</span>
                <span class="metric-value info" id="global-total">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Used</span>
                <span class="metric-value warning" id="global-used">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Remaining</span>
                <span class="metric-value success" id="global-remaining">-</span>
            </div>
            <div class="progress-bar" style="background: var(--bg-tertiary); border-radius: 10px; height: 8px; margin: 10px 0;">
                <div class="progress-fill" id="global-progress" style="width: 0%; background: linear-gradient(90deg, #4CAF50, #8BC34A); height: 100%; border-radius: 10px; transition: width 0.3s ease;"></div>
            </div>
            
            <div style="margin-top: 20px;">
                <div class="metric-row">
                    <span class="metric-label">Daily Limit</span>
                    <span class="metric-value info" id="daily-limit">-</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Used Today</span>
                    <span class="metric-value warning" id="daily-used">-</span>
                </div>
                <div class="progress-bar" style="background: var(--bg-tertiary); border-radius: 10px; height: 8px; margin: 10px 0;">
                    <div class="progress-fill" id="daily-progress" style="width: 0%; background: linear-gradient(90deg, #FF9800, #FFC107); height: 100%; border-radius: 10px; transition: width 0.3s ease;"></div>
                </div>
            </div>
        </div>

        <!-- Stats Cards Section -->
        <div class="dashboard" style="margin-top: 20px;">
            <!-- Actions Total -->
            <div class="card actions-total">
                <div class="card-header">
                    <i class="fas fa-chart-bar" style="color: #9C27B0; font-size: 1.8em; margin-right: 15px;"></i>
                <div>
                    <h3 style="margin: 0; color: var(--text-primary);">
                        <a href="actions-history.html" style="text-decoration: none; color: inherit; display: flex; align-items: center; gap: 8px;">
                            📊 Total History
                            <i class="fas fa-external-link-alt" style="font-size: 0.7em; opacity: 0.6;"></i>
                        </a>
                    </h3>
                    <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9em;">
                        All actions performed since the start
                    </p>
                </div>
            </div>
            <div class="metric-row">
                <span class="metric-label">Total Actions</span>
                <span class="metric-value info" id="actions-total-count">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">❤️ Likes</span>
                <span class="metric-value" style="color: #e91e63;" id="actions-total-likes">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">💬 Replies</span>
                <span class="metric-value" style="color: #2196f3;" id="actions-total-replies">-</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">🔄 Retweets</span>
                <span class="metric-value" style="color: #4caf50;" id="actions-total-retweets">-</span>
            </div>
        </div>

        <!-- Recent Activity -->
        <div class="card recent-activity">
            <div class="card-header">
                <i class="fas fa-clock" style="color: #F44336; font-size: 1.8em; margin-right: 15px;"></i>
                <div>
                    <h3 style="margin: 0; color: var(--text-primary);">
                        <a href="actions-history.html" style="text-decoration: none; color: inherit; display: flex; align-items: center; gap: 8px;">
                            ⚡ Recent Activity
                            <i class="fas fa-external-link-alt" style="font-size: 0.7em; opacity: 0.6;"></i>
                        </a>
                    </h3>
                    <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9em;">
                        Recent actions performed by your accounts
                    </p>
                </div>
            </div>
            <div id="recent-activity-list">
                <div class="loading" style="text-align: center; padding: 20px; color: var(--text-secondary);">
                    <i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Modern live logs block -->
    <div class="card mb-3" id="liveLogsCard" style="margin-top: 20px;">
        <div class="card-header" style="display:flex;align-items:center;gap:10px;cursor:pointer;" onclick="toggleLogsVisibility()">
            <i class="fas fa-terminal"></i>
            <h3 style="flex:1;">📊 Real-time Raid Engine Logs</h3>
            <div style="display:flex;align-items:center;gap:8px;">
                <span id="logsStatus" style="font-size:0.85em;color:#28a745;">
                    <i class="fas fa-circle" style="font-size:0.6em;"></i> WebSocket connected
                </span>
                <i class="fas fa-chevron-down" id="logsToggleIcon" style="font-size:0.9em;color:#666;transition:transform 0.3s ease;"></i>
            </div>
        </div>
        <div id="logsContent" style="display:none;">
            <div style="padding:10px;border-bottom:1px solid #e1e8ed;background:#f8f9fa;display:flex;align-items:center;gap:8px;">
                <button class="btn btn-secondary" id="pauseLogsBtn" onclick="toggleLogsPause()" style="padding:4px 8px;font-size:0.85em;">
                    <i class="fas fa-pause"></i> Pause
                </button>
                <button class="btn btn-primary" id="downloadLogsBtn" onclick="downloadFilteredLogs()" style="padding:4px 8px;font-size:0.85em;">
                    <i class="fas fa-download"></i> Download
                </button>
            </div>
        <div class="card-body" style="padding:0;">
            <div id="logsControls" style="padding:10px;border-bottom:1px solid #e1e8ed;background:#f8f9fa;">
                <div style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
                    <div style="display:flex;align-items:center;gap:5px;">
                        <label style="font-size:0.9em;color:#657786;">Filter by raid type:</label>
                        <select id="logTypeFilter" onchange="applyLogFilters()" style="padding:2px 5px;border:1px solid #ccc;border-radius:3px;">
                            <option value="all">All</option>
                            <option value="like">Likes</option>
                            <option value="retweet">Retweets</option>
                            <option value="reply">Alpha Replies</option>
                            <option value="system">System</option>
                            <option value="error">Errors</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:5px;">
                        <label style="font-size:0.9em;color:#657786;">Limit:</label>
                        <select id="logLimitSelect" onchange="changeLogLimit()" style="padding:2px 5px;border:1px solid #ccc;border-radius:3px;">
                            <option value="20">20</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:5px;">
                        <span style="font-size:0.9em;color:#657786;">Total: <strong id="logsTotalCount">0</strong></span>
                    </div>
                </div>
            </div>
            <div id="liveLogs" style="background:#f9fcff;border-radius:0 0 8px 8px;padding:15px;font-family:monospace;font-size:0.9em;line-height:1.5;max-height:400px;overflow-y:auto;overflow-x:hidden;white-space:pre-wrap;word-break:break-word;">
                <div style="text-align:center;color:#657786;padding:20px;">
                    <i class="fas fa-spinner fa-spin"></i> Connecting to raid logs...
                </div>
            </div>
        </div>
        </div>
    </div>

    <div class="card mb-3" id="tokenSettingsSection">
        <div class="card-header">
            <i class="fas fa-brain"></i>
            <h3>🧠 AI Alpha Token Settings</h3>
        </div>
        <div class="alert alert-info" style="margin-bottom: 18px;">
            <strong>Alpha Configuration:</strong><br>
            Configure how the AI will shill your token in alpha replies.<br>
            The <b>symbol</b>, <b>name</b>, <b>X handle</b>, and <b>chain</b> you enter here will be used by the AI to generate personalized alpha calls about your project.<br>
            <b>Each reply will highlight your token's moon potential and alpha opportunities.</b>
        </div>
        <div class="grid-2 mobile-stack">
            <div class="input-group">
                <label for="tokenSymbolInput">Token Symbol (with $):</label>
                <input type="text" id="tokenSymbolInput" class="form-control mobile-full-width" maxlength="12" placeholder="Ex: $PICA">
            </div>
            <div class="input-group">
                <label for="tokenNameInput">Token Name:</label>
                <input type="text" id="tokenNameInput" class="form-control mobile-full-width" maxlength="32" placeholder="Ex: Pineapple Cat">
            </div>
            <div class="input-group">
                <label for="tokenXInput">Token X Handle (with @):</label>
                <input type="text" id="tokenXInput" class="form-control mobile-full-width" maxlength="32" placeholder="Ex: @picaonbase">
            </div>
            <div class="input-group">
                <label for="tokenChainInput">Blockchain:</label>
                <input type="text" id="tokenChainInput" class="form-control mobile-full-width" maxlength="32" placeholder="Ex: Base">
            </div>
        </div>
        <button class="btn btn-primary btn-full mobile-full-width" id="saveAIPromptBtn"><i class="fas fa-save"></i> Save Alpha Settings</button>
        <div id="aiPromptStatus" class="mt-2"></div>
    </div>
        
       

        
        <div class="card mb-3" id="watchAccountsSection">
            <div class="card-header">
                <i class="fas fa-eye"></i>
                <h3>🎯 Degen Targets to Raid</h3>
            </div>
            <div class="alert alert-info" style="margin-bottom: 18px;">
                <strong>Target Configuration:</strong><br>
                Enter the X usernames (without @) of alpha accounts you want to monitor for new tweets.<br>
                When these degens post fresh content, the automation will engage with likes, retweets, and alpha replies to maximize exposure.<br>
                <b>Separate multiple usernames with commas for maximum raid efficiency.</b>
            </div>
            <div class="input-group">
                <label for="watchAccountsAddInput">Alpha Accounts to Monitor:</label>
                <div style="display:flex;gap:10px;margin-bottom:10px;">
                    <textarea id="watchAccountsAddInput" class="form-control" rows="2" placeholder="elonmusk\nheci.base.eth\nLarpVonTrier" style="max-width:320px;resize:vertical;"></textarea>
                    <div style="display:flex;flex-direction:column;gap:5px;">
                        <button class="btn btn-primary" onclick="addWatchAccount()"><i class="fas fa-plus"></i> Add Raid Target</button>
                        <button class="btn btn-danger btn-sm" onclick="clearAllWatchAccounts()" title="Clear all targets"><i class="fas fa-trash-alt"></i> Clear All</button>
                    </div>
                </div>
                <ul id="watchAccountsList" style="list-style:none;padding:0;margin:0;"></ul>
            </div>
        </div>

                        <div class="card mb-3" id="replyImagesSection">
            <div class="card-header">
                <i class="fas fa-images"></i>
                <h3>🖼️ Auto-Reply Images</h3>
            </div>
            <div class="alert alert-info" style="margin-bottom: 18px;">
                <strong>Image Reply System:</strong><br>
                Upload up to 20 images that will be randomly attached to 10% of your automated replies.<br>
                <b>Max size: 3MB per image. Supported formats: JPG, PNG, GIF, WEBP.</b>
            </div>
            <div class="input-group">
                <label for="replyImagesUpload">Upload Reply Images:</label>
                <div style="display:flex;gap:10px;margin-bottom:15px;align-items:center;">
                    <input type="file" id="replyImagesUpload" class="form-control" multiple accept="image/*" style="max-width:300px;">
                    <button class="btn btn-primary" onclick="uploadReplyImages()"><i class="fas fa-upload"></i> Upload Images</button>
                    <button class="btn btn-danger btn-sm" onclick="clearAllReplyImages()" title="Clear all images"><i class="fas fa-trash-alt"></i> Clear All</button>
                </div>
                <div style="margin-bottom:15px;">
                    <label>
                        <input type="checkbox" id="enableImageReplies" onchange="toggleImageReplies()"> 
                        Enable automatic image replies (10% chance)
                    </label>
                </div>
                <div id="replyImagesGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px;margin-top:15px;"></div>
                <div id="replyImagesStatus" style="margin-top:10px;font-size:14px;color:#666;"></div>
            </div>
        </div>

                        <div class="card mb-3" id="raidWalletsSection">
            <div class="card-header">
                <i class="fas fa-users"></i>
                <h3>👥 Raid X Account Management</h3>
            </div>
            <div class="alert alert-info" style="margin-bottom: 18px;">
                <strong>Connect Your Raid Army:</strong><br>
                Add multiple X accounts to maximize your raid power and alpha reach.<br>
                Each connected wallet will participate in automated likes, retweets, and alpha shilling.<br>
                <b>More accounts = more engagement = better alpha distribution = moon mission success.</b>
            </div>
            <div class="grid-2 mobile-stack">
                <div>
                    <button class="btn btn-primary btn-full mobile-full-width" onclick="generateInvitationToken()">
                        <i class="fas fa-link"></i>
                        Generate X Raid Invitation Link
                    </button>
                </div>
                <div class="input-group">
                    <label for="accountSelect">Raid Wallets:</label>
                    <select id="accountSelect" class="form-control mobile-full-width" onchange="updateSelectedAccount()">
                        <option value="">No raid wallet selected</option>
                    </select>
                </div>
            </div>
            <div id="accountsList" class="accounts-list mt-3"></div>
        </div>

        

        

    </div> 
    <button class="floating-btn refresh-btn" onclick="refreshDashboard()" title="Refresh data">
        <i class="fas fa-sync-alt"></i>
    </button>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // --- Configuration Globale et Variables ---
        window.API_BASE_URL = 'http://localhost:3005';
        let defaultAccountId = null;
        let watchAccounts = [];
        
        // WebSocket pour logs temps réel
        let socket = null;
        let logsData = {
            logs: [],
            total: 0,
            hasMore: false,
            currentOffset: 0,
            limit: 20
        };
        let logsPaused = false;
        let currentLogFilter = 'all';


        // --- Theme Management ---
        function initializeTheme() {
            // Récupérer la préférence sauvegardée ou utiliser le thème système
            const savedTheme = localStorage.getItem('x-autoraider-theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialTheme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
            
            setTheme(initialTheme);
            
            // Écouter les changements de préférence système
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                if (!localStorage.getItem('x-autoraider-theme')) {
                    setTheme(e.matches ? 'dark' : 'light');
                }
            });
        }
        
        function setTheme(theme) {
            const root = document.documentElement;
            const themeToggleBtn = document.getElementById('themeToggle');
            const themeIcon = themeToggleBtn?.querySelector('i');
            
            if (theme === 'dark') {
                root.setAttribute('data-theme', 'dark');
                if (themeIcon) {
                    themeIcon.className = 'fas fa-sun';
                    themeToggleBtn.title = 'Switch to Light Theme';
                }
            } else {
                root.removeAttribute('data-theme');
                if (themeIcon) {
                    themeIcon.className = 'fas fa-moon';
                    themeToggleBtn.title = 'Switch to Dark Theme';
                }
            }
            
            // Save theme preference
            localStorage.setItem('x-autoraider-theme', theme);
            
            // Animation du bouton
            if (themeToggleBtn) {
                themeToggleBtn.style.transform = 'scale(0.8) rotate(180deg)';
                setTimeout(() => {
                    themeToggleBtn.style.transform = 'scale(1) rotate(0deg)';
                }, 200);
            }
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
            
            // Feedback visuel avec animation
            const btn = document.getElementById('themeToggle');
            if (btn) {
                btn.style.boxShadow = '0 0 20px var(--primary-color)';
                setTimeout(() => {
                    btn.style.boxShadow = '';
                }, 300);
            }
        }
        
        // Exposer globalement pour le onclick
        window.toggleTheme = toggleTheme;

        /**
         * Gestion des erreurs OAuth et messages d'URL
         */
        function handleURLMessages() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Vérifier les erreurs OAuth2
            if (urlParams.has('error')) {
                const errorType = urlParams.get('error');
                const errorMessage = urlParams.get('message') || 'Erreur inconnue';
                const errorCode = urlParams.get('code') || '';
                
                console.error('[OAUTH] Erreur détectée dans l\'URL:', { errorType, errorMessage, errorCode });
                
                // Afficher une notification d'erreur
                showOAuthErrorNotification(errorType, errorMessage, errorCode);
                
                // Nettoyer l'URL pour éviter que l'erreur reste affichée
                const cleanUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);
            }
            
            // Vérifier les messages de succès
            if (urlParams.has('success')) {
                const successType = urlParams.get('success');
                const username = urlParams.get('username');
                const automationStopped = urlParams.get('automation_stopped');
                
                console.log('[OAUTH] Succès détecté dans l\'URL:', { successType, username, automationStopped });
                
                // Afficher une notification de succès
                showOAuthSuccessNotification(successType, username, automationStopped === 'true');
                
                // Nettoyer l'URL
                const cleanUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);
                
                // Recharger les données pour refléter le nouveau compte
                setTimeout(() => {
                    loadAccounts();
                    refreshDashboard();
                }, 1000);
            }
        }

        /**
         * Afficher une notification d'erreur OAuth
         */
        function showOAuthErrorNotification(errorType, errorMessage, errorCode) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
                color: white;
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
                z-index: 10001;
                max-width: 400px;
                animation: slideInRight 0.5s ease-out;
                border-left: 5px solid #a93226;
            `;
            
            let errorTitle = 'Erreur d\'authentification';
            let errorDescription = errorMessage;
            
            // Messages spécifiques selon le type d'erreur
            switch(errorType) {
                case 'oauth2_callback_failed':
                    errorTitle = 'Échec de connexion OAuth2';
                    if (errorCode === '401') {
                        errorDescription = 'Authentification refusée. Vérifiez que l\'application est autorisée sur votre compte Twitter.';
                    } else if (errorCode === '400') {
                        errorDescription = 'Code d\'autorisation invalide ou expiré. Veuillez réessayer la connexion.';
                    }
                    break;
                default:
                    errorTitle = 'Erreur de connexion';
                    break;
            }
            
            notification.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 1.5em; margin-top: 2px;"></i>
                    <div style="flex: 1;">
                        <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 8px;">${errorTitle}</div>
                        <div style="font-size: 0.95em; line-height: 1.4; margin-bottom: 12px;">${errorDescription}</div>
                        ${errorCode ? `<div style="font-size: 0.8em; opacity: 0.8;">Code d'erreur: ${errorCode}</div>` : ''}
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                            background: rgba(255,255,255,0.2);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.9em;
                            margin-top: 10px;
                        ">Fermer</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-suppression après 10 secondes
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 10000);
        }

        /**
         * Afficher une notification de succès OAuth
         */
        function showOAuthSuccessNotification(successType, username, automationStopped = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
                color: white;
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 8px 25px rgba(39, 174, 96, 0.3);
                z-index: 10001;
                max-width: 400px;
                animation: slideInRight 0.5s ease-out;
                border-left: 5px solid #229954;
            `;
            
            let successTitle = 'Connexion réussie !';
            let successDescription = `Le compte @${username} a été connecté avec succès.`;
            
            if (successType === 'oauth2_connected') {
                successTitle = 'Account Connected!';
                if (automationStopped) {
                    successDescription = `Account @${username} added successfully. Please restart automation to include this account.`;
                } else {
                    successDescription = `@${username} est maintenant connecté via OAuth 2.0 et prêt pour l'automatisation.`;
                }
            }
            
            notification.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <i class="fas fa-check-circle" style="font-size: 1.5em; margin-top: 2px;"></i>
                    <div style="flex: 1;">
                        <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 8px;">${successTitle}</div>
                        <div style="font-size: 0.95em; line-height: 1.4; margin-bottom: 12px;">${successDescription}</div>
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                            background: rgba(255,255,255,0.2);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.9em;
                        ">Fermer</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-suppression après 5 secondes
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // Add CSS animations for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
        `;
        document.head.appendChild(style);

        // Initialiser la gestion des messages d'URL au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            handleURLMessages();
        });

        // Si le DOM est déjà chargé, exécuter immédiatement
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', handleURLMessages);
        } else {
            handleURLMessages();
        }

        // --- Fonctions Utilitaires ---
        function escapeHTML(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getTypeColor(type) {
            switch (type) {
                case 'like': return '#e91e63';
                case 'retweet': return '#1da1f2';
                case 'reply': return '#17bf63';
                case 'automation': return '#ff9800';
                case 'system': return '#6c757d';
                default: return '#17a2b8';
            }
        }

        async function loadRecentActivity() {
            const container = document.getElementById('recentActivityContainer');
            if (!container) return;

            try {
                const res = await fetch(`${API_BASE_URL}/api/dashboard/recent-activity?hours=24`);
                const data = await res.json();

                if (!res.ok || !data.success) {
                    throw new Error(data.error || 'Failed to load recent activity');
                }

                const activities = data.data;
                if (activities.length === 0) {
                    container.innerHTML = '<p style="text-align:center;color:#666;">No recent activity in the last 24 hours.</p>';
                    return;
                }

                const actionIcons = {
                    like: 'fas fa-heart text-danger',
                    retweet: 'fas fa-retweet text-success',
                    reply: 'fas fa-reply text-info',
                    comment: 'fas fa-comment text-info'
                };

                let html = activities.slice(0, 3).map(act => `
                    <div style="display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #eee;">
                        <i class="${actionIcons[act.actionType] || 'fas fa-question-circle'}" style="font-size: 1.2em; margin-right: 12px; width: 20px;"></i>
                        <div style="flex: 1; font-size: 0.9em;">
                            <strong>@${act.username}</strong> ${act.actionType}d a tweet
                        </div>
                        <span style="font-size: 0.85em; color: #666;">${act.timeAgo} ago</span>
                    </div>
                `).join('');

                container.innerHTML = html;

            } catch (error) {
                console.error('Error loading recent activity:', error);
                container.innerHTML = `<p style="text-align:center;color:#d9534f;">Error loading activity.</p>`;
            }
        }

        // --- Gestion de l'UI (Interface Utilisateur) ---
        function updateSelectedAccount() {
            const select = document.getElementById('accountSelect');
            defaultAccountId = select.value;
        }

        function updateAutomationStatus(isEnabled) {
            const statusEl = document.getElementById('automationStatus');
            const activityIndicator = document.getElementById('automationActivityIndicator');
            const progressContainer = document.getElementById('automationProgressContainer');

            if (statusEl) {
                statusEl.className = isEnabled ? 'status-badge status-active' : 'status-badge status-inactive';
                statusEl.innerHTML = isEnabled ?
                    '<i class="fas fa-bolt electric-bolt"></i> Automation Active' :
                    '<i class="fas fa-pause-circle"></i> Automation Paused';
            }
            
            // Gestion des animations
            if (isEnabled) {
                // Afficher les indicateurs d'activité
                if (activityIndicator) activityIndicator.style.display = 'block';
                if (progressContainer) progressContainer.style.display = 'block';
                
                // Démarrer le countdown (10 minutes = 600000ms)
                if (typeof startAutomationCountdown === 'function') {
                    startAutomationCountdown(600000);
                }
            } else {
                // Masquer les indicateurs d'activité
                if (activityIndicator) activityIndicator.style.display = 'none';
                if (progressContainer) progressContainer.style.display = 'none';
                
                // Arrêter le countdown
                if (typeof stopAutomationCountdown === 'function') {
                    stopAutomationCountdown();
                }
            }
        }

        // --- Fonctions API (Communication avec le Backend) ---

        // Gestion des Comptes
        async function loadAccounts() {
            try {
                const res = await fetch(`${API_BASE_URL}/api/accounts`);
                const data = await res.json();
                
                // Vérifier si la réponse contient un tableau d'accounts
                const accounts = Array.isArray(data) ? data : (data.accounts || []);
                
                const select = document.getElementById('accountSelect');
                const listDiv = document.getElementById('accountsList');
                select.innerHTML = '';
                
                if (accounts.length === 0) {
                    listDiv.innerHTML = '<i>No account connected.</i>';
                    select.innerHTML = '<option>No account available</option>';
                    return;
                }

                accounts.forEach(acc => {
                    const opt = document.createElement('option');
                    opt.value = acc.id;
                    opt.textContent = `@${acc.username}`;
                    select.appendChild(opt);
                });

                if (!defaultAccountId || !accounts.find(a => a.id === defaultAccountId)) {
                    defaultAccountId = accounts[0].id;
                }
                select.value = defaultAccountId;

                listDiv.innerHTML = `<b>Connected accounts:</b><ul style='list-style:none;padding:0;margin:0;'>` +
                    accounts.map(a => `
                        <li style='display:flex;align-items:center;gap:10px;margin:8px 0;'>
                            <span style='font-weight:500;'>@${a.username}</span>
                            <button class='btn btn-danger btn-icon' title='Remove account' onclick='removeAccount("${a.id}")'>
                                <i class='fas fa-trash'></i>
                            </button>
                        </li>`).join('') + '</ul>';
            } catch (error) {
                console.error('Error loading accounts:', error);
                document.getElementById('accountsList').innerHTML = '<i>Error loading accounts.</i>';
            }
        }

        async function removeAccount(accountId) {
            if (!confirm('Are you sure you want to remove this X account from the platform?')) return;
            try {
                const res = await fetch(`${API_BASE_URL}/api/account?accountId=${encodeURIComponent(accountId)}`, { method: 'DELETE' });
                if (res.ok) {
                    alert('Account removed successfully.');
                    loadAccounts();
                } else {
                    const data = await res.json();
                    alert('Error: ' + (data.error || 'Unknown error.'));
                }
            } catch (err) {
                alert('Network error: ' + err.message);
            }
        }

        async function generateInvitationToken() {
            try {
                const res = await fetch(`${API_BASE_URL}/api/admin/projects/default/invite`, { method: 'POST' });
                if (!res.ok) throw new Error('Failed to generate invitation link.');
                const data = await res.json();
                if (data.inviteUrl) {
                    // Tentative de copie dans le clipboard avec fallback
                    let clipboardSuccess = false;
                    try {
                        // Vérifier si l'API clipboard est disponible et le document focalisé
                        if (navigator.clipboard && document.hasFocus()) {
                            await navigator.clipboard.writeText(data.inviteUrl);
                            clipboardSuccess = true;
                        } else {
                            // Fallback: méthode alternative de copie
                            const textArea = document.createElement('textarea');
                            textArea.value = data.inviteUrl;
                            textArea.style.position = 'fixed';
                            textArea.style.left = '-999999px';
                            textArea.style.top = '-999999px';
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            
                            try {
                                clipboardSuccess = document.execCommand('copy');
                            } catch (fallbackErr) {
                                console.warn('Fallback copy failed:', fallbackErr);
                            }
                            
                            document.body.removeChild(textArea);
                        }
                    } catch (clipboardErr) {
                        console.warn('Clipboard operation failed:', clipboardErr);
                        // Essayer la méthode fallback
                        try {
                            const textArea = document.createElement('textarea');
                            textArea.value = data.inviteUrl;
                            textArea.style.position = 'fixed';
                            textArea.style.left = '-999999px';
                            textArea.style.top = '-999999px';
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            clipboardSuccess = document.execCommand('copy');
                            document.body.removeChild(textArea);
                        } catch (fallbackErr) {
                            console.warn('All copy methods failed:', fallbackErr);
                        }
                    }
                    
                    // Message adapté selon le succès de la copie
                    if (clipboardSuccess) {
                        alert(`✅ Invitation link copied to clipboard!\n\n${data.inviteUrl}`);
                    } else {
                        // Créer une boîte de dialogue personnalisée pour sélectionner le texte
                        const modal = document.createElement('div');
                        modal.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0,0,0,0.8);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            z-index: 10000;
                        `;
                        
                        const content = document.createElement('div');
                        content.style.cssText = `
                            background: white;
                            padding: 30px;
                            border-radius: 12px;
                            max-width: 600px;
                            width: 90%;
                            text-align: center;
                        `;
                        
                        content.innerHTML = `
                            <h3 style="color: #1da1f2; margin-bottom: 15px;">🔗 Lien d'invitation généré</h3>
                            <p style="margin-bottom: 15px;">Copiez manuellement le lien ci-dessous :</p>
                            <input type="text" value="${data.inviteUrl}" readonly 
                                   style="width: 100%; padding: 10px; border: 2px solid #1da1f2; border-radius: 6px; margin-bottom: 15px; font-family: monospace;" 
                                   onclick="this.select()" id="inviteUrlInput">
                            <div>
                                <button onclick="document.getElementById('inviteUrlInput').select(); document.execCommand('copy'); this.textContent='✅ Copié!'; setTimeout(() => this.textContent='📋 Copier', 2000);" 
                                        style="background: #1da1f2; color: white; border: none; padding: 10px 20px; border-radius: 6px; margin-right: 10px; cursor: pointer;">📋 Copy</button>
                                <button onclick="document.body.removeChild(this.closest('div').parentElement.parentElement)" 
                                        style="background: #657786; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Close</button>
                            </div>
                        `;
                        
                        modal.appendChild(content);
                        document.body.appendChild(modal);
                        
                        // Auto-sélection du texte
                        setTimeout(() => {
                            const input = document.getElementById('inviteUrlInput');
                            if (input) input.select();
                        }, 100);
                    }
                } else {
                    throw new Error('No invitation URL received from server.');
                }
            } catch (err) {
                alert('❌ Error generating invitation link: ' + err.message);
                console.error('Error generating token:', err);
            }
        }
        
        // Gestion des Paramètres (Token & Surveillance)
        function loadTokenSettings() {
            document.getElementById('tokenSymbolInput').value = localStorage.getItem('ai_token_symbol') || '$PICA';
            document.getElementById('tokenNameInput').value = localStorage.getItem('ai_token_name') || 'Pineapple Cat';
            document.getElementById('tokenXInput').value = localStorage.getItem('ai_token_x') || '@picaonbase';
            document.getElementById('tokenChainInput').value = localStorage.getItem('ai_token_chain') || 'Base';
        }
        
        async function saveTokenSettings() {
            const statusDiv = document.getElementById('aiPromptStatus');
            try {
                const settings = {
                    tokenSymbol: document.getElementById('tokenSymbolInput').value.trim(),
                    tokenName: document.getElementById('tokenNameInput').value.trim(),
                    tokenX: document.getElementById('tokenXInput').value.trim(),
                    tokenChain: document.getElementById('tokenChainInput').value.trim()
                };
                
                localStorage.setItem('ai_token_symbol', settings.tokenSymbol);
                localStorage.setItem('ai_token_name', settings.tokenName);
                localStorage.setItem('ai_token_x', settings.tokenX);
                localStorage.setItem('ai_token_chain', settings.tokenChain);

                const res = await fetch('/api/token-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                
                statusDiv.innerHTML = res.ok ? 
                    '<span style="color:var(--success-color)">Token settings saved!</span>' :
                    '<span style="color:var(--danger-color)">Error saving token settings.</span>';

            } catch (e) {
                statusDiv.innerHTML = `<span style="color:var(--danger-color)">Network error: ${e.message}</span>`;
            }
        }

        async function loadWatchAccounts() {
            try {
                const res = await fetch(`${API_BASE_URL}/api/watch-accounts`);
                const data = await res.json();
                let accounts = Array.isArray(data.watchAccounts) ? data.watchAccounts : (Array.isArray(data) ? data : []);
                updateWatchAccountsList(accounts);
            } catch (error) {
                console.error('Error loading monitored accounts:', error);
            }
        }

        function updateWatchAccountsList(accounts) {
            const ul = document.getElementById('watchAccountsList');
            ul.innerHTML = '';
            if (!accounts || accounts.length === 0) {
                ul.innerHTML = `<li style='color:#888;font-style:italic;'>No Alpha accounts monitored yet.</li>`;
                return;
            }
            accounts.forEach(account => {
                // Gérer les deux formats possibles : string ou objet
                let pseudo, displayName;
                if (typeof account === 'string') {
                    // Format simple : juste le pseudo
                    pseudo = account;
                    displayName = account;
                } else if (typeof account === 'object' && account !== null) {
                    // Format objet : extraire le pseudo
                    pseudo = account.username || account.id || account.pseudo || 'unknown';
                    displayName = account.username || account.id || account.pseudo || 'unknown';
                } else {
                    // Fallback pour les cas inattendus
                    console.warn('[WATCH-ACCOUNTS] Format de compte inattendu:', account);
                    pseudo = 'unknown';
                    displayName = 'unknown';
                }
                
                const li = document.createElement('li');
                li.style.display = 'flex';
                li.style.alignItems = 'center';
                li.style.gap = '10px';
                li.style.margin = '6px 0';
                li.innerHTML = `<span style='font-weight:500;'>@${displayName}</span>` +
                    `<button class='btn btn-danger btn-icon' title='Remove this Alpha account' onclick='removeWatchAccount("${pseudo}")'><i class='fas fa-trash'></i></button>`;
                ul.appendChild(li);
            });
        }

        async function addWatchAccount() {
            const input = document.getElementById('watchAccountsAddInput');
            const pseudos = input.value.split('\n').map(p => p.trim().replace(/^@/, '')).filter(Boolean);
            if (pseudos.length === 0) return;
            try {
                // Get current accounts first
                const currentRes = await fetch(`${API_BASE_URL}/api/watch-accounts`);
                const currentData = await currentRes.json();
                let currentAccounts = Array.isArray(currentData.watchAccounts) ? currentData.watchAccounts : (Array.isArray(currentData) ? currentData : []);
                
                // Convert current accounts to simple strings for comparison
                const currentPseudos = currentAccounts.map(acc => {
                    if (typeof acc === 'string') return acc;
                    return acc.username || acc.id || acc.pseudo || 'unknown';
                });
                
                // Filter out duplicates
                const newPseudos = pseudos.filter(pseudo => !currentPseudos.includes(pseudo));
                
                if (newPseudos.length === 0) {
                    alert('All accounts are already in the list!');
                    input.value = '';
                    return;
                }
                
                // Add only new accounts
                await fetch(`${API_BASE_URL}/api/watch-accounts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pseudos: newPseudos })
                });
                
                if (newPseudos.length < pseudos.length) {
                    alert(`Added ${newPseudos.length} new accounts. ${pseudos.length - newPseudos.length} were already in the list.`);
                }
                
                input.value = '';
                loadWatchAccounts();
                
                // Déclencher immédiatement la re-validation de l'automation
                setTimeout(() => {
                    validateAutomationCriteria();
                }, 500);
                
                // Load initial data
                refreshAnalytics();
                
                // Load Smart Scheduler data (with safety checks)
                if (typeof loadSmartSchedulerConfig === 'function') {
                    loadSmartSchedulerConfig();
                } else {
                    console.log('[SMART-SCHEDULER] loadSmartSchedulerConfig not available yet');
                }
                
                if (typeof loadSmartSchedulerStats === 'function') {
                    loadSmartSchedulerStats();
                } else {
                    console.log('[SMART-SCHEDULER] loadSmartSchedulerStats not available yet');
                }
                
                if (typeof loadSmartSchedulerQueue === 'function') {
                    loadSmartSchedulerQueue();
                } else {
                    console.log('[SMART-SCHEDULER] loadSmartSchedulerQueue not available yet');
                }
                
                // Load influencer data
                if (typeof loadInfluencerStats === 'function') {
                    loadInfluencerStats();
                } else {
                    console.log('[INFLUENCER] loadInfluencerStats not available yet');
                }
                
                if (typeof loadRecentInfluencerInteractions === 'function') {
                    loadRecentInfluencerInteractions();
                } else {
                    console.log('[INFLUENCER] loadRecentInfluencerInteractions not available yet');
                }
            } catch (error) {
                alert('Error adding Alpha accounts: ' + error.message);
            }
        }
        
        // Fonction de validation des critères d'automation (SANS mise à jour du bouton)
        async function validateAutomationCriteria() {
            try {
                console.log('[AUTOMATION] Validation des critères en cours...');
                
                // Vérifier les comptes connectés
                const accountsResponse = await fetch(`${API_BASE_URL}/api/accounts`);
                const accountsData = await accountsResponse.json();
                const connectedAccounts = accountsData.accounts || [];
                
                // Vérifier les comptes à surveiller
                const watchResponse = await fetch(`${API_BASE_URL}/api/watch-accounts`);
                const watchData = await watchResponse.json();
                const watchAccounts = watchData.watchAccounts || [];
                
                // Vérifier les tokens AI
                const hasOpenAIToken = document.getElementById('openaiApiKey')?.value?.trim() || false;
                
                // Mise à jour des critères de validation UNIQUEMENT
                updateValidationCriterion('accounts', connectedAccounts.length > 0, 
                    connectedAccounts.length > 0 ? 
                    `✅ ${connectedAccounts.length} account connected` : 
                    '❌ You need to connect X account');
                
                updateValidationCriterion('watchlist', watchAccounts.length > 0, 
                    watchAccounts.length > 0 ? 
                    `✅ ${watchAccounts.length} account to watch` : 
                    '❌ You need to connect X account');
                
                updateValidationCriterion('token', hasOpenAIToken, 
                    hasOpenAIToken ? 
                    '✅ Token information OK' : 
                    '❌ Token information missing');
                
                // Retourner le résultat SANS modifier le bouton
                const allCriteriaMet = connectedAccounts.length > 0 && watchAccounts.length > 0 && hasOpenAIToken;
                
                console.log(`[AUTOMATION] Critères: ${allCriteriaMet ? '✅ Remplis' : '❌ Manquants'}`);
                return allCriteriaMet;
                
            } catch (error) {
                console.error('[AUTOMATION] Erreur lors de la validation:', error);
                return false;
            }
        }
        
        // Fonction utilitaire pour mettre à jour un critère de validation
        function updateValidationCriterion(criterion, isValid, message) {
            const criterionElement = document.querySelector(`[data-criterion="${criterion}"]`);
            if (criterionElement) {
                const icon = criterionElement.querySelector('i');
                const span = criterionElement.querySelector('span');
                
                if (isValid) {
                    icon.className = 'fas fa-check-circle';
                    icon.style.color = '#28a745';
                } else {
                    icon.className = 'fas fa-times-circle';
                    icon.style.color = '#dc3545';
                }
                
                if (span) {
                    span.textContent = message;
                }
            }
        }
        
        // FONCTION PRINCIPALE - Gestion unifiée du bouton automation
        async function validateAndToggleAutomation() {
            console.log('[BUTTON] Clic sur le bouton automation');
            
            try {
                // Appeler directement toggleAutomation sans validation complexe
                await toggleAutomation();
            } catch (error) {
                console.error('[BUTTON] Erreur:', error);
                showNotification('Erreur: ' + error.message, 'error');
            }
        }

        // Variable globale pour l'état automation
        let globalAutomationState = {
            isEnabled: false,
            lastSync: 0,
            syncing: false
        };

        // Source unique de vérité pour l'état automation
        async function syncAutomationState() {
            if (globalAutomationState.syncing) return;
            
            try {
                globalAutomationState.syncing = true;
                const response = await fetch(`${API_BASE_URL}/api/automation-status`);
                const data = await response.json();
                
                const stateChanged = globalAutomationState.isEnabled !== data.isAutomationEnabled;
                globalAutomationState.isEnabled = data.isAutomationEnabled;
                globalAutomationState.lastSync = Date.now();
                
                // Mettre à jour le bouton seulement si l'état a changé
                if (stateChanged) {
                    updateAutomationButtonFromGlobalState();
                }
            } catch (error) {
                console.warn('[SYNC] Erreur synchronisation automation:', error.message);
            } finally {
                globalAutomationState.syncing = false;
            }
        }

        // FONCTION UNIQUE - Gestion du bouton automation
        function updateAutomationButtonFromGlobalState() {
            const toggleBtn = document.getElementById('toggleAutomationBtn');
            if (!toggleBtn) return;
            
            console.log('[BUTTON] Mise à jour bouton, état:', globalAutomationState.isEnabled);
            
            if (globalAutomationState.isEnabled) {
                // AUTOMATION ACTIVE
                toggleBtn.disabled = false;
                toggleBtn.className = 'btn btn-warning btn-full';
                toggleBtn.innerHTML = '<i class="fas fa-stop"></i>🛑 STOP AUTOMATION';
                toggleBtn.dataset.automationStatus = 'active';
                updateAutomationStatus(true);
            } else {
                // AUTOMATION INACTIVE
                toggleBtn.disabled = false;
                toggleBtn.className = 'btn btn-success btn-full btn-automation-ready automation-pulse';
                toggleBtn.innerHTML = '<i class="fas fa-rocket"></i>🚀 LAUNCH AUTOMATION';
                toggleBtn.dataset.automationStatus = 'ready';
                updateAutomationStatus(false);
            }
        }

        async function removeWatchAccount(pseudo) {
            try {
                await fetch(`${API_BASE_URL}/api/watch-accounts`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: pseudo })
                });
                loadWatchAccounts();
                
                // Déclencher immédiatement la re-validation de l'automation
                setTimeout(() => {
                    validateAutomationCriteria();
                }, 500);
            } catch (error) {
                console.error('Error removing monitored account:', error);
            }
        }

        async function clearAllWatchAccounts() {
            if (!confirm('Are you sure you want to clear all raid targets? This action cannot be undone.')) {
                return;
            }
            
            try {
                // Get current accounts
                const res = await fetch(`${API_BASE_URL}/api/watch-accounts`);
                const data = await res.json();
                let accounts = Array.isArray(data.watchAccounts) ? data.watchAccounts : (Array.isArray(data) ? data : []);
                
                // Remove each account
                for (const account of accounts) {
                    const pseudo = typeof account === 'string' ? account : (account.username || account.id || account.pseudo);
                    if (pseudo) {
                        await fetch(`${API_BASE_URL}/api/watch-accounts`, {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ username: pseudo })
                        });
                    }
                }
                
                loadWatchAccounts();
                
                // Déclencher immédiatement la re-validation de l'automation
                setTimeout(() => {
                    validateAutomationCriteria();
                }, 500);
                
                alert('All raid targets have been cleared successfully!');
            } catch (error) {
                console.error('Error clearing all monitored accounts:', error);
                alert('Error clearing accounts. Please try again.');
            }
        }

        async function saveWatchAccounts() {
            // Supprimé
        }

        // ===== REPLY IMAGES MANAGEMENT =====
        
        async function loadReplyImages() {
            try {
                const res = await fetch(`${API_BASE_URL}/api/reply-images`);
                const data = await res.json();
                updateReplyImagesGrid(data.images || []);
                updateReplyImagesStatus(data.images || []);
                
                // Load settings
                const settingsRes = await fetch(`${API_BASE_URL}/api/reply-images/settings`);
                const settings = await settingsRes.json();
                document.getElementById('enableImageReplies').checked = settings.enabled || false;
            } catch (error) {
                console.error('Error loading reply images:', error);
            }
        }

        function updateReplyImagesGrid(images) {
            const grid = document.getElementById('replyImagesGrid');
            grid.innerHTML = '';
            
            if (images.length === 0) {
                grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;color:#888;font-style:italic;padding:20px;">No images uploaded yet. Upload some images to enable automatic image replies.</div>';
                return;
            }
            
            images.forEach(image => {
                const div = document.createElement('div');
                div.style.cssText = 'position:relative;border:2px solid #ddd;border-radius:8px;overflow:hidden;aspect-ratio:1;background:#f5f5f5;';
                div.innerHTML = `
                    <img src="${API_BASE_URL}/api/reply-images/${image.filename}" 
                         style="width:100%;height:100%;object-fit:cover;" 
                         alt="${image.filename}">
                    <button onclick="deleteReplyImage('${image.filename}')" 
                            style="position:absolute;top:5px;right:5px;background:rgba(255,0,0,0.8);color:white;border:none;border-radius:50%;width:24px;height:24px;cursor:pointer;font-size:12px;"
                            title="Delete image">×</button>
                    <div style="position:absolute;bottom:0;left:0;right:0;background:rgba(0,0,0,0.7);color:white;padding:4px;font-size:10px;text-align:center;">
                        ${(image.size / 1024 / 1024).toFixed(1)}MB
                    </div>
                `;
                grid.appendChild(div);
            });
        }

        function updateReplyImagesStatus(images) {
            const status = document.getElementById('replyImagesStatus');
            const count = images.length;
            const totalSize = images.reduce((sum, img) => sum + img.size, 0);
            const totalSizeMB = (totalSize / 1024 / 1024).toFixed(1);
            
            status.innerHTML = `📊 ${count}/20 images uploaded • Total size: ${totalSizeMB}MB`;
            
            if (count >= 20) {
                status.innerHTML += ' • <span style="color:#ff6b6b;">Maximum reached</span>';
            }
        }

        async function uploadReplyImages() {
            const input = document.getElementById('replyImagesUpload');
            const files = Array.from(input.files);
            
            if (files.length === 0) {
                alert('Please select images to upload.');
                return;
            }
            
            // Check current count
            const res = await fetch(`${API_BASE_URL}/api/reply-images`);
            const data = await res.json();
            const currentCount = (data.images || []).length;
            
            if (currentCount + files.length > 20) {
                alert(`Cannot upload ${files.length} images. Maximum is 20 total (currently ${currentCount}).`);
                return;
            }
            
            // Validate files
            for (const file of files) {
                if (file.size > 3 * 1024 * 1024) {
                    alert(`File "${file.name}" is too large. Maximum size is 3MB.`);
                    return;
                }
                if (!file.type.startsWith('image/')) {
                    alert(`File "${file.name}" is not an image.`);
                    return;
                }
            }
            
            try {
                const formData = new FormData();
                files.forEach(file => formData.append('images', file));
                
                const uploadRes = await fetch(`${API_BASE_URL}/api/reply-images/upload`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadRes.ok) {
                    throw new Error('Upload failed');
                }
                
                input.value = '';
                loadReplyImages();
                alert(`Successfully uploaded ${files.length} images!`);
            } catch (error) {
                console.error('Error uploading images:', error);
                alert('Error uploading images. Please try again.');
            }
        }

        async function deleteReplyImage(filename) {
            if (!confirm(`Delete image "${filename}"?`)) return;
            
            try {
                await fetch(`${API_BASE_URL}/api/reply-images/${filename}`, {
                    method: 'DELETE'
                });
                loadReplyImages();
            } catch (error) {
                console.error('Error deleting image:', error);
                alert('Error deleting image. Please try again.');
            }
        }

        async function clearAllReplyImages() {
            if (!confirm('Are you sure you want to delete all reply images? This action cannot be undone.')) {
                return;
            }
            
            try {
                await fetch(`${API_BASE_URL}/api/reply-images/clear`, {
                    method: 'DELETE'
                });
                loadReplyImages();
                alert('All reply images have been deleted successfully!');
            } catch (error) {
                console.error('Error clearing images:', error);
                alert('Error clearing images. Please try again.');
            }
        }

        async function toggleImageReplies() {
            const enabled = document.getElementById('enableImageReplies').checked;
            
            try {
                await fetch(`${API_BASE_URL}/api/reply-images/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled })
                });
                
                console.log(`Image replies ${enabled ? 'enabled' : 'disabled'}`);
            } catch (error) {
                console.error('Error updating image reply settings:', error);
                // Revert checkbox on error
                document.getElementById('enableImageReplies').checked = !enabled;
            }
        }

        // FONCTION SIMPLIFIÉE - Chargement du statut automation
        async function loadAutomationStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/automation-status`);
                const data = await response.json();
                
                console.log('[LOAD] Chargement statut depuis API:', data);
                
                // Mettre à jour l'état global
                globalAutomationState.isEnabled = data.isEnabled;
                globalAutomationState.lastSync = Date.now();
                
                console.log('[LOAD] État global mis à jour:', globalAutomationState.isEnabled);
                
                // Mettre à jour l'interface
                updateAutomationButtonFromGlobalState();
            } catch (error) {
                console.error('[LOAD] Erreur chargement statut:', error);
                // En cas d'erreur, forcer l'état à false
                globalAutomationState.isEnabled = false;
                updateAutomationButtonFromGlobalState();
            }
        }
        
        // Fonction pour afficher des notifications discrètes
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107',
                info: '#17a2b8'
            };
            
            notification.style.backgroundColor = colors[type] || colors.info;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animation d'entrée
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Suppression automatique
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }
        
        // Variables globales pour la validation
        let automationValidationState = {
            accounts: false,
            token: false,
            watchlist: false
        };
        
        // SUPPRIMÉ - Fonction dupliquée, remplacée par updateAutomationButtonFromGlobalState
        
        // SUPPRIMÉ - Fonction non utilisée

        // Variable pour éviter les clics multiples
        let toggleInProgress = false;

        async function toggleAutomation() {
            if (toggleInProgress) {
                console.log('[TOGGLE] Action déjà en cours, ignorée');
                return;
            }
            
            try {
                toggleInProgress = true;
                const button = document.getElementById('toggleAutomationBtn');
                
                console.log('[TOGGLE] État actuel:', globalAutomationState.isEnabled);
                
                // Affichage immédiat de l'état "en cours"
                button.disabled = true;
                button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>Changement en cours...';
                
                const res = await fetch(`${API_BASE_URL}/api/automation-status`, { method: 'POST' });
                const data = await res.json();
                
                console.log('[TOGGLE] Réponse API:', data);
                
                // Mettre à jour l'état global avec la réponse API
                globalAutomationState.isEnabled = data.isAutomationEnabled;
                globalAutomationState.lastSync = Date.now();
                
                console.log('[TOGGLE] Nouvel état:', globalAutomationState.isEnabled);
                
                // Mettre à jour l'interface
                updateAutomationButtonFromGlobalState();
                
                // Notification
                showNotification(data.isAutomationEnabled ? 'Automation démarrée' : 'Automation arrêtée', 'success');
            } catch (error) {
                console.error('[TOGGLE] Erreur:', error);
                // En cas d'erreur, recharger l'état depuis le serveur
                await loadAutomationStatus();
                showNotification('Erreur: ' + error.message, 'error');
            } finally {
                toggleInProgress = false;
            }
        }

        // --- Fonctions Analytics Dashboard ---
        async function refreshAnalytics() {
            console.log('[ANALYTICS] Début du rafraîchissement analytics...');
            try {
                const refreshBtn = document.getElementById('refreshAnalyticsBtn');
                if (refreshBtn) {
                    refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Chargement...';
                    refreshBtn.disabled = true;
                }
                
                // Afficher un indicateur de mise à jour dans le titre
                const titleElement = document.querySelector('h4 .fas.fa-chart-bar');
                if (titleElement) {
                    titleElement.className = 'fas fa-spinner fa-spin';
                    titleElement.style.color = '#1da1f2';
                }
                
                console.log('[ANALYTICS] Appel API:', `${API_BASE_URL}/api/dashboard-stats`);
                const response = await fetch(`${API_BASE_URL}/api/dashboard-stats`);
                console.log('[ANALYTICS] Réponse reçue:', response.status);
                
                const data = await response.json();
                console.log('[ANALYTICS] Données reçues:', data);
                
                // Adapter les données du serveur au format attendu par l'interface
                const adaptedMetrics = adaptDashboardStatsToMetrics(data);
                console.log('[ANALYTICS] Métriques adaptées:', adaptedMetrics);
                
                updateAnalyticsDisplay(adaptedMetrics);
                console.log('[ANALYTICS] Dashboard mis à jour avec succès');
                
            } catch (error) {
                console.error('Erreur lors du rafraîchissement des analytics:', error);
                
                // Affichage d'erreur dans l'interface
                const topAccountsContainer = document.getElementById('analyticsTopAccounts');
                if (topAccountsContainer) {
                    topAccountsContainer.innerHTML = `
                        <div style="text-align: center; color: var(--danger-color); padding: 20px;">
                            <i class="fas fa-exclamation-triangle"></i> Erreur de chargement des analytics
                        </div>
                    `;
                }
            } finally {
                const refreshBtn = document.getElementById('refreshAnalyticsBtn');
                if (refreshBtn) {
                    refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh';
                    refreshBtn.disabled = false;
                }
                
                // Restaurer l'icône du titre
                const titleElement = document.querySelector('h4 .fas.fa-spinner');
                if (titleElement) {
                    titleElement.className = 'fas fa-chart-bar';
                    titleElement.style.color = '#28a745';
                }
            }
        }
        
        // Fonction pour adapter les données du serveur au format attendu par l'interface
        // VERSION CORRIGÉE - UTILISE LA NOUVELLE STRUCTURE actionLog
        function adaptDashboardStatsToMetrics(dashboardStats) {
            console.log('[ANALYTICS] Adaptation des données avec nouvelle structure:', dashboardStats);
            
            // Source unique : les statistiques d'actions calculées côté backend
            const actionStats = dashboardStats.actionLog || {
                today: { likes: 0, retweets: 0, replies: 0, total: 0 },
                thisHour: { likes: 0, retweets: 0, replies: 0, total: 0 },
                allTime: { likes: 0, retweets: 0, replies: 0, total: 0 }
            };
            
            console.log('[ANALYTICS] Action stats reçues:', actionStats);
            
            return {
                summary: {
                    likes: { 
                        today: actionStats.today.likes || 0, 
                        thisHour: actionStats.thisHour.likes || 0, 
                        total: actionStats.allTime.likes || 0 
                    },
                    retweets: { 
                        today: actionStats.today.retweets || 0, 
                        thisHour: actionStats.thisHour.retweets || 0, 
                        total: actionStats.allTime.retweets || 0 
                    },
                    comments: { 
                        today: actionStats.today.replies || 0, 
                        thisHour: actionStats.thisHour.replies || 0, 
                        total: actionStats.allTime.replies || 0 
                    },
                    total: { 
                        today: actionStats.today.total || 0, 
                        thisHour: actionStats.thisHour.total || 0, 
                        total: actionStats.allTime.total || 0 
                    }
                },
                performance: {
                    successRate: 0.95,
                    averageResponseTime: 250,
                    errorCount: 0
                },
                quotaEfficiency: (actionStats.today.total || 0) > 0 ? Math.min(100, ((actionStats.today.total || 0) / 300) * 100) : 0,
                topAccounts: [] // Simplifié - pas de comptes pour éviter les conflits
            };
        }
        
        function updateAnalyticsDisplay(metrics) {
            console.log('[ANALYTICS] Mise à jour de l\'affichage avec:', metrics);
            
            // Mise à jour des métriques principales
            if (metrics.summary) {
                // Likes
                const likesTodayEl = document.getElementById('analyticsLikesToday');
                const likesHourEl = document.getElementById('analyticsLikesHour');
                const likesTotalEl = document.getElementById('analyticsLikesTotal');
                
                if (likesTodayEl) likesTodayEl.textContent = metrics.summary.likes?.today || 0;
                if (likesHourEl) likesHourEl.textContent = metrics.summary.likes?.thisHour || 0;
                if (likesTotalEl) likesTotalEl.textContent = metrics.summary.likes?.total || 0;
                
                // Retweets
                const retweetsTodayEl = document.getElementById('analyticsRetweetsToday');
                const retweetsHourEl = document.getElementById('analyticsRetweetsHour');
                const retweetsTotalEl = document.getElementById('analyticsRetweetsTotal');
                
                if (retweetsTodayEl) retweetsTodayEl.textContent = metrics.summary.retweets?.today || 0;
                if (retweetsHourEl) retweetsHourEl.textContent = metrics.summary.retweets?.thisHour || 0;
                if (retweetsTotalEl) retweetsTotalEl.textContent = metrics.summary.retweets?.total || 0;
                
                // Comments
                const commentsTodayEl = document.getElementById('analyticsCommentsToday');
                const commentsHourEl = document.getElementById('analyticsCommentsHour');
                const commentsTotalEl = document.getElementById('analyticsCommentsTotal');
                
                if (commentsTodayEl) commentsTodayEl.textContent = metrics.summary.comments?.today || 0;
                if (commentsHourEl) commentsHourEl.textContent = metrics.summary.comments?.thisHour || 0;
                if (commentsTotalEl) commentsTotalEl.textContent = metrics.summary.comments?.total || 0;
                
                // Total
                const totalTodayEl = document.getElementById('analyticsTotalToday');
                const totalHourEl = document.getElementById('analyticsTotalHour');
                const totalHistoriqueEl = document.getElementById('analyticsTotalHistorique');
                
                if (totalTodayEl) totalTodayEl.textContent = metrics.summary.total?.today || 0;
                if (totalHourEl) totalHourEl.textContent = metrics.summary.total?.thisHour || 0;
                if (totalHistoriqueEl) totalHistoriqueEl.textContent = metrics.summary.total?.total || 0;
                
                // 🎯 NOUVEAU : Mise à jour des métriques essentielles simplifiées
                const actionsRemainingEl = document.getElementById('actionsRemainingToday');
                const actionsUsedEl = document.getElementById('actionsUsedToday');
                const quotaUsagePercentageEl = document.getElementById('quotaUsagePercentage');
                
                // Calculer les totaux depuis les métriques
                const totalActionsToday = (metrics.summary.likes?.today || 0) + 
                                        (metrics.summary.retweets?.today || 0) + 
                                        (metrics.summary.comments?.today || 0);
                
                // Quota quotidien estimé (peut être ajusté selon les données backend)
                const dailyQuotaLimit = dashboardStats?.quotasData?.dailyLimit || 300;
                const actionsRemaining = Math.max(0, dailyQuotaLimit - totalActionsToday);
                const usagePercentage = dailyQuotaLimit > 0 ? Math.round((totalActionsToday / dailyQuotaLimit) * 100) : 0;
                
                if (actionsRemainingEl) actionsRemainingEl.textContent = actionsRemaining;
                if (actionsUsedEl) actionsUsedEl.textContent = totalActionsToday;
                if (quotaUsagePercentageEl) quotaUsagePercentageEl.textContent = `${usagePercentage}%`;
                
                // 🎯 NOUVEAU : Mise à jour de la section "Unified Quota System"
                updateUnifiedQuotaDisplay(dashboardStats);
            }
            
            // Mise à jour des métriques de performance
            if (metrics.performance) {
                const successRate = Math.round((metrics.performance.successRate || 0) * 100);
                const successRateEl = document.getElementById('analyticsSuccessRate');
                if (successRateEl) successRateEl.textContent = `${successRate}%`;
                
                const responseTime = Math.round(metrics.performance.averageResponseTime || 0);
                const responseTimeEl = document.getElementById('analyticsResponseTime');
                if (responseTimeEl) responseTimeEl.textContent = `${responseTime}ms`;
                
                const errorCountEl = document.getElementById('analyticsErrorCount');
                if (errorCountEl) errorCountEl.textContent = metrics.performance.errorCount || 0;
            }
            
            // Section comptes supprimée - plus d'affichage de comptes
            
            // Mise à jour des métriques de quotas
            if (metrics.quotaEfficiency !== undefined) {
                const efficiency = Math.round(metrics.quotaEfficiency);
                const efficiencyEl = document.getElementById('analyticsQuotaEfficiency');
                if (efficiencyEl) efficiencyEl.textContent = `${efficiency}%`;
            }
            
            // Comptes actifs
            const activeAccounts = metrics.topAccounts?.length || 0;
            const activeAccountsEl = document.getElementById('analyticsActiveAccounts');
            if (activeAccountsEl) activeAccountsEl.textContent = activeAccounts;
            
            // Dernière mise à jour
            const now = new Date();
            const lastUpdateEl = document.getElementById('analyticsLastUpdate');
            if (lastUpdateEl) lastUpdateEl.textContent = now.toLocaleTimeString('fr-FR');
            
            // Section top comptes supprimée pour éviter les conflits
            console.log('[ANALYTICS] Top comptes ignorés:', metrics.topAccounts?.length || 0);
            
            // Mise à jour du graphique horaire
            updateHourlyChartDisplay(metrics.hourlyActivity || []);
        }
        
        function updateTopAccountsDisplay(topAccounts) {
            const container = document.getElementById('analyticsTopAccounts');
            if (!container) return;
            
            if (!topAccounts || topAccounts.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: var(--medium-gray); padding: 20px;">
                        <i class="fas fa-info-circle"></i> Aucune donnée de compte disponible
                    </div>
                `;
                return;
            }
            
            let html = '';
            topAccounts.slice(0, 5).forEach((account, index) => {
                const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                const successRate = Math.round(account.successRate || 0);
                const totalActions = account.totalActions || 0;
                
                html += `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; border-radius: 6px; background: ${index % 2 === 0 ? '#f8f9fa' : 'transparent'}; margin-bottom: 4px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.2em;">${medal}</span>
                            <span style="font-weight: 500; color: var(--dark-gray);">${escapeHTML(account.accountId || 'Compte inconnu')}</span>
                        </div>
                        <div style="text-align: right; font-size: 0.9em;">
                            <div style="color: var(--success-color); font-weight: bold;">${successRate}% succès</div>
                            <div style="color: var(--medium-gray);">${totalActions} actions</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        
        function updateHourlyChartDisplay(hourlyActivity) {
            const container = document.getElementById('analyticsHourlyChart');
            if (!container) return;
            
            if (!hourlyActivity || hourlyActivity.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: var(--medium-gray); padding: 20px;">
                        <i class="fas fa-chart-bar"></i> Aucune donnée d'activité disponible
                    </div>
                `;
                return;
            }
            
            const maxActivity = Math.max(...hourlyActivity.map(h => h.total || 0));
            let html = '<div style="display: flex; align-items: end; gap: 2px; height: 60px; padding: 0 10px;">';
            
            hourlyActivity.forEach(hour => {
                const height = maxActivity > 0 ? Math.max(2, (hour.total / maxActivity) * 50) : 2;
                const isCurrentHour = hour.hour === new Date().getHours();
                
                html += `
                    <div style="
                        flex: 1;
                        height: ${height}px;
                        background: ${isCurrentHour ? 'var(--primary-color)' : hour.total > 0 ? 'var(--success-color)' : '#e9ecef'};
                        border-radius: 2px 2px 0 0;
                        position: relative;
                        transition: all 0.3s ease;
                    " title="${hour.hour}h: ${hour.total} actions">
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Ajout des labels d'heures
            html += '<div style="display: flex; justify-content: space-between; font-size: 0.7em; color: var(--medium-gray); margin-top: 5px; padding: 0 10px;">';
            for (let i = 0; i < 24; i += 6) {
                html += `<span>${i}h</span>`;
            }
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        // 🚀 FONCTION ANALYTICS BASÉE SUR ACTIONS-HISTORY (SOURCE UNIQUE DE VÉRITÉ)
        async function forceRefreshAnalytics() {
            console.log('🚀 ANALYTICS DEPUIS ACTIONS-HISTORY - DÉBUT');
            
            try {
                console.log('📱 Appel API actions-history (vraie source)...');
                const response = await fetch(`${API_BASE_URL}/api/actions-history`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('📊 Données brutes reçues:', {
                    success: data.success,
                    totalActions: data.actions?.length || 0
                });
                
                if (data && data.performedActions) {
                    // Parser les données performedActions en format actions
                    const actions = [];
                    
                    Object.entries(data.performedActions).forEach(([tweetId, accounts]) => {
                        Object.entries(accounts).forEach(([accountId, actionTypes]) => {
                            Object.entries(actionTypes).forEach(([actionType, timestamp]) => {
                                actions.push({
                                    tweetId,
                                    accountId,
                                    actionType,
                                    timestamp: new Date(timestamp)
                                });
                            });
                        });
                    });
                    
                    // Comptage TOTAL par type d'action (historique)
                    const likesTotal = actions.filter(a => a.actionType === 'like').length;
                    const retweetsTotal = actions.filter(a => a.actionType === 'retweet').length;
                    const commentsTotal = actions.filter(a => a.actionType === 'reply').length;
                    const total = actions.length;
                    
                    // Comptes uniques
                    const uniqueAccounts = [...new Set(actions.map(a => a.accountId))].length;
                    
                    // Actions AUJOURD'HUI (priorité)
                    const today = new Date().toDateString();
                    const todayActions = actions.filter(a => {
                        const actionDate = new Date(a.timestamp).toDateString();
                        return actionDate === today;
                    });
                    
                    // Comptage par type AUJOURD'HUI
                    const likesToday = todayActions.filter(a => a.actionType === 'like').length;
                    const retweetsToday = todayActions.filter(a => a.actionType === 'retweet').length;
                    const commentsToday = todayActions.filter(a => a.actionType === 'reply').length;
                    const totalToday = todayActions.length;
                    
                    // Actions cette heure
                    const currentHour = new Date().getHours();
                    const thisHourActions = actions.filter(a => {
                        const actionDate = new Date(a.timestamp);
                        return actionDate.toDateString() === today && actionDate.getHours() === currentHour;
                    });
                    
                    // Comptage par type CETTE HEURE
                    const likesThisHour = thisHourActions.filter(a => a.actionType === 'like').length;
                    const retweetsThisHour = thisHourActions.filter(a => a.actionType === 'retweet').length;
                    const commentsThisHour = thisHourActions.filter(a => a.actionType === 'reply').length;
                    const totalThisHour = thisHourActions.length;
                    
                    // Taux de succès (on assume 100% car ce sont des actions réussies)
                    const successRate = total > 0 ? 100 : 0;
                    
                    // Calcul de l'utilisation globale des quotas
                    let quotaEfficiency = 0;
                    try {
                        // Récupérer les quotas depuis l'API
                        const quotasResponse = await fetch(`${API_BASE_URL}/api/quotas`);
                        if (quotasResponse.ok) {
                            const quotasData = await quotasResponse.json();
                            if (quotasData.success && quotasData.quotas) {
                                const quotas = quotasData.quotas;
                                // Calculer les quotas totaux disponibles
                                const totalAvailable = (quotas.like || 0) + (quotas.retweet || 0) + (quotas.reply || 0);
                                // Calculer l'utilisation globale
                                quotaEfficiency = totalAvailable > 0 ? Math.round((totalToday / totalAvailable) * 100) : 0;
                                console.log('📊 Calcul quota efficiency:', {
                                    totalToday,
                                    totalAvailable,
                                    quotaEfficiency: `${quotaEfficiency}%`
                                });
                            }
                        }
                    } catch (error) {
                        console.warn('⚠️ Erreur récupération quotas pour calcul efficiency:', error);
                        quotaEfficiency = 0;
                    }
                    
                    console.log('📈 Métriques calculées:', {
                        likesToday, retweetsToday, commentsToday, totalToday, 
                        likesTotal, retweetsTotal, commentsTotal, total,
                        uniqueAccounts, thisHourActions, successRate, quotaEfficiency
                    });
                    
                    // Mise à jour des éléments du dashboard - NOUVELLE LOGIQUE
                    const updates = [
                        // Actions du jour (gros chiffres)
                        { id: 'analyticsLikesToday', value: likesToday },
                        { id: 'analyticsRetweetsToday', value: retweetsToday },
                        { id: 'analyticsCommentsToday', value: commentsToday },
                        { id: 'analyticsTotalToday', value: totalToday },
                        
                        // Cette heure (détail)
                        { id: 'analyticsLikesHour', value: likesThisHour },
                        { id: 'analyticsRetweetsHour', value: retweetsThisHour },
                        { id: 'analyticsCommentsHour', value: commentsThisHour },
                        { id: 'analyticsTotalHour', value: totalThisHour },
                        
                        // Total historique (petits chiffres)
                        { id: 'analyticsLikesTotal', value: likesTotal },
                        { id: 'analyticsRetweetsTotal', value: retweetsTotal },
                        { id: 'analyticsCommentsTotal', value: commentsTotal },
                        { id: 'analyticsTotalHistorique', value: total },
                        
                        // Bouton Total All Time
                        { id: 'totalAllTimeCount', value: total },
                        
                        // Métriques de performance
                        { id: 'analyticsSuccessRate', value: `${successRate}%` },
                        { id: 'analyticsResponseTime', value: '~200ms' },
                        { id: 'analyticsErrorCount', value: 0 },
                        { id: 'analyticsActiveAccounts', value: uniqueAccounts },
                        { id: 'analyticsQuotaEfficiency', value: `${quotaEfficiency}%` }
                    ];
                    
                    let successCount = 0;
                    updates.forEach(update => {
                        const element = document.getElementById(update.id);
                        if (element) {
                            element.textContent = update.value;
                            element.style.background = '#90EE90';
                            element.style.transition = 'background 2s';
                            setTimeout(() => element.style.background = '', 2000);
                            console.log(`✅ ${update.id}: ${update.value}`);
                            successCount++;
                        } else {
                            console.warn(`⚠️ Élément non trouvé: ${update.id}`);
                        }
                    });
                    
                    // Mise à jour de l'heure
                    const lastUpdateEl = document.getElementById('analyticsLastUpdate');
                    if (lastUpdateEl) {
                        lastUpdateEl.textContent = new Date().toLocaleTimeString('fr-FR');
                        console.log('🕒 Heure mise à jour');
                    }
                    
                    // Mise à jour du top des comptes
                    updateTopAccountsFromHistory(actions);
                    
                    // Génération des données d'activité horaire
                    const hourlyActivity = generateHourlyActivityFromActions(actions);
                    updateHourlyChartDisplay(hourlyActivity);
                    
                    // Mise à jour du graphique de répartition des quotas (si disponible)
                    const quotasData = { like: likesToday, retweet: retweetsToday, reply: commentsToday };
                    if (typeof updateQuotaDistributionChart === 'function') {
                        updateQuotaDistributionChart(quotasData);
                    }
                    
                    console.log(`🎉 SUCCÈS! ${successCount}/${updates.length} éléments mis à jour depuis actions-history`);
                    
                    // Notification visuelle supprimée à la demande de l'utilisateur
                    // Les analytics sont toujours mis à jour, mais sans bandeau dérangeant
                    
                } else {
                    throw new Error('Données actions-history invalides');
                }
                
            } catch (error) {
                console.error('❌ Erreur:', error);
                
                // Notification d'erreur
                const errorNotification = document.createElement('div');
                errorNotification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #f44336;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    z-index: 9999;
                    font-weight: bold;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                errorNotification.innerHTML = `❌ Erreur Actions-History: ${error.message}`;
                document.body.appendChild(errorNotification);
                
                setTimeout(() => errorNotification.remove(), 5000);
            }
        }
        
        // Fonction pour mettre à jour le top des comptes depuis l'historique
        function updateTopAccountsFromHistory(actions) {
            const container = document.getElementById('analyticsTopAccounts');
            if (!container) return;
            
            const accountStats = {};
            actions.forEach(action => {
                if (!accountStats[action.accountId]) {
                    accountStats[action.accountId] = {
                        accountId: action.accountId,
                        totalActions: 0,
                        likes: 0,
                        retweets: 0,
                        comments: 0,
                        successRate: 100
                    };
                }
                accountStats[action.accountId].totalActions++;
                if (action.actionType === 'like') accountStats[action.accountId].likes++;
                if (action.actionType === 'retweet') accountStats[action.accountId].retweets++;
                if (action.actionType === 'reply') accountStats[action.accountId].comments++;
            });
            
            // Convertir en tableau et trier par nombre total d'actions
            const sortedAccounts = Object.values(accountStats)
                .sort((a, b) => b.totalActions - a.totalActions)
                .slice(0, 5);
            
            updateTopAccountsDisplay(sortedAccounts);
        }
        
        function generateHourlyActivityFromActions(actions) {
            // Initialiser un tableau pour les 24 heures
            const hourlyData = [];
            for (let hour = 0; hour < 24; hour++) {
                hourlyData.push({
                    hour: hour,
                    total: 0,
                    likes: 0,
                    retweets: 0,
                    comments: 0
                });
            }
            
            // Compter les actions par heure
            actions.forEach(action => {
                try {
                    const actionDate = new Date(action.timestamp);
                    const hour = actionDate.getHours();
                    
                    if (hour >= 0 && hour < 24) {
                        hourlyData[hour].total++;
                        if (action.actionType === 'like') hourlyData[hour].likes++;
                        if (action.actionType === 'retweet') hourlyData[hour].retweets++;
                        if (action.actionType === 'reply') hourlyData[hour].comments++;
                    }
                } catch (error) {
                    console.warn('Erreur parsing timestamp pour graphique horaire:', action.timestamp);
                }
            });
            
            return hourlyData;
        }
        
        function updateTopAccountsDisplay(topAccounts) {
            const container = document.getElementById('analyticsTopAccounts');
            if (!container) return;
            
            if (!topAccounts || topAccounts.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: var(--medium-gray); padding: 20px;">
                        <i class="fas fa-info-circle"></i> Aucune donnée de compte disponible
                    </div>
                `;
                return;
            }
            
            let html = '';
            topAccounts.forEach((account, index) => {
                const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                const successRate = Math.round(account.successRate || 0);
                const totalActions = account.totalActions || 0;
                
                html += `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; border-radius: 6px; background: ${index % 2 === 0 ? '#f8f9fa' : 'transparent'}; margin-bottom: 4px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 1.2em;">${medal}</span>
                            <span style="font-weight: 500; color: var(--dark-gray);">Compte ${account.accountId}</span>
                        </div>
                        <div style="text-align: right; font-size: 0.9em;">
                            <div style="color: var(--success-color); font-weight: bold;">${successRate}% succès</div>
                            <div style="color: var(--medium-gray);">${totalActions} actions (${account.likes}L ${account.retweets}R ${account.comments}C)</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        
        // --- Fonction manquante pour générer les invitations ---
        function generateInvitationToken() {
            fetch(`${API_BASE_URL}/api/admin/projects/default/invite`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.inviteUrl) {
                    navigator.clipboard.writeText(data.inviteUrl).then(() => {
                        alert(`Lien d'invitation généré et copié dans le presse-papiers:\n\n${data.inviteUrl}`);
                    }).catch(() => {
                        prompt('Lien d\'invitation généré (copiez-le manuellement):', data.inviteUrl);
                    });
                } else {
                    alert('Erreur lors de la génération du lien d\'invitation');
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                alert('Erreur lors de la génération du lien d\'invitation');
            });
        }
        
        function openActionsDetail() {
            window.open('actions-detail.html', '_blank');
        }
        
        async function updateFoundTweets() {
            try {
                const res = await fetch(`${API_BASE_URL}/api/found-tweets`);
                const data = await res.json();
                
                const foundTweetsDiv = document.getElementById('foundTweets');
                const foundTweetsCard = document.getElementById('foundTweetsCard');

                if (!data.tweets || data.tweets.length === 0) {
                    foundTweetsCard.style.display = 'none';
                    return;
                }
                
                foundTweetsCard.style.display = 'block';
                foundTweetsDiv.innerHTML = data.tweets.map(tweet => `
                    <div class="card mb-2" style="padding: 15px; border: 1px solid #eee;">
                        <div class="account-info mb-2">
                            <div class="account-avatar">${tweet.author.charAt(0).toUpperCase()}</div>
                            <strong>@${tweet.author}</strong>
                            <span class="text-muted">• ${new Date(tweet.timestamp).toLocaleString()}</span>
                        </div>
                        <p class="mb-2">${escapeHTML(tweet.text)}</p>
                        <a href="${tweet.url}" target="_blank" class="btn btn-primary" style="padding: 5px 10px; font-size: 0.9em;">
                            <i class="fas fa-external-link-alt"></i> View on X
                        </a>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error updating found tweets:', error);
            }
      }
      // Fonction pour basculer la visibilité des logs
    function toggleLogsVisibility() {
        const logsContent = document.getElementById('logsContent');
        const toggleIcon = document.getElementById('logsToggleIcon');
        
        if (logsContent.style.display === 'none') {
            logsContent.style.display = 'block';
            toggleIcon.style.transform = 'rotate(180deg)';
        } else {
            logsContent.style.display = 'none';
            toggleIcon.style.transform = 'rotate(0deg)';
        }
    }

    // Fonction pour télécharger les logs filtrés
    function downloadFilteredLogs() {
            fetch(`${API_BASE_URL}/api/download-logs`)
                .then(response => {
                    if (!response.ok) throw new Error('Erreur lors du téléchargement');
                    return response.text();
                })
                .then(content => {
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `x-autoraider-logs-${new Date().toISOString().split('T')[0]}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                })
                .catch(error => {
                    console.error('Erreur téléchargement logs:', error);
                    alert('Erreur lors du téléchargement des logs');
                });
        }
        
        // --- Contrôles avancés des logs ---
        function toggleLogsPause() {
            logsPaused = !logsPaused;
            const btn = document.getElementById('pauseLogsBtn');
            const icon = btn.querySelector('i');
            
            if (logsPaused) {
                btn.innerHTML = '<i class="fas fa-play"></i> Reprendre';
                btn.style.background = '#28a745';
                updateLogsStatus('Logs en pause', '#ffc107');
            } else {
                btn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                btn.style.background = '#6c757d';
                updateLogsStatus('WebSocket connecté', '#28a745');
            }
        }
        
        function applyLogFilters() {
            currentLogFilter = document.getElementById('logTypeFilter').value;
            displayLogs(); // Réafficher avec le nouveau filtre
        }
        
        function changeLogLimit() {
            const newLimit = parseInt(document.getElementById('logLimitSelect').value);
            logsData.limit = newLimit;
            
            // Recharger les logs avec la nouvelle limite
            if (socket && socket.connected) {
                logsData.logs = [];
                logsData.currentOffset = 0;
                socket.emit('requestLogs', { limit: newLimit, offset: 0 });
            }
        }
        
        function updateLogsStatus(message, color) {
            const statusElement = document.getElementById('logsStatus');
            if (statusElement) {
                statusElement.innerHTML = `<i class="fas fa-circle" style="font-size:0.6em;"></i> ${message}`;
                statusElement.style.color = color;
            }
        }
        
        function updateLogsTotalCount() {
            const countElement = document.getElementById('logsTotalCount');
            if (countElement) {
                countElement.textContent = logsData.total;
            }
        }
        
        // --- Gestion WebSocket des logs ---
        function initializeWebSocket() {
            // Vérifier si Socket.IO est disponible
            if (typeof io === 'undefined') {
                console.warn('[WEBSOCKET] Socket.IO non disponible, utilisation du fallback REST');
                updateLogsStatus('Mode REST (fallback)', '#ffc107');
                refreshLiveLogsFallback();
                setInterval(refreshLiveLogsFallback, 5000);
                return;
            }
            
            socket = io(API_BASE_URL);
            
            socket.on('connect', () => {
                console.log('[WEBSOCKET] Connecté au serveur');
                updateLogsStatus('WebSocket connecté', '#28a745');
            });
            
            socket.on('initialLogs', (data) => {
                console.log('[WEBSOCKET] Logs initiaux reçus:', data);
                logsData = { ...data, currentOffset: data.logs.length };
                updateLogsTotalCount();
                displayLogs();
            });
            
            socket.on('newLog', (logEntry) => {
                if (logsPaused) return; // Ne pas ajouter si en pause
                
                console.log('[WEBSOCKET] Nouveau log reçu:', logEntry);
                logsData.logs.unshift(logEntry);
                logsData.total++;
                // Limiter à 100 logs en mémoire côté client
                if (logsData.logs.length > 100) {
                    logsData.logs.pop();
                }
                updateLogsTotalCount();
                displayLogs();
            });
            
            socket.on('logsResponse', (data) => {
                console.log('[WEBSOCKET] Logs paginés reçus:', data);
                if (data.logs && data.logs.length > 0) {
                    logsData.logs.push(...data.logs);
                    logsData.currentOffset += data.logs.length;
                    logsData.hasMore = data.hasMore;
                    updateLogsTotalCount();
                    displayLogs();
                }
            });
            
            socket.on('disconnect', () => {
                console.log('[WEBSOCKET] Déconnecté du serveur');
                updateLogsStatus('Déconnecté', '#dc3545');
                // Fallback vers polling si WebSocket échoue
                setTimeout(refreshLiveLogsFallback, 2000);
            });
            
            socket.on('connect_error', (error) => {
                console.error('[WEBSOCKET] Erreur de connexion:', error);
                updateLogsStatus('Erreur connexion', '#dc3545');
                // Fallback vers polling
                refreshLiveLogsFallback();
            });
        }
        
        function displayLogs() {
            const liveLogs = document.getElementById('liveLogs');
            if (!liveLogs) return;
            
            // Filtrer les logs selon le filtre sélectionné
            let filteredLogs = logsData.logs;
            if (currentLogFilter !== 'all') {
                filteredLogs = logsData.logs.filter(log => log.type === currentLogFilter);
            }
            
            if (filteredLogs.length === 0) {
                liveLogs.innerHTML = '<div style="text-align:center;color:#657786;padding:20px;">Aucun log à afficher.</div>';
                return;
            }
            
            const logsHtml = filteredLogs.map(log => formatLogLine(log)).join('\n');
            liveLogs.innerHTML = logsHtml;
            
            // Add "Load more" button if needed
            updateLoadMoreButton();
        }
        
        function updateLoadMoreButton() {
            const container = document.getElementById('liveLogsCard');
            if (!container) return;
            
            let loadMoreBtn = document.getElementById('loadMoreLogsBtn');
            
            if (logsData.hasMore) {
                if (!loadMoreBtn) {
                    loadMoreBtn = document.createElement('button');
                    loadMoreBtn.id = 'loadMoreLogsBtn';
                    loadMoreBtn.className = 'btn btn-secondary';
                    loadMoreBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Charger plus de logs';
                    loadMoreBtn.onclick = loadMoreLogs;
                    loadMoreBtn.style.marginTop = '10px';
                    loadMoreBtn.style.width = '100%';
                    container.appendChild(loadMoreBtn);
                }
            } else if (loadMoreBtn) {
                loadMoreBtn.remove();
            }
        }
        
        function loadMoreLogs() {
            if (socket && socket.connected) {
                socket.emit('requestLogs', {
                    limit: logsData.limit,
                    offset: logsData.currentOffset
                });
            }
        }
        
        // Fallback vers polling si WebSocket échoue
        function refreshLiveLogsFallback() {
            fetch(`${API_BASE_URL}/api/live-logs?limit=${logsData.limit}&offset=0`)
                .then(res => res.json())
                .then(data => {
                    console.log('[FALLBACK] Logs récupérés via REST:', data);
                    if (data.logs) {
                        logsData = {
                            logs: data.logs,
                            total: data.total || data.logs.length,
                            hasMore: data.hasMore || false,
                            currentOffset: data.logs.length,
                            limit: logsData.limit
                        };
                        updateLogsTotalCount();
                        displayLogs();
                    }
                })
                .catch(err => {
                    console.error('[FALLBACK] Erreur lors du chargement des logs:', err);
                    const liveLogs = document.getElementById('liveLogs');
                    if (liveLogs) {
                        liveLogs.innerHTML = '<div style="text-align:center;color:#dc3545;padding:20px;">Erreur lors du chargement des logs.</div>';
                    }
                });
        }

        // --- Affichage des logs live d'automatisation ---
        function getActionIcon(type) {
            switch(type) {
                case 'like': return '<i class="fas fa-heart" style="color:#e0245e"></i>';
                case 'retweet': return '<i class="fas fa-retweet" style="color:#17bf63"></i>';
                case 'reply': return '<i class="fas fa-reply" style="color:#1da1f2"></i>';
                case 'mute': return '<i class="fas fa-volume-mute" style="color:#888"></i>';
                case 'ia': return '<i class="fas fa-robot" style="color:#ffad1f"></i>';
                case 'tweet_found': return '<i class="fas fa-search" style="color:#764ba2"></i>';
                case 'delay': return '<i class="fas fa-clock" style="color:#ff9800"></i>';
                case 'system': return '<i class="fas fa-cog" style="color:#888"></i>';
                default: return '<i class="fas fa-asterisk" style="color:#aaa"></i>';
            }
        }

        function getTypeBadge(type) {
            switch(type) {
                case 'like': return '<span class="status-badge" style="background:#e0245e;color:#fff">Like</span>';
                case 'retweet': return '<span class="status-badge" style="background:#17bf63;color:#fff">Retweet</span>';
                case 'reply': return '<span class="status-badge" style="background:#1da1f2;color:#fff">Reply</span>';
                case 'mute': return '<span class="status-badge status-inactive">Mute</span>';
                case 'ia': return '<span class="status-badge" style="background:#ffad1f;color:#fff">IA</span>';
                case 'tweet_found': return '<span class="status-badge" style="background:#764ba2;color:#fff">Found</span>';
                case 'delay': return '<span class="status-badge" style="background:#ff9800;color:#fff">Délai</span>';
                case 'system': return '<span class="status-badge" style="background:#888;color:#fff">System</span>';
                default: return '<span class="status-badge" style="background:#aaa;color:#fff">Info</span>';
            }
        }

        function formatLogLine(log) {
            // FILTRAGE : Masquer les logs backoffice non pertinents
            const backofficeKeywords = [
                'HEARTBEAT', 'CACHE', 'REDIS', 'ANALYTICS', 'RATE-LIMITER',
                'Service initialisé', 'Données sauvegardées', 'Erreur Redis',
                'Automatisation toujours active', 'Entre actions - Attente',
                'Service de rate limiting', 'Clé chargée', 'Tentatives de reconnexion',
                'INFLUENCER', 'influencer', 'Monitoring automatique', 'Auto-monitoring',
                'DEBUG', '[DEBUG]', 'debug'
            ];
            
            // Vérifier si le log contient des mots-clés backoffice
            const isBackofficeLog = backofficeKeywords.some(keyword => 
                log.message && log.message.includes(keyword)
            );
            
            // Masquer les logs backoffice
            if (isBackofficeLog) {
                return '';
            }
            
            const time = new Date(log.timestamp).toLocaleTimeString('fr-FR', { 
                hour: '2-digit', minute: '2-digit', second: '2-digit' 
            });
            
            // Configuration pour les logs utiles uniquement
            const typeConfig = {
                'like': { icon: '❤️', color: '#e91e63' },
                'retweet': { icon: '🔄', color: '#4caf50' },
                'reply': { icon: '💬', color: '#2196f3' },
                'system': { icon: '🎭', color: '#9c27b0' }, // Pour influenceurs
                'error': { icon: '⚠️', color: '#f44336' }
            };
            
            const config = typeConfig[log.type] || typeConfig['system'];
            
            // Style FUN et GRAND avec animations
            let html = `
                <div class="log-entry-animated" style="
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 15px 20px;
                    margin: 8px 0;
                    border-left: 5px solid ${config.color};
                    background: linear-gradient(135deg, rgba(${config.color.slice(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.1), rgba(${config.color.slice(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.05));
                    border-radius: 0 15px 15px 0;
                    font-size: 1.1em;
                    line-height: 1.4;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                    transform: translateX(-10px);
                    animation: slideInBounce 0.6s ease-out forwards, pulse 2s infinite;
                    transition: all 0.3s ease;
                    cursor: pointer;
                " onmouseover="this.style.transform='translateX(0) scale(1.02)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.15)'" 
                   onmouseout="this.style.transform='translateX(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'">
                    <span style="font-size: 1.8em; animation: bounce 1s ease-in-out;">${config.icon}</span>
                    <span style="color: #555; font-size: 1em; min-width: 80px; font-weight: 600; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);">${time}</span>
            `;
            
            // Comptes avec flèche STYLÉE
            if (log.account) {
                html += `<span style="color: #1da1f2; font-weight: 700; font-size: 1.1em; text-shadow: 1px 1px 2px rgba(29,161,242,0.3);">@${log.account}</span>`;
            }
            if (log.account && log.targetUser) {
                html += `<span style="color: #ff6b35; font-size: 1.3em; animation: wiggle 1s ease-in-out infinite;">→</span>`;
            }
            if (log.targetUser) {
                html += `<span style="color: #657786; font-weight: 700; font-size: 1.1em; text-shadow: 1px 1px 2px rgba(101,119,134,0.3);">@${log.targetUser}</span>`;
            }
            
            // Message principal STYLÉ
            html += `<span style="flex: 1; color: #2c3e50; font-weight: 600; font-size: 1.05em; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);">${log.message || log.text || 'Action effectuée'}</span>`;
            
            // Quota ANIMÉ si disponible
            if (log.metadata && log.metadata.quotaUsed && log.metadata.quotaLimit) {
                const percentage = Math.round((log.metadata.quotaUsed / log.metadata.quotaLimit) * 100);
                const quotaColor = percentage > 80 ? '#f44336' : percentage > 60 ? '#ff9800' : '#4caf50';
                html += `
                    <span style="
                        background: linear-gradient(45deg, ${quotaColor}, ${quotaColor}dd);
                        color: white;
                        padding: 6px 12px;
                        border-radius: 20px;
                        font-size: 0.9em;
                        font-weight: bold;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                        animation: glow 2s ease-in-out infinite alternate;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
                    ">
                        ${log.metadata.quotaUsed}/${log.metadata.quotaLimit}
                    </span>
                `;
            }
            
            // Lien vers le tweet STYLÉ
            if (log.tweetId && log.tweetUrl) {
                html += `
                    <a href="${log.tweetUrl}" target="_blank" style="
                        color: #1da1f2;
                        text-decoration: none;
                        padding: 8px 12px;
                        border-radius: 25px;
                        background: linear-gradient(45deg, #1da1f2, #1991db);
                        color: white;
                        font-size: 1.1em;
                        box-shadow: 0 3px 10px rgba(29,161,242,0.3);
                        transition: all 0.3s ease;
                        animation: twitterPulse 3s ease-in-out infinite;
                    " onmouseover="this.style.transform='scale(1.1) rotate(5deg)'; this.style.boxShadow='0 5px 20px rgba(29,161,242,0.5)'" 
                       onmouseout="this.style.transform='scale(1) rotate(0deg)'; this.style.boxShadow='0 3px 10px rgba(29,161,242,0.3)'" 
                       title="🐦 Voir le tweet sur X">
                        <i class="fab fa-twitter" style="font-size: 1.2em;"></i>
                    </a>
                `;
            }
            
            html += `</div>`;
            
            // Contenu du tweet (ligne séparée si présent)
            if (log.tweetText && log.tweetText !== 'Contenu non disponible') {
                html += `
                    <div style="
                        margin-left: 32px;
                        padding: 4px 8px;
                        background: #f8f9fa;
                        border-radius: 4px;
                        font-size: 0.8em;
                        color: #666;
                        font-style: italic;
                        margin-bottom: 4px;
                    ">
                        "${log.tweetText}"
                    </div>
                `;
            }
            
            // Réponse IA (ligne séparée si présente)
            if (log.replyText) {
                html += `
                    <div style="
                        margin-left: 32px;
                        padding: 4px 8px;
                        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
                        border-radius: 4px;
                        font-size: 0.8em;
                        color: #333;
                        margin-bottom: 4px;
                    ">
                        🤖 ${log.replyText}
                    </div>
                `;
            }
            
            return html;
        }

        async function refreshLiveLogs() {
            try {
                const res = await fetch(API_BASE_URL + '/api/live-logs');
                const data = await res.json();
                const logs = data.logs || [];
                const container = document.getElementById('liveLogsContainer');
                if (!container) return;
                if (!logs.length) {
                    container.innerHTML = '<div style="color:#aaa;text-align:center;">Aucun log à afficher pour l\'instant.<br>Les logs d\'automatisation s\'afficheront ici en temps réel.</div>';
                    return;
                }
                container.innerHTML = logs.map(formatLogLine).join('');
                // Auto-scroll en bas
                container.scrollTop = container.scrollHeight;
            } catch (e) {
                const container = document.getElementById('liveLogsContainer');
                if (container) container.innerHTML = '<div style="color:#e0245e;text-align:center;">Erreur lors du chargement des logs.</div>';
            }
        }
        // 📊 --- FONCTIONS GESTION DES QUOTAS (NETTOYÉES) ---
        
        // --- Fonction pour gérer le menu déroulant Quick Start Guide (GLOBAL) ---
        let quickStartExpanded = false;
        
        function toggleQuickStartGuide() {
            const content = document.getElementById('quickStartContent');
            const chevron = document.getElementById('quickStartChevron');
            const status = document.querySelector('.quick-start-status');
            const header = document.querySelector('.quick-start-header');
            
            if (!content || !chevron || !status || !header) return;
            
            quickStartExpanded = !quickStartExpanded;
            
            if (quickStartExpanded) {
                // Expand
                const scrollHeight = content.scrollHeight;
                content.style.maxHeight = scrollHeight + 'px';
                content.style.padding = '0 25px';
                chevron.style.transform = 'rotate(180deg)';
                status.textContent = 'Click to collapse';
                header.style.backgroundColor = 'rgba(29, 161, 242, 0.05)';
                
                // Save state in localStorage
                localStorage.setItem('quickStartExpanded', 'true');
            } else {
                // Collapse
                content.style.maxHeight = '0px';
                content.style.padding = '0 25px';
                chevron.style.transform = 'rotate(0deg)';
                status.textContent = 'Click to expand';
                header.style.backgroundColor = 'transparent';
                
                // Save state in localStorage
                localStorage.setItem('quickStartExpanded', 'false');
            }
        }
        
        // Restore Quick Start Guide state on page load
        function initializeQuickStartGuide() {
            const savedState = localStorage.getItem('quickStartExpanded');
            if (savedState === 'true') {
                // Delay to ensure DOM is ready
                setTimeout(() => {
                    toggleQuickStartGuide();
                }, 100);
            }
        }
        
        // EXPOSITION GLOBALE IMMÉDIATE pour onclick
        window.toggleQuickStartGuide = toggleQuickStartGuide;

        // --- Initialisation au chargement de la page ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialiser WebSocket au lieu du polling
            initializeWebSocket();
            // Fonction de déconnexion globale (utilisée par les boutons onclick)
            window.logout = async () => {
                if (!confirm('Êtes-vous sûr de vouloir vous déconnecter ?')) return;
                try {
                    const res = await fetch('/api/logout', { method: 'POST' });
                    if (res.ok) window.location.href = 'login.html';
                    else alert('Échec de la déconnexion.');
                } catch (e) {
                    alert('Erreur réseau lors de la déconnexion.');
                }
            };

            // Fonction scrollToSection pour les validations
            window.scrollToSection = (sectionId) => {
                const element = document.getElementById(sectionId);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            };

            // Fonction pour remonter en haut de page
            window.scrollToTop = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            // Gestion de l'affichage du bouton scroll to top
            const scrollToTopBtn = document.getElementById('scrollToTopBtn');
            window.addEventListener('scroll', () => {
                if (window.pageYOffset > 300) {
                    scrollToTopBtn.classList.add('show');
                } else {
                    scrollToTopBtn.classList.remove('show');
                }
            });
            
            // Bouton de sauvegarde des paramètres du token
            document.getElementById('saveAIPromptBtn').onclick = saveTokenSettings;
            
            // Nettoyage et chargement initial
            if (document.getElementById('liveLogs')) document.getElementById('liveLogs').innerHTML = '';
            
            loadAccounts();
            loadWatchAccounts();
            loadReplyImages();
            loadTokenSettings();
            loadAutomationStatus();
            
            // Initialiser le système de quotas unifié
            refreshQuotaData();
            
            // Initialiser le nouveau dashboard glassmorphism
            initializeDashboard();
            
            // Initialiser les analytics après le dashboard
            refreshAnalytics();
            loadInfluencerStats();
            loadRecentInfluencerInteractions();
            
            // Initialiser les logs en temps réel
            initializeWebSocket();
            
            // Intervalles de rafraîchissement unifiés
            setInterval(refreshDashboard, 30000); // Dashboard toutes les 30 secondes
            setInterval(refreshQuotaData, 30000); // Quotas toutes les 30 secondes
            setInterval(updateFoundTweets, 15000); // Tweets trouvés toutes les 15 secondes
            setInterval(forceRefreshAnalytics, 30000); // Analytics toutes les 30 secondes
            // SUPPRIMÉ : Cette synchronisation toutes les 5s écrasait constamment le statut
            // setInterval(syncAutomationState, 5000); // Synchronisation état automation toutes les 5 secondes
            
            // --- Fonction refreshDashboard ---
            function refreshDashboard() {
                fetch(`${API_BASE_URL}/api/dashboard-stats`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Mettre à jour les statistiques du dashboard
                            const stats = data.stats || {};
                            
                            // Mettre à jour les éléments du dashboard si ils existent
                            if (document.getElementById('totalAccounts')) {
                                document.getElementById('totalAccounts').textContent = stats.totalAccounts || '0';
                            }
                            // SUPPRIMÉ : Cette ligne écrasait le statut automation géré par updateAutomationStatus()
                            // if (document.getElementById('automationStatus')) {
                            //     document.getElementById('automationStatus').textContent = stats.automationEnabled ? 'Enabled' : 'Disabled';
                            // }
                            if (document.getElementById('totalActions')) {
                                document.getElementById('totalActions').textContent = stats.totalActions || '0';
                            }
                            
                            // Mettre à jour les quotas si disponibles
                            if (stats.quotas && stats.actionsLeft) {
                                updateQuotasDisplay(stats.quotas, stats.actionsLeft, stats.quotasData);
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Erreur lors du rafraîchissement du dashboard:', error);
                    });
            }
            
            // --- Gestion des quotas GLOBAUX PARTAGÉS (dans DOMContentLoaded) ---
            function loadQuotasSettings() {
                console.log('[QUOTA-UI] Chargement des quotas globaux partagés...');
                
                // Utiliser l'API dashboard-stats qui contient maintenant les comptes enrichis
                fetch(`${API_BASE_URL}/api/dashboard-stats`)
                    .then(res => res.json())
                    .then(stats => {
                        console.log('[QUOTA-UI] Stats dashboard reçues:', stats);
                        
                        // Si on a les comptes enrichis, les utiliser
                        if (stats.enrichedAccounts) {
                            console.log('[QUOTA-UI] Utilisation des comptes enrichis avec statut');
                            updateActiveAccountsDisplay(stats.enrichedAccounts);
                        }
                        
                        // 🎯 CORRECTION : Utiliser les données du système unifié au lieu du fallback défaillant
                        if (!stats.enrichedAccounts || stats.enrichedAccounts.length === 0) {
                            console.log('[QUOTA-UI] Pas de comptes enrichis - utilisation des données système unifié');
                            
                            // Créer des comptes enrichis à partir des données du système unifié
                            const quotaInfo = stats.quotaInfo || {};
                            const accountsUsage = quotaInfo.accountsUsage || {};
                            
                            const unifiedAccounts = Object.keys(accountsUsage).map(accountId => ({
                                id: accountId,
                                username: accountsUsage[accountId].username || accountId,
                                isActive: accountsUsage[accountId].isActive !== false,
                                dailyUsed: accountsUsage[accountId].dailyUsed || 0,
                                globalUsed: accountsUsage[accountId].globalUsed || 0
                            }));
                            
                            console.log('[QUOTA-UI] Comptes créés depuis système unifié:', unifiedAccounts);
                            updateActiveAccountsDisplay(unifiedAccounts);
                        }
                        
                        return stats;
                    })
                    .then(stats => {
                        if (stats) {
                            // Continuer avec le traitement des autres données
                            
                            // Mettre à jour l'allocation actuelle
                            updateAllocationDisplay(stats.allocation);
                            
                            // Mettre à jour le résumé global
                            updateSummaryDisplay(stats.summary);
                            
                            // Vérifier et mettre à jour quotaGlobalInput (si existe)
                            const quotaGlobalInput = document.getElementById('quotaGlobalInput');
                            if (quotaGlobalInput) {
                                quotaGlobalInput.value = stats.dailyQuotas.dailyLimit || 300;
                                quotaGlobalInput.max = stats.globalPack.totalActions;
                            }
                        
                        // Afficher les limites de sécurité avec les nouvelles données
                        const quotaLimits = document.getElementById('quotaLimits');
                        if (quotaLimits) {
                            const maxAllowed = Math.min(stats.globalPack.totalActions, 1000);
                            quotaLimits.innerHTML = `
                                💳 Pack global: ${stats.globalPack.totalActions.toLocaleString()} actions | 
                                🚫 Limite max/jour: ${maxAllowed} actions
                            `;
                        }
                        
                        // Charger les actions activées avec vérifications (valeurs par défaut)
                        const enabledActions = ['like', 'retweet', 'reply'];
                        
                        const enableLike = document.getElementById('enableLike');
                        if (enableLike) {
                            enableLike.checked = enabledActions.includes('like');
                        }
                        
                        const enableRetweet = document.getElementById('enableRetweet');
                        if (enableRetweet) {
                            enableRetweet.checked = enabledActions.includes('retweet');
                        }
                        
                        const enableComment = document.getElementById('enableComment');
                        if (enableComment) {
                            enableComment.checked = enabledActions.includes('reply');
                        }
                        
                        // Note: Les fonctions updateQuotasDistribution et updateQuotasDisplay
                        // appartiennent à l'ancien système de quotas par compte.
                        // Le nouveau système de quota global partagé utilise les fonctions
                        // updateGlobalPackDisplay, updateActiveAccountsDisplay, etc.
                        // qui sont déjà appelées ci-dessus.
                    }
                })
                .catch(err => console.error('Erreur lors du chargement des quotas:', err));
        }
        
        // ===== FONCTIONS POUR QUOTA GLOBAL PARTAGÉ =====
        
        /**
         * Mettre à jour l'affichage du pack global
         */
        function updateGlobalPackDisplay(globalPack) {
            const packInfoElement = document.getElementById('globalPackInfo');
            if (packInfoElement) {
                const usagePercent = Math.round((globalPack.usedActions / globalPack.totalActions) * 100);
                packInfoElement.innerHTML = `
                    <div style="background:#f8f9fa;padding:15px;border-radius:8px;margin-bottom:15px;">
                        <h4 style="margin:0 0 10px 0;color:#1da1f2;">🎁 Pack Global</h4>
                        <div style="display:flex;gap:20px;flex-wrap:wrap;">
                            <div><strong>Total:</strong> ${globalPack.totalActions.toLocaleString()} actions</div>
                            <div><strong>Utilisées:</strong> ${globalPack.usedActions.toLocaleString()} actions</div>
                            <div><strong>Restantes:</strong> ${globalPack.remainingActions.toLocaleString()} actions</div>
                            <div><strong>Utilisation:</strong> ${usagePercent}%</div>
                        </div>
                        <div style="background:#e9ecef;height:8px;border-radius:4px;margin-top:10px;">
                            <div style="background:#1da1f2;height:100%;width:${usagePercent}%;border-radius:4px;"></div>
                        </div>
                    </div>
                `;
            }
        }
        
        /**
         * Mettre à jour l'affichage des comptes actifs avec statut enrichi
         */
        function updateActiveAccountsDisplay(activeAccounts) {
            const accountsElement = document.getElementById('activeAccountsList');
            if (accountsElement) {
                if (activeAccounts.length === 0) {
                    accountsElement.innerHTML = '<p style="color:#666;">No account connected</p>';
                    return;
                }
                
                let html = '<h4 style="margin:0 0 15px 0;color:#1da1f2;">💱 Active Accounts</h4>';
                
                activeAccounts.forEach(account => {
                    const dailyTotal = Object.values(account.dailyUsed).reduce((sum, val) => sum + val, 0);
                    const quotaPercent = Math.round((account.actionsUsed / (account.actionsUsed + account.quotaRemaining)) * 100);
                    const dailyPercent = Math.round((dailyTotal / (dailyTotal + account.dailyRemaining)) * 100);
                    
                    // Déterminer l'icône et la couleur du statut
                    let statusIcon = '✅';
                    let statusColor = '#28a745';
                    let statusText = 'Active';
                    
                    if (account.status) {
                        switch (account.status.state) {
                            case 'paused':
                                statusIcon = '⏸️';
                                statusColor = '#ffc107';
                                statusText = account.status.reason || 'Paused';
                                break;
                            case 'working':
                                statusIcon = '🚀';
                                statusColor = '#007bff';
                                statusText = account.status.reason || 'In action';
                                break;
                            case 'active':
                            default:
                                statusIcon = '✅';
                                statusColor = '#28a745';
                                statusText = 'Ready to Work';
                                break;
                        }
                    }
                    
                    html += `
                        <div style="background:#f8f9fa;padding:12px;border-radius:6px;margin-bottom:10px;border-left:4px solid ${statusColor};">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                                <div style="display:flex;align-items:center;gap:8px;">
                                    <strong>@${account.displayName || account.username}</strong>
                                    <span style="background:#${account.authMethod === 'oauth2' ? '1da1f2' : '17bf63'};color:white;padding:2px 8px;border-radius:12px;font-size:12px;">
                                        ${account.authMethod.toUpperCase()}
                                    </span>
                                </div>
                            </div>
                            
                            <!-- Indicateur de statut -->
                            <div style="display:flex;align-items:center;gap:6px;margin-bottom:10px;padding:6px 10px;background:rgba(${statusColor === '#28a745' ? '40,167,69' : statusColor === '#ffc107' ? '255,193,7' : '23,162,184'},0.1);border-radius:4px;">
                                <span style="font-size:14px;">${statusIcon}</span>
                                <span style="font-size:13px;color:${statusColor};font-weight:500;">${statusText}</span>
                            </div>
                            
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;font-size:13px;">
                                <div>
                                    <div><strong>Quota Global:</strong> ${account.actionsUsed}/${account.actionsUsed + account.quotaRemaining} (${quotaPercent}%)</div>
                                    <div style="background:#e9ecef;height:4px;border-radius:2px;margin-top:2px;">
                                        <div style="background:#dc3545;height:100%;width:${quotaPercent}%;border-radius:2px;"></div>
                                    </div>
                                </div>
                                <div>
                                    <div><strong>Aujourd'hui:</strong> ${dailyTotal}/${dailyTotal + account.dailyRemaining} (${dailyPercent}%)</div>
                                    <div style="background:#e9ecef;height:4px;border-radius:2px;margin-top:2px;">
                                        <div style="background:#28a745;height:100%;width:${dailyPercent}%;border-radius:2px;"></div>
                                    </div>
                                </div>
                            </div>
                            <div style="display:flex;gap:15px;margin-top:8px;font-size:12px;">
                                <span style="color:#e0245e;">❤️ ${account.dailyUsed.like || 0} likes</span>
                                <span style="color:#17bf63;">🔄 ${account.dailyUsed.retweet || 0} retweets</span>
                                <span style="color:#ffad1f;">💬 ${account.dailyUsed.reply || 0} replies</span>
                            </div>
                        </div>
                    `;
                });
                
                accountsElement.innerHTML = html;
            }
        }
        
        /**
         * Mettre à jour l'affichage de l'allocation avec les vraies données des quotas
         */
        async function updateAllocationDisplay() {
            const allocationElement = document.getElementById('allocationInfo');
            if (!allocationElement) {
                console.warn('[FRONTEND] Element allocationInfo not found in DOM');
                return;
            }

            try {
                // Récupérer les vraies données des quotas depuis l'API
                const response = await fetch(`${API_BASE_URL}/api/quotas`);
                const data = await response.json();
                
                if (data.success && data.quotas) {
                    const quotas = data.quotas;
                    const totalLimit = (quotas.totalUsed || 0) + (quotas.totalRemaining || 0);
                    const usagePercent = totalLimit > 0 ? Math.round((quotas.totalUsed / totalLimit) * 100) : 0;
                    
                    
                } else {
                    throw new Error('Invalid quota data received');
                }
            } catch (error) {
                console.error('[FRONTEND] Error loading quota allocation:', error);
                allocationElement.innerHTML = `
                    <div style="background:#fff3cd;padding:12px;border-radius:6px;margin-bottom:15px;border:1px solid #ffeaa7;">
                        <h4 style="margin:0 0 10px 0;color:#856404;">⚠️ Erreur de connexion</h4>
                        <p style="margin:0;color:#856404;">Impossible de récupérer les données des quotas. Vérifiez que le serveur est démarré.</p>
                    </div>
                `;
            }
        }
        
        /**
         * Mettre à jour le résumé global
         */
        function updateSummaryDisplay(summary) {
            const summaryElement = document.getElementById('quotasSummary');
            if (summaryElement && summary) {
                // Sécuriser l'accès aux propriétés avec des valeurs par défaut
                const totalActiveAccounts = summary.totalActiveAccounts || 0;
                const globalUsagePercent = summary.globalUsagePercent || 0;
                const dailyUsagePercent = summary.dailyUsagePercent || 0;
                
                summaryElement.innerHTML = `
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:15px;">
                        <div style="background:#fff3cd;padding:12px;border-radius:6px;text-align:center;">
                            <div style="font-size:24px;font-weight:bold;color:#856404;">${totalActiveAccounts}</div>
                            <div style="font-size:12px;color:#856404;">Comptes Actifs</div>
                        </div>
                        <div style="background:#d1ecf1;padding:12px;border-radius:6px;text-align:center;">
                            <div style="font-size:24px;font-weight:bold;color:#0c5460;">${globalUsagePercent}%</div>
                            <div style="font-size:12px;color:#0c5460;">Pack Utilisé</div>
                        </div>
                        <div style="background:#d4edda;padding:12px;border-radius:6px;text-align:center;">
                            <div style="font-size:24px;font-weight:bold;color:#155724;">${dailyUsagePercent}%</div>
                            <div style="font-size:12px;color:#155724;">Quota Journalier</div>
                        </div>
                    </div>
                `;
            }
        }
        
        function updateQuotasDistribution(quotasData) {
            const distribution = quotasData.distribution || { like: 45, retweet: 10, reply: 45 };
            const dailyLimit = quotasData.dailyLimit || 3000;
            
            const likeQuota = Math.floor(dailyLimit * distribution.like / 100);
            const retweetQuota = Math.floor(dailyLimit * distribution.retweet / 100);
            const replyQuota = Math.floor(dailyLimit * distribution.reply / 100);
            
            const repartitionQuotas = document.getElementById('repartitionQuotas');
            if (repartitionQuotas) {
                repartitionQuotas.innerHTML = `
                    <div style="display:flex;gap:15px;flex-wrap:wrap;">
                        <span style="color:#e0245e;font-weight:600;">❤️ ${likeQuota} likes (${distribution.like}%)</span>
                        <span style="color:#17bf63;font-weight:600;">🔄 ${retweetQuota} retweets (${distribution.retweet}%)</span>
                        <span style="color:#ffad1f;font-weight:600;">💬 ${replyQuota} replies (${distribution.reply}%)</span>
                    </div>
                `;
            } else {
                console.warn('[DEBUG] Element repartitionQuotas not found in DOM');
            }
            }
            
            function updateQuotasDisplay(quotas, actionsLeft, quotasData) {
                // Mettre à jour l'affichage principal des quotas
                const quotaElt = document.getElementById('quotasDashboard');
                if (!quotaElt) return;
            
            let html = '<b>Actions restantes aujourd\'hui :</b> ';
            let totalLeft = 0, totalQuota = 0;
            
            if (quotas.like) {
                html += `<span style="color:#e0245e;font-weight:600;">❤️ ${actionsLeft.like || 0}/${quotas.like}</span>`;
                totalLeft += actionsLeft.like || 0;
                totalQuota += quotas.like;
            }
            
            if (quotas.retweet) {
                html += ` | <span style="color:#17bf63;font-weight:600;">🔄 ${actionsLeft.retweet || 0}/${quotas.retweet}</span>`;
                totalLeft += actionsLeft.retweet || 0;
                totalQuota += quotas.retweet;
            }
            
            if (quotas.reply) {
                html += ` | <span style="color:#ffad1f;font-weight:600;">💬 ${actionsLeft.reply || 0}/${quotas.reply}</span>`;
                totalLeft += actionsLeft.reply || 0;
                totalQuota += quotas.reply;
            }
            
            html += ` <span style="margin-left:15px;color:#1abc9c;font-weight:bold;">📊 Total: ${totalLeft}/${totalQuota}</span>`;
            
            // Affichage des crédits totaux
            if (quotasData) {
                const percentage = Math.round((quotasData.usedCredits / quotasData.totalCredits) * 100);
                const creditColor = percentage > 80 ? '#e74c3c' : percentage > 60 ? '#f39c12' : '#27ae60';
                html += `<br><span style="color:${creditColor};font-weight:bold;margin-top:8px;display:inline-block;">💳 Crédits: ${quotasData.remainingCredits}/${quotasData.totalCredits} (${100-percentage}% restant)</span>`;
            }
            
                quotaElt.innerHTML = html;
            }
            
            function saveQuotasSettings() {
                const dailyLimit = parseInt(document.getElementById('quotaGlobalInput').value);
                const enabledActions = [];
                
                if (document.getElementById('enableLike').checked) enabledActions.push('like');
                if (document.getElementById('enableRetweet').checked) enabledActions.push('retweet');
                if (document.getElementById('enableComment').checked) enabledActions.push('reply');
                
                const status = document.getElementById('quotasSaveStatus');
                
                if (!dailyLimit || dailyLimit < 1) {
                    status.textContent = 'Quota invalide';
                    status.style.color = '#e74c3c';
                    return;
                }
                
                if (enabledActions.length === 0) {
                    status.textContent = 'Au moins une action doit être activée';
                    status.style.color = '#e74c3c';
                    return;
                }
                
                fetch(`${API_BASE_URL}/api/set-action-limit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ dailyLimit, enabledActions })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        status.textContent = 'Quotas saved!';
                        status.style.color = '#27ae60';
                        
                        // Recharger les données
                        loadQuotasSettings();
                        refreshDashboard();
                    } else {
                        status.textContent = data.error || 'Error';
                        status.style.color = '#e74c3c';
                    }
                })
                .catch(err => {
                    status.textContent = 'Network error';
                    status.style.color = '#e74c3c';
                    console.error('Error:', err);
                });
            }
            
            // --- Fonction pour ouvrir le détail des actions ---
            function openActionsDetail(actionType) {
                // Open in new window/tab
                const url = `actions-detail.html?type=${actionType}`;
                window.open(url, '_blank', 'width=1000,height=700,scrollbars=yes,resizable=yes');
            }
            
            // Quick Start Guide functions are now defined globally above
            
            // ===== INFLUENCER SPOTLIGHT FUNCTIONS =====
            
            async function loadInfluencerStats() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/stats`);
                    const data = await response.json();
                    
                    if (data.success) {
                        updateInfluencerUI(data.stats);
                    } else {
                        console.error('[INFLUENCER] Error loading stats:', data.error);
                    }
                } catch (error) {
                    console.error('[INFLUENCER] Error fetching stats:', error);
                }
            }
            
            // Fonction manquante pour mettre à jour l'UI des influenceurs
            function updateInfluencerUI(stats) {
                try {
                    // Mise à jour des statistiques d'influenceurs si l'élément existe
                    const influencerStatsElement = document.getElementById('influencer-stats');
                    if (influencerStatsElement && stats) {
                        influencerStatsElement.innerHTML = `
                            <div class="stat-item">
                                <span class="stat-label">Total Interactions:</span>
                                <span class="stat-value">${stats.totalInteractions || 0}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Mega Influenceurs:</span>
                                <span class="stat-value">${stats.megaInfluencers || 0}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Macro Influenceurs:</span>
                                <span class="stat-value">${stats.macroInfluencers || 0}</span>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('[INFLUENCER] Erreur mise à jour UI:', error);
                }
            }
            
            // Fonction manquante pour mettre à jour les interactions récentes
            function updateRecentInteractionsUI(interactions) {
                try {
                    const recentInteractionsElement = document.getElementById('recent-interactions');
                    if (recentInteractionsElement && interactions) {
                        if (interactions.length === 0) {
                            recentInteractionsElement.innerHTML = '<p>Aucune interaction récente</p>';
                            return;
                        }
                        
                        const interactionsHTML = interactions.slice(0, 5).map(interaction => `
                            <div class="interaction-item">
                                <strong>@${interaction.influencer?.username || 'unknown'}</strong>
                                <span class="interaction-type">${interaction.interactionType || 'unknown'}</span>
                                <span class="interaction-time">${new Date(interaction.timestamp).toLocaleString()}</span>
                            </div>
                        `).join('');
                        
                        recentInteractionsElement.innerHTML = interactionsHTML;
                    }
                } catch (error) {
                    console.error('[INFLUENCER] Erreur mise à jour interactions:', error);
                }
            }
            
            async function loadRecentInfluencerInteractions() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/recent?limit=10`);
                    const data = await response.json();
                    
                    if (data.success) {
                        updateRecentInteractionsUI(data.interactions);
                    } else {
                        console.error('[INFLUENCER] Error loading recent interactions:', data.error);
                    }
                } catch (error) {
                    console.error('[INFLUENCER] Error fetching recent interactions:', error);
                }
            }
            
            // ===== NOUVELLES FONCTIONS POUR INTERFACE UNIFIÉE =====
            
            /**
             * Basculer l'affichage du panneau d'actions avancées
             */
            function toggleAdvancedActions() {
                const panel = document.getElementById('advancedActionsPanel');
                const icon = document.getElementById('advancedToggleIcon');
                
                if (panel && icon) {
                    if (panel.style.display === 'none' || panel.style.display === '') {
                        panel.style.display = 'block';
                        icon.className = 'fas fa-chevron-up';
                    } else {
                        panel.style.display = 'none';
                        icon.className = 'fas fa-chevron-down';
                    }
                }
            }
            
            /**
             * Exporter les données analytics en CSV
             */
            async function exportAnalyticsData() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/dashboard-stats`);
                    const data = await response.json();
                    
                    if (data.success) {
                        // Créer le contenu CSV
                        let csvContent = 'Type,Total,Aujourd\'hui,Cette heure\n';
                        csvContent += `Likes,${data.stats.totalLikes || 0},${data.stats.todayLikes || 0},${data.stats.hourLikes || 0}\n`;
                        csvContent += `Retweets,${data.stats.totalRetweets || 0},${data.stats.todayRetweets || 0},${data.stats.hourRetweets || 0}\n`;
                        csvContent += `Comments,${data.stats.totalComments || 0},${data.stats.todayComments || 0},${data.stats.hourComments || 0}\n`;
                        csvContent += `Total,${data.stats.totalActions || 0},${data.stats.todayActions || 0},${data.stats.hourActions || 0}\n`;
                        
                        // Télécharger le fichier
                        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                        const link = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', `analytics-data-${new Date().toISOString().split('T')[0]}.csv`);
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        console.log('[ANALYTICS] Données exportées avec succès');
                    } else {
                        console.error('[ANALYTICS] Erreur lors de l\'export:', data.error);
                        alert('Erreur lors de l\'export des données');
                    }
                } catch (error) {
                    console.error('[ANALYTICS] Erreur export:', error);
                    alert('Erreur lors de l\'export des données');
                }
            }
            
            /**
             * Réinitialiser les analytics (avec confirmation)
             */
            async function resetAnalytics() {
                if (!confirm('Êtes-vous sûr de vouloir réinitialiser toutes les données analytics ? Cette action est irréversible.')) {
                    return;
                }
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/reset-analytics`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        alert('Analytics reset successfully');
                        // Actualiser les données
                        refreshDashboard();
                    } else {
                        alert('Reset error: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('[ANALYTICS] Erreur reset:', error);
                    alert('Erreur lors de la réinitialisation');
                }
            }
            
            /**
             * Nettoyer les comptes déconnectés de la gestion des quotas
             */
            async function cleanupDisconnectedAccounts() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/cleanup-disconnected-accounts`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        if (data.changes) {
                            alert(`Nettoyage terminé ! ${data.activeAccounts} comptes actifs restants.`);
                        } else {
                            alert(`Aucun changement nécessaire. ${data.activeAccounts} comptes déjà actifs.`);
                        }
                        // Refresh dashboard data
                        refreshDashboard();
                    } else {
                        alert('Cleanup error: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('[QUOTA-CLEANUP] Erreur nettoyage:', error);
                    alert('Erreur lors du nettoyage des comptes déconnectés');
                }
            }
            
            // ===== NAVIGATION ACTIONS & PERFORMANCE =====
            
            /**
             * Open details for specific action type with real data
             * @param {string} actionType - Type d'action ('like', 'retweet', 'reply', 'all', 'all-time')
             */
            async function openActionsDetail(actionType) {
                console.log(`[ACTIONS-DETAIL] Ouverture des détails pour: ${actionType}`);
                
                // Afficher modal de chargement
                showLoadingModal(actionType);
                
                try {
                    // Récupérer les vraies données d'actions
                    const response = await fetch(`${API_BASE_URL}/api/actions-history`);
                    if (!response.ok) {
                        throw new Error(`Erreur API: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    if (!data.success || !data.actions) {
                        throw new Error('Données d\'actions indisponibles');
                    }
                    
                    // Filtrer les actions selon le type et la période
                    const filteredActions = filterActionsByType(data.actions, actionType);
                    
                    // Créer le contenu de la modal avec les vraies données
                    const { title, content } = createDetailedModalContent(actionType, filteredActions);
                    
                    // Afficher la modal avec les données
                    showModal(title, content);
                    
                    // Initialiser les filtres et interactions
                    initializeModalFilters(filteredActions, actionType);
                    
                } catch (error) {
                    console.error('[ACTIONS-DETAIL] Erreur chargement données:', error);
                    showErrorModal(actionType, error.message);
                }
            }
            
            /**
             * Filtrer les actions selon le type et la période
             */
            function filterActionsByType(actions, actionType) {
                const today = new Date().toDateString();
                
                switch(actionType) {
                    case 'like':
                        return actions.filter(a => a.actionType === 'like');
                    case 'retweet':
                        return actions.filter(a => a.actionType === 'retweet');
                    case 'reply':
                        return actions.filter(a => a.actionType === 'reply');
                    case 'all':
                        return actions.filter(a => {
                            const actionDate = new Date(a.timestamp).toDateString();
                            return actionDate === today;
                        });
                    case 'all-time':
                        return actions;
                    default:
                        return actions;
                }
            }
            
            /**
             * Créer le contenu détaillé de la modal avec vraies données
             */
            function createDetailedModalContent(actionType, actions) {
                let title, content;
                
                const actionTypeNames = {
                    'like': '❤️ Likes',
                    'retweet': '🔄 Retweets', 
                    'reply': '💬 Comments',
                    'all': '📊 Actions d\'Aujourd\'hui',
                    'all-time': '📈 Historique Complet'
                };
                
                title = `${actionTypeNames[actionType] || 'Actions'} - ${actions.length} actions`;
                
                content = `
                    <div style="padding: 0;">
                        <!-- En-tête avec statistiques -->
                        <div style="padding: 20px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-bottom: 1px solid #dee2e6;">
                            <div class="grid-2" style="margin-bottom: 15px;">
                                <div class="stat-card" style="padding: 15px; text-align: center; background: white;">
                                    <div style="font-size: 2rem; color: #28a745; font-weight: bold;">${actions.length}</div>
                                    <div style="color: #666;">Total Actions</div>
                                </div>
                                <div class="stat-card" style="padding: 15px; text-align: center; background: white;">
                                    <div style="font-size: 2rem; color: #007bff; font-weight: bold;">${[...new Set(actions.map(a => a.accountId))].length}</div>
                                    <div style="color: #666;">Comptes Actifs</div>
                                </div>
                            </div>
                            
                            <!-- Filtres -->
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                                <label style="font-weight: 600; color: #495057;">Filtres:</label>
                                <select id="filterPeriod" style="padding: 8px; border: 1px solid #ced4da; border-radius: 6px; background: white;">
                                    <option value="all">Toutes les périodes</option>
                                    <option value="today">Aujourd'hui</option>
                                    <option value="week">Cette semaine</option>
                                    <option value="month">Ce mois</option>
                                </select>
                                <select id="filterAccount" style="padding: 8px; border: 1px solid #ced4da; border-radius: 6px; background: white;">
                                    <option value="all">Tous les comptes</option>
                                    ${[...new Set(actions.map(a => a.accountId))].map(accountId => 
                                        `<option value="${accountId}">@${accountId}</option>`
                                    ).join('')}
                                </select>
                                <button onclick="applyFilters()" style="padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                    <i class="fas fa-filter"></i> Appliquer
                                </button>
                                <button onclick="exportActions()" style="padding: 8px 15px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                    <i class="fas fa-download"></i> Exporter
                                </button>
                            </div>
                        </div>
                        
                        <!-- Liste des actions -->
                        <div id="actionsList" style="max-height: 400px; overflow-y: auto; padding: 0;">
                            ${generateActionsList(actions)}
                        </div>
                        
                        <!-- Pied de page avec résumé -->
                        <div style="padding: 15px; background: #f8f9fa; border-top: 1px solid #dee2e6; text-align: center; color: #6c757d;">
                            <strong>🎆 Efficacité démontrée :</strong> ${actions.length} actions réalisées avec succès sur Twitter !
                        </div>
                    </div>
                `;
                
                return { title, content };
            }
            
            /**
             * Générer la liste HTML des actions
             */
            function generateActionsList(actions) {
                if (actions.length === 0) {
                    return `
                        <div style="padding: 40px; text-align: center; color: #6c757d;">
                            <i class="fas fa-inbox" style="font-size: 3rem; margin-bottom: 15px; opacity: 0.5;"></i>
                            <p>Aucune action trouvée pour cette période.</p>
                        </div>
                    `;
                }
                
                // Trier les actions par ordre chronologique décroissant (plus récent en premier)
                const sortedActions = [...actions].sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                return sortedActions.map((action, index) => {
                    const date = new Date(action.timestamp);
                    const timeAgo = getTimeAgo(date);
                    const actionIcon = getActionIcon(action.actionType);
                    const actionColor = getActionColor(action.actionType);
                    const tweetUrl = action.tweetUrl || `https://twitter.com/i/status/${action.tweetId || 'unknown'}`;
                    
                    return `
                        <div class="action-item" style="
                            padding: 15px 20px;
                            border-bottom: 1px solid #f0f0f0;
                            transition: background 0.2s;
                            cursor: pointer;
                        " onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='white'">
                            <div style="display: flex; align-items: center; gap: 15px;">
                                <!-- Icône d'action -->
                                <div style="
                                    width: 40px;
                                    height: 40px;
                                    border-radius: 50%;
                                    background: ${actionColor};
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    color: white;
                                    font-size: 1.2rem;
                                    flex-shrink: 0;
                                ">
                                    ${actionIcon}
                                </div>
                                
                                <!-- Informations de l'action -->
                                <div style="flex: 1; min-width: 0;">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 5px;">
                                        <div style="font-weight: 600; color: #333;">
                                            ${getActionLabel(action.actionType)}
                                            ${action.targetUser ? ` sur @${action.targetUser}` : ' sur le post'}
                                        </div>
                                        <div style="font-size: 0.85em; color: #6c757d; white-space: nowrap;">
                                            ${timeAgo}
                                        </div>
                                    </div>
                                    
                                    <div style="color: #6c757d; font-size: 0.9em; margin-bottom: 8px; line-height: 1.4;">
                                        <div style="margin-bottom: 3px;">
                                            <strong>Par:</strong> @${getUserDisplayName(action.accountId)}
                                            ${action.monitoredAccount ? ` • <strong>Compte surveillé:</strong> @${action.monitoredAccount}` : ''}
                                        </div>
                                        ${action.targetUser ? `
                                            <div style="font-size: 0.85em; color: #28a745; font-weight: 500;">
                                                🎯 Action ciblée sur @${action.targetUser}
                                            </div>
                                        ` : ''}
                                    </div>
                                    
                                    ${action.tweetText ? `
                                        <div style="
                                            background: #f8f9fa;
                                            padding: 10px;
                                            border-radius: 8px;
                                            border-left: 3px solid ${actionColor};
                                            margin-bottom: 10px;
                                            font-size: 0.9em;
                                            line-height: 1.4;
                                        ">
                                            "${action.tweetText.length > 100 ? action.tweetText.substring(0, 100) + '...' : action.tweetText}"
                                        </div>
                                    ` : ''}
                                    
                                    <!-- Boutons d'action -->
                                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                                        <a href="${tweetUrl}" target="_blank" style="
                                            padding: 6px 12px;
                                            background: #1da1f2;
                                            color: white;
                                            text-decoration: none;
                                            border-radius: 6px;
                                            font-size: 0.85em;
                                            display: inline-flex;
                                            align-items: center;
                                            gap: 5px;
                                        " onmouseover="this.style.background='#0d8bd9'" onmouseout="this.style.background='#1da1f2'">
                                            <i class="fab fa-twitter"></i> Voir le Post
                                        </a>
                                        
                                        ${action.targetUser ? `
                                            <a href="https://twitter.com/${action.targetUser}" target="_blank" style="
                                                padding: 6px 12px;
                                                background: #6c757d;
                                                color: white;
                                                text-decoration: none;
                                                border-radius: 6px;
                                                font-size: 0.85em;
                                                display: inline-flex;
                                                align-items: center;
                                                gap: 5px;
                                            " onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='#6c757d'">
                                                <i class="fas fa-user"></i> Profil Cible
                                            </a>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            /**
             * Obtenir l'icône pour un type d'action
             */
            function getActionIcon(actionType) {
                switch(actionType) {
                    case 'like': return '❤️';
                    case 'retweet': return '🔄';
                    case 'reply': return '💬';
                    default: return '📊';
                }
            }
            
            /**
             * Obtenir la couleur pour un type d'action
             */
            function getActionColor(actionType) {
                switch(actionType) {
                    case 'like': return '#e53e3e';
                    case 'retweet': return '#38a169';
                    case 'reply': return '#d69e2e';
                    default: return '#4a5568';
                }
            }
            
            /**
             * Obtenir le label pour un type d'action
             */
            function getActionLabel(actionType) {
                switch(actionType) {
                    case 'like': return 'Like effectué';
                    case 'retweet': return 'Retweet effectué';
                    case 'reply': return 'Commentaire posté';
                    default: return 'Action effectuée';
                }
            }
            
            /**
             * Calculer le temps écoulé depuis une date
             */
            function getTimeAgo(date) {
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);
                const diffDays = Math.floor(diffHours / 24);
                
                if (diffMins < 1) return 'À l\'instant';
                if (diffMins < 60) return `${diffMins}min`;
                if (diffHours < 24) return `${diffHours}h`;
                if (diffDays < 7) return `${diffDays}j`;
                return date.toLocaleDateString('fr-FR');
            }
            
            /**
             * Obtenir le nom d'affichage lisible pour un utilisateur
             * Convertit les IDs numériques en noms d'utilisateur humains
             */
            function getUserDisplayName(userId) {
                // Mapping des IDs vers les noms d'utilisateur lisibles
                const userMapping = {
                    '153720161': 'psyk0t',
                    // Add other mappings as needed
                };
                
                // Si on a un mapping, l'utiliser, sinon garder l'ID original
                return userMapping[userId] || userId;
            }
            
            /**
             * Afficher une modal de chargement
             */
            function showLoadingModal(actionType) {
                const actionNames = {
                    'like': 'Likes',
                    'retweet': 'Retweets',
                    'reply': 'Comments',
                    'all': 'Actions d\'Aujourd\'hui',
                    'all-time': 'Historique Complet'
                };
                
                const title = `Chargement des ${actionNames[actionType] || 'Actions'}...`;
                const content = `
                    <div style="padding: 40px; text-align: center;">
                        <div style="
                            width: 50px;
                            height: 50px;
                            border: 4px solid #f3f3f3;
                            border-top: 4px solid #007bff;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                            margin: 0 auto 20px;
                        "></div>
                        <p style="color: #6c757d; font-size: 1.1em;">Récupération des données d'actions...</p>
                        <style>
                            @keyframes spin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                        </style>
                    </div>
                `;
                
                showModal(title, content);
            }
            
            /**
             * Afficher une modal d'erreur
             */
            function showErrorModal(actionType, errorMessage) {
                const title = 'Erreur de Chargement';
                const content = `
                    <div style="padding: 40px; text-align: center;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #dc3545; margin-bottom: 20px;"></i>
                        <h3 style="color: #dc3545; margin-bottom: 15px;">Impossible de charger les données</h3>
                        <p style="color: #6c757d; margin-bottom: 20px;">${errorMessage}</p>
                        <button onclick="closeModal()" style="
                            padding: 10px 20px;
                            background: #dc3545;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                        ">Close</button>
                    </div>
                `;
                
                showModal(title, content);
            }
            
            /**
             * Initialiser les filtres de la modal
             */
            function initializeModalFilters(actions, actionType) {
                // Stocker les actions pour les filtres
                window.currentModalActions = actions;
                window.currentModalActionType = actionType;
                
                // Écouter les changements de filtres
                const filterPeriod = document.getElementById('filterPeriod');
                const filterAccount = document.getElementById('filterAccount');
                
                if (filterPeriod) {
                    filterPeriod.addEventListener('change', applyFilters);
                }
                if (filterAccount) {
                    filterAccount.addEventListener('change', applyFilters);
                }
            }
            
            /**
             * Appliquer les filtres aux actions
             */
            function applyFilters() {
                if (!window.currentModalActions) return;
                
                const filterPeriod = document.getElementById('filterPeriod')?.value || 'all';
                const filterAccount = document.getElementById('filterAccount')?.value || 'all';
                
                let filteredActions = [...window.currentModalActions];
                
                // Filtrer par période
                if (filterPeriod !== 'all') {
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const thisWeek = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                    const thisMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                    
                    filteredActions = filteredActions.filter(action => {
                        const actionDate = new Date(action.timestamp);
                        switch(filterPeriod) {
                            case 'today': return actionDate >= today;
                            case 'week': return actionDate >= thisWeek;
                            case 'month': return actionDate >= thisMonth;
                            default: return true;
                        }
                    });
                }
                
                // Filtrer par compte
                if (filterAccount !== 'all') {
                    filteredActions = filteredActions.filter(action => action.accountId === filterAccount);
                }
                
                // Mettre à jour la liste
                const actionsList = document.getElementById('actionsList');
                if (actionsList) {
                    actionsList.innerHTML = generateActionsList(filteredActions);
                }
                
                console.log(`[FILTERS] ${filteredActions.length} actions après filtrage`);
            }
            
            /**
             * Exporter les actions en CSV
             */
            function exportActions() {
                if (!window.currentModalActions) return;
                
                const actions = window.currentModalActions;
                const actionType = window.currentModalActionType;
                
                // Créer le contenu CSV
                const headers = ['Date', 'Heure', 'Type', 'Compte', 'Cible', 'Texte du Tweet', 'URL du Tweet'];
                const csvContent = [
                    headers.join(','),
                    ...actions.map(action => {
                        const date = new Date(action.timestamp);
                        return [
                            date.toLocaleDateString('fr-FR'),
                            date.toLocaleTimeString('fr-FR'),
                            action.actionType,
                            action.accountId,
                            action.targetUser || '',
                            `"${(action.tweetText || '').replace(/"/g, '""')}"`,
                            action.tweetUrl || `https://twitter.com/i/status/${action.tweetId || ''}`
                        ].join(',');
                    })
                ].join('\n');
                
                // Télécharger le fichier
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `actions-${actionType}-${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(`[EXPORT] ${actions.length} actions exportées en CSV`);
            }
            
            /**
             * Close modal
             */
            function closeModal() {
                const modal = document.getElementById('actionsDetailModal');
                if (modal) {
                    modal.remove();
                }
                // Nettoyer les variables globales
                window.currentModalActions = null;
                window.currentModalActionType = null;
            }
            
            // Rendre les fonctions accessibles globalement
            window.closeModal = closeModal;
            window.applyFilters = applyFilters;
            window.exportActions = exportActions;
            
            /**
             * Afficher une modal avec le contenu spécifié
             */
            function showModal(title, content) {
                // Remove any existing modal
                const existingModal = document.getElementById('actionsDetailModal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                // Créer la modal
                const modal = document.createElement('div');
                modal.id = 'actionsDetailModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: white;
                        border-radius: 15px;
                        max-width: 800px;
                        width: 90%;
                        max-height: 80%;
                        overflow-y: auto;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    ">
                        <div style="
                            padding: 20px;
                            border-bottom: 1px solid #eee;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                            border-radius: 15px 15px 0 0;
                        ">
                            <h2 style="margin: 0; color: #333;">${title}</h2>
                            <button onclick="closeModal()" style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                                color: #666;
                                padding: 5px;
                                border-radius: 50%;
                                width: 35px;
                                height: 35px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            " onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                                ×
                            </button>
                        </div>
                        <div>${content}</div>
                        <div style="
                            padding: 20px;
                            border-top: 1px solid #eee;
                            text-align: right;
                            background: #f8f9fa;
                            border-radius: 0 0 15px 15px;
                        ">
                            <button onclick="closeModal()" class="btn" style="
                                padding: 10px 20px;
                                background: #6c757d;
                                color: white;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                            ">Close</button>
                        </div>
                    </div>
                `;
                
                // Add modal to DOM
                document.body.appendChild(modal);
                
                // Close modal by clicking background
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal();
                    }
                });
            }
            
            /**
             * Peupler les données de la modal avec les vraies données
             */
            function populateModalData(actionType) {
                // Récupérer les données actuelles depuis les éléments du dashboard
                const likesToday = document.getElementById('analyticsLikesToday')?.textContent || '0';
                const retweetsToday = document.getElementById('analyticsRetweetsToday')?.textContent || '0';
                const commentsToday = document.getElementById('analyticsCommentsToday')?.textContent || '0';
                const totalToday = document.getElementById('analyticsTotalToday')?.textContent || '0';
                
                const likesTotal = document.getElementById('analyticsLikesTotal')?.textContent || '0';
                const retweetsTotal = document.getElementById('analyticsRetweetsTotal')?.textContent || '0';
                const commentsTotal = document.getElementById('analyticsCommentsTotal')?.textContent || '0';
                const totalHistorique = document.getElementById('analyticsTotalHistorique')?.textContent || '0';
                
                // Peupler selon le type d'action
                switch(actionType) {
                    case 'like':
                        const modalLikesToday = document.getElementById('modalLikesToday');
                        const modalLikesTotal = document.getElementById('modalLikesTotal');
                        if (modalLikesToday) modalLikesToday.textContent = likesToday;
                        if (modalLikesTotal) modalLikesTotal.textContent = likesTotal;
                        break;
                        
                    case 'retweet':
                        const modalRetweetsToday = document.getElementById('modalRetweetsToday');
                        const modalRetweetsTotal = document.getElementById('modalRetweetsTotal');
                        if (modalRetweetsToday) modalRetweetsToday.textContent = retweetsToday;
                        if (modalRetweetsTotal) modalRetweetsTotal.textContent = retweetsTotal;
                        break;
                        
                    case 'reply':
                        const modalCommentsToday = document.getElementById('modalCommentsToday');
                        const modalCommentsTotal = document.getElementById('modalCommentsTotal');
                        if (modalCommentsToday) modalCommentsToday.textContent = commentsToday;
                        if (modalCommentsTotal) modalCommentsTotal.textContent = commentsTotal;
                        break;
                        
                    case 'all':
                        const modalAllLikesToday = document.getElementById('modalAllLikesToday');
                        const modalAllRetweetsToday = document.getElementById('modalAllRetweetsToday');
                        const modalAllCommentsToday = document.getElementById('modalAllCommentsToday');
                        const modalAllTotalToday = document.getElementById('modalAllTotalToday');
                        if (modalAllLikesToday) modalAllLikesToday.textContent = likesToday;
                        if (modalAllRetweetsToday) modalAllRetweetsToday.textContent = retweetsToday;
                        if (modalAllCommentsToday) modalAllCommentsToday.textContent = commentsToday;
                        if (modalAllTotalToday) modalAllTotalToday.textContent = totalToday;
                        break;
                        
                    case 'all-time':
                        const modalHistoryLikes = document.getElementById('modalHistoryLikes');
                        const modalHistoryRetweets = document.getElementById('modalHistoryRetweets');
                        const modalHistoryComments = document.getElementById('modalHistoryComments');
                        const modalHistoryTotal = document.getElementById('modalHistoryTotal');
                        if (modalHistoryLikes) modalHistoryLikes.textContent = likesTotal;
                        if (modalHistoryRetweets) modalHistoryRetweets.textContent = retweetsTotal;
                        if (modalHistoryComments) modalHistoryComments.textContent = commentsTotal;
                        if (modalHistoryTotal) modalHistoryTotal.textContent = totalHistorique;
                        break;
                }
            }
            
            // ===== FONCTIONS GESTION QUOTAS DYNAMIQUES =====
            
            /**
             * Refresh quota data from API
             */
            async function refreshQuotaData() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/shared-quota-stats`);
                    const data = await response.json();
                    
                    if (data.success) {
                        updateQuotaDisplay(data);
                        console.log('[QUOTA] Données rafraîchies avec succès');
                    } else {
                        console.error('[QUOTA] Erreur lors du rafraîchissement:', data.error);
                    }
                } catch (error) {
                    console.error('[QUOTA] Erreur réseau:', error);
                }
            }
            
            /**
             * Mettre à jour l'affichage des quotas
             */
            function updateQuotaDisplay(data) {
                // Mettre à jour le pack global
                const globalPackTotal = document.getElementById('globalPackTotal');
                const globalPackUsed = document.getElementById('globalPackUsed');
                const globalPackRemaining = document.getElementById('globalPackRemaining');
                const globalPackProgress = document.getElementById('globalPackProgress');
                const globalPackPercent = document.getElementById('globalPackPercent');
                const estimatedDaysLeft = document.getElementById('estimatedDaysLeft');
                
                // Sécuriser l'accès aux données du pack global
                const globalPack = data.globalPack || {};
                if (globalPackTotal) globalPackTotal.textContent = (globalPack.total || 0).toLocaleString();
                if (globalPackUsed) globalPackUsed.textContent = (globalPack.used || 0).toLocaleString();
                if (globalPackRemaining) globalPackRemaining.textContent = (globalPack.remaining || 0).toLocaleString();
                if (globalPackPercent) globalPackPercent.textContent = `${globalPack.usagePercent || 0}%`;
                if (estimatedDaysLeft) estimatedDaysLeft.textContent = globalPack.estimatedDaysLeft || '--';
                
                if (globalPackProgress) {
                    const usagePercent = globalPack.usagePercent || 0;
                    globalPackProgress.style.width = `${usagePercent}%`;
                    // Changer la couleur selon l'usage
                    if (usagePercent > 80) {
                        globalPackProgress.style.background = '#dc3545';
                    } else if (usagePercent > 60) {
                        globalPackProgress.style.background = '#ffc107';
                    } else {
                        globalPackProgress.style.background = '#28a745';
                    }
                }
                
                // Mettre à jour les comptes connectés (vue simplifiée)
                const connectedAccountsList = document.getElementById('connectedAccountsQuotas');
                if (connectedAccountsList && data.connectedAccounts) {
                    let html = '';
                    data.connectedAccounts.forEach(account => {
                        const usageColor = account.usagePercent > 80 ? '#dc3545' : 
                                         account.usagePercent > 60 ? '#ffc107' : '#28a745';
                        
                        html += `
                            <div style="background:#f8f9fa;padding:12px;border-radius:8px;margin-bottom:10px;border-left:4px solid ${usageColor};">
                                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                                    <div style="display:flex;align-items:center;gap:8px;">
                                        <strong>@${account.displayName}</strong>
                                        <span style="background:#${account.authMethod === 'oauth2' ? '1da1f2' : '17bf63'};color:white;padding:2px 8px;border-radius:12px;font-size:12px;">
                                            ${account.authMethod.toUpperCase()}
                                        </span>
                                    </div>
                                    <span style="color:${usageColor};font-weight:bold;">${account.usagePercent}%</span>
                                </div>
                                <div style="background:#e9ecef;border-radius:10px;height:8px;margin-bottom:8px;">
                                    <div style="background:${usageColor};height:100%;border-radius:10px;width:${account.usagePercent}%;transition:width 0.3s;"></div>
                                </div>
                                <div style="display:flex;justify-content:space-between;font-size:12px;color:#6c757d;">
                                    <span>Quota: ${account.dailyQuota}</span>
                                    <span>Utilisé: ${account.dailyUsed}</span>
                                    <span>Restant: ${account.dailyRemaining}</span>
                                </div>
                            </div>
                        `;
                    });
                    connectedAccountsList.innerHTML = html;
                }
                
                // Mettre à jour les quotas détaillés par type d'action pour chaque utilisateur
                const userQuotasDetails = document.getElementById('userQuotasDetails');
                if (userQuotasDetails && data.connectedAccounts) {
                    let detailsHtml = '';
                    
                    data.connectedAccounts.forEach(account => {
                        // Calculer la répartition des quotas par type d'action (45% likes, 10% retweets, 45% replies)
                        const dailyQuota = account.dailyQuota || 0;
                        const likesQuota = Math.floor(dailyQuota * 0.45);
                        const retweetsQuota = Math.floor(dailyQuota * 0.10);
                        const repliesQuota = Math.floor(dailyQuota * 0.45);
                        
                        // Simuler l'usage par type (à remplacer par les vraies données quand disponibles)
                        const totalUsed = account.dailyUsed || 0;
                        const likesUsed = Math.floor(totalUsed * 0.45);
                        const retweetsUsed = Math.floor(totalUsed * 0.10);
                        const repliesUsed = Math.floor(totalUsed * 0.45);
                        
                        const likesRemaining = Math.max(0, likesQuota - likesUsed);
                        const retweetsRemaining = Math.max(0, retweetsQuota - retweetsUsed);
                        const repliesRemaining = Math.max(0, repliesQuota - repliesUsed);
                        
                        detailsHtml += `
                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                <div style="display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #f8f9fa;">
                                    <div style="width: 40px; height: 40px; border-radius: 50%; background: linear-gradient(135deg, #1da1f2, #0d8bd9); display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                                        <i class="fas fa-user" style="color: white; font-size: 16px;"></i>
                                    </div>
                                    <div style="flex: 1;">
                                        <h6 style="margin: 0; color: #495057; font-size: 1.1em; font-weight: 600;">@${account.displayName}</h6>
                                        <div style="font-size: 0.8em; color: #6c757d;">
                                            <span style="background:#${account.authMethod === 'oauth2' ? '1da1f2' : '17bf63'};color:white;padding:2px 6px;border-radius:8px;font-size:11px;">
                                                ${account.authMethod.toUpperCase()}
                                            </span>
                                            <span style="margin-left: 8px;">Daily Quota: ${dailyQuota} actions</span>
                                        </div>
                                    </div>
                                    <button onclick="openUserActionsHistory('${account.displayName}')" 
                                            style="background: #17a2b8; color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.8em; transition: all 0.3s;"
                                            onmouseover="this.style.background='#138496'" 
                                            onmouseout="this.style.background='#17a2b8'"
                                            title="Voir l'historique des actions de cet utilisateur">
                                        <i class="fas fa-history"></i> Historique
                                    </button>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                                    <!-- Likes -->
                                    <div onclick="openUserActionsHistory('${account.displayName}', 'like')" 
                                         style="text-align: center; padding: 15px; background: linear-gradient(135deg, #fff5f5, #fed7d7); border-radius: 10px; border: 1px solid #fbb6ce; cursor: pointer; transition: all 0.3s;"
                                         onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(229,62,62,0.25)'"
                                         onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                         title="Cliquer pour voir l'historique des likes de @${account.displayName}">
                                        <div style="font-size: 1.8em; margin-bottom: 5px;">❤️</div>
                                        <div style="font-size: 1.4em; font-weight: bold; color: #e53e3e; margin-bottom: 3px;">${likesRemaining}</div>
                                        <div style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Likes disponibles</div>
                                        <div style="background: #e9ecef; border-radius: 6px; height: 6px; overflow: hidden;">
                                            <div style="background: #e53e3e; height: 100%; width: ${likesQuota > 0 ? Math.round((likesUsed / likesQuota) * 100) : 0}%; transition: width 0.3s;"></div>
                                        </div>
                                        <div style="font-size: 0.7em; color: #6c757d; margin-top: 4px;">${likesUsed}/${likesQuota}</div>
                                    </div>
                                    
                                    <!-- Retweets -->
                                    <div onclick="openUserActionsHistory('${account.displayName}', 'retweet')" 
                                         style="text-align: center; padding: 15px; background: linear-gradient(135deg, #f0fff4, #c6f6d5); border-radius: 10px; border: 1px solid #9ae6b4; cursor: pointer; transition: all 0.3s;"
                                         onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(56,161,105,0.25)'"
                                         onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                         title="Cliquer pour voir l'historique des retweets de @${account.displayName}">
                                        <div style="font-size: 1.8em; margin-bottom: 5px;">🔄</div>
                                        <div style="font-size: 1.4em; font-weight: bold; color: #38a169; margin-bottom: 3px;">${retweetsRemaining}</div>
                                        <div style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Retweets disponibles</div>
                                        <div style="background: #e9ecef; border-radius: 6px; height: 6px; overflow: hidden;">
                                            <div style="background: #38a169; height: 100%; width: ${retweetsQuota > 0 ? Math.round((retweetsUsed / retweetsQuota) * 100) : 0}%; transition: width 0.3s;"></div>
                                        </div>
                                        <div style="font-size: 0.7em; color: #6c757d; margin-top: 4px;">${retweetsUsed}/${retweetsQuota}</div>
                                    </div>
                                    
                                    <!-- Replies -->
                                    <div onclick="openUserActionsHistory('${account.displayName}', 'reply')" 
                                         style="text-align: center; padding: 15px; background: linear-gradient(135deg, #fffaf0, #feebc8); border-radius: 10px; border: 1px solid #f6e05e; cursor: pointer; transition: all 0.3s;"
                                         onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(214,158,46,0.25)'"
                                         onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                         title="Cliquer pour voir l'historique des replies de @${account.displayName}">
                                        <div style="font-size: 1.8em; margin-bottom: 5px;">💬</div>
                                        <div style="font-size: 1.4em; font-weight: bold; color: #d69e2e; margin-bottom: 3px;">${repliesRemaining}</div>
                                        <div style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Replies disponibles</div>
                                        <div style="background: #e9ecef; border-radius: 6px; height: 6px; overflow: hidden;">
                                            <div style="background: #d69e2e; height: 100%; width: ${repliesQuota > 0 ? Math.round((repliesUsed / repliesQuota) * 100) : 0}%; transition: width 0.3s;"></div>
                                        </div>
                                        <div style="font-size: 0.7em; color: #6c757d; margin-top: 4px;">${repliesUsed}/${repliesQuota}</div>
                                    </div>
                                </div>
                                
                                <!-- Résumé total pour cet utilisateur -->
                                <div onclick="openUserActionsHistory('${account.displayName}')" 
                                     style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s;"
                                     onmouseover="this.style.background='#e9ecef'"
                                     onmouseout="this.style.background='#f8f9fa'"
                                     title="Cliquer pour voir tout l'historique de @${account.displayName}">
                                    <div style="font-size: 0.9em; color: #495057;">
                                        <strong>📊 Total: ${totalUsed}/${dailyQuota} actions utilisées</strong>
                                        <span style="margin-left: 10px; color: #6c757d;">
                                            (${account.dailyRemaining} restantes)
                                        </span>
                                        <i class="fas fa-external-link-alt" style="margin-left: 8px; font-size: 0.8em; color: #6c757d;"></i>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    userQuotasDetails.innerHTML = detailsHtml;
                }
                
                // Mettre à jour le résumé
                const totalConnectedAccounts = document.getElementById('totalConnectedAccounts');
                if (totalConnectedAccounts) totalConnectedAccounts.textContent = data.totalConnected;
                
                // Mettre à jour le timestamp
                const lastQuotaUpdate = document.getElementById('lastQuotaUpdate');
                if (lastQuotaUpdate) {
                    const updateTime = new Date(data.lastUpdate).toLocaleTimeString('fr-FR');
                    lastQuotaUpdate.textContent = updateTime;
                }
            }
            
            /**
             * Afficher l'historique des quotas dans une nouvelle fenêtre
             */
            async function showQuotaHistory() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/actions-history?limit=200`);
                    const data = await response.json();
                    
                    if (data.success && data.history && Array.isArray(data.history)) {
                        const historyWindow = window.open('', '_blank', 'width=1000,height=700,scrollbars=yes,resizable=yes');
                        historyWindow.document.write(`
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>Historique des Quotas - X-AutoRaider</title>
                                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
                                <style>
                                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #f8f9fa; }
                                    .header { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                                    .history-item { background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #007bff; }
                                    .timestamp { color: #6c757d; font-size: 12px; }
                                    .action-type { font-weight: bold; color: #007bff; }
                                    .username { color: #28a745; font-weight: bold; }
                                </style>
                            </head>
                            <body>
                                <div class="header">
                                    <h1><i class="fas fa-history"></i> Historique des Actions</h1>
                                    <p>Total: ${data.history.length} actions enregistrées</p>
                                </div>
                                <div id="historyList">
                                    ${data.history.map(item => `
                                        <div class="history-item">
                                            <div class="timestamp">${new Date(item.timestamp).toLocaleString('fr-FR')}</div>
                                            <div><span class="action-type">${item.actionType.toUpperCase()}</span> par <span class="username">@${item.username}</span></div>
                                            <div style="margin-top:5px;color:#6c757d;">${item.details}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </body>
                            </html>
                        `);
                        historyWindow.document.close();
                    } else {
                        alert('Erreur lors de la récupération de l\'historique: ' + data.error);
                    }
                } catch (error) {
                    console.error('[QUOTA-HISTORY] Erreur:', error);
                    alert('Erreur lors de la récupération de l\'historique');
                }
            }
            
            /**
             * Ajuster la taille du pack global
             */
            async function adjustGlobalPack() {
                const newSize = prompt('Nouvelle taille du pack global (nombre d\'actions):');
                if (!newSize || isNaN(newSize) || parseInt(newSize) <= 0) {
                    alert('Veuillez entrer un nombre valide');
                    return;
                }
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/shared-quota/update-pack`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            totalActions: parseInt(newSize),
                            packType: 'premium',
                            expiryDate: null 
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        alert(`Pack mis à jour avec succès: ${newSize} actions`);
                        refreshQuotaData();
                    } else {
                        alert('Erreur lors de la mise à jour: ' + data.error);
                    }
                } catch (error) {
                    console.error('[QUOTA-UPDATE] Erreur:', error);
                    alert('Erreur lors de la mise à jour du pack');
                }
            }
            
            /**
             * Réinitialiser les quotas journaliers
             */
            async function resetDailyQuotas() {
                if (!confirm('Êtes-vous sûr de vouloir réinitialiser tous les quotas journaliers ? Cette action est irréversible.')) {
                    return;
                }
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/shared-quota/reset-daily`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        alert('Quotas journaliers réinitialisés avec succès');
                        refreshQuotaData();
                    } else {
                        alert('Erreur lors de la réinitialisation: ' + data.error);
                    }
                } catch (error) {
                    console.error('[QUOTA-RESET] Erreur:', error);
                    alert('Erreur lors de la réinitialisation');
                }
            }
            
            /**
             * Afficher le compte à rebours jusqu'au prochain reset
             */
            function updateQuotaResetCountdown() {
                const countdownElement = document.getElementById('quotaResetCountdown');
                if (!countdownElement) return;
                
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);
                
                const timeLeft = tomorrow - now;
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                
                countdownElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // === NOUVELLES FONCTIONS DASHBOARD GLASSMORPHISM ===
            
            // Variables globales pour le dashboard
            window.dashboardData = {
                nextScanTime: 0,
                successRate: 0,
                queueCount: 0,
                lastActionTime: null,
                aiAnalysisCount: 0
            };
            
            /**
             * Met à jour le countdown du prochain scan
             */
            async function updateNextScanCountdown() {
                try {
                    // Récupérer le temps du prochain scan depuis l'API
                    const response = await fetch(`${API_BASE_URL}/api/next-scan-time`);
                    const data = await response.json();
                    
                    if (data.success && data.nextScanTime) {
                        const timeStr = data.nextScanTime;
                        const nextScanEl = document.getElementById('nextScanTime');
                        const queueNextScanEl = document.getElementById('queueNextScan');
                        if (nextScanEl) nextScanEl.textContent = timeStr;
                        if (queueNextScanEl) queueNextScanEl.textContent = timeStr;
                    }
                } catch (error) {
                    console.error('[DASHBOARD] Erreur updateNextScanCountdown:', error);
                    // Valeur par défaut en cas d'erreur
                    const nextScanEl = document.getElementById('nextScanTime');
                    const queueNextScanEl = document.getElementById('queueNextScan');
                    if (nextScanEl) nextScanEl.textContent = 'Prochainement';
                    if (queueNextScanEl) queueNextScanEl.textContent = 'Prochainement';
                }
            }
            
            /**
             * Calcule et affiche le taux de succès
             */
            async function updateSuccessRate() {
                try {
                    // Récupérer le taux de succès depuis l'API
                    const response = await fetch(`${API_BASE_URL}/api/success-rate`);
                    const data = await response.json();
                    
                    const successRateEl = document.getElementById('successRate');
                    const progressBarEl = document.getElementById('successProgressBar');
                    
                    if (data.success && successRateEl && progressBarEl) {
                        const rate = Math.round(data.successRate || 0);
                        successRateEl.textContent = `${rate}%`;
                        progressBarEl.style.width = `${rate}%`;
                        
                        // Couleur selon le taux
                        if (rate >= 80) {
                            progressBarEl.style.background = 'linear-gradient(90deg, #38a169, #48bb78)';
                        } else if (rate >= 60) {
                            progressBarEl.style.background = 'linear-gradient(90deg, #d69e2e, #ecc94b)';
                        } else {
                            progressBarEl.style.background = 'linear-gradient(90deg, #e53e3e, #fc8181)';
                        }
                    }
                } catch (error) {
                    console.error('[DASHBOARD] Erreur updateSuccessRate:', error);
                    // Valeur par défaut en cas d'erreur
                    const successRateEl = document.getElementById('successRate');
                    const progressBarEl = document.getElementById('successProgressBar');
                    if (successRateEl) successRateEl.textContent = '85%';
                    if (progressBarEl) {
                        progressBarEl.style.width = '85%';
                        progressBarEl.style.background = 'linear-gradient(90deg, #38a169, #48bb78)';
                    }
                }
            }
            
            /**
             * Met à jour les métriques du jour avec comparaison
             */
            async function updateTodayMetrics() {
                try {
                    // Récupérer la comparaison quotidienne depuis l'API
                    const response = await fetch(`${API_BASE_URL}/api/daily-comparison`);
                    const data = await response.json();
                    
                    const todayTotalEl = document.getElementById('todayTotal');
                    const todayLikesEl = document.getElementById('todayLikes');
                    const todayRetweetsEl = document.getElementById('todayRetweets');
                    const todayCommentsEl = document.getElementById('todayComments');
                    const dailyGrowthEl = document.getElementById('dailyGrowth');
                    
                    if (data.success && data.today) {
                        if (todayTotalEl) todayTotalEl.textContent = data.today.total || 0;
                        if (todayLikesEl) todayLikesEl.textContent = data.today.likes || 0;
                        if (todayRetweetsEl) todayRetweetsEl.textContent = data.today.retweets || 0;
                        if (todayCommentsEl) todayCommentsEl.textContent = data.today.replies || 0;
                        
                        // Afficher la croissance quotidienne
                        const growth = data.growthPercentage || 0;
                        if (dailyGrowthEl) {
                            dailyGrowthEl.textContent = growth > 0 ? `+${growth}%` : `${growth}%`;
                            dailyGrowthEl.style.color = growth > 0 ? '#38a169' : '#e53e3e';
                            dailyGrowthEl.previousElementSibling.className = growth > 0 ? 'fas fa-arrow-up' : 'fas fa-arrow-down';
                        }
                    }
                } catch (error) {
                    console.error('[DASHBOARD] Erreur updateTodayMetrics:', error);
                    // Utiliser les données analytics existantes en fallback
                    if (window.analyticsData && window.analyticsData.actions) {
                        const todayTotalEl = document.getElementById('todayTotal');
                        const todayLikesEl = document.getElementById('todayLikes');
                        const todayRetweetsEl = document.getElementById('todayRetweets');
                        const todayCommentsEl = document.getElementById('todayComments');
                        
                        if (todayTotalEl) todayTotalEl.textContent = window.analyticsData.actions.today.total;
                        if (todayLikesEl) todayLikesEl.textContent = window.analyticsData.actions.today.like;
                        if (todayRetweetsEl) todayRetweetsEl.textContent = window.analyticsData.actions.today.retweet;
                        if (todayCommentsEl) todayCommentsEl.textContent = window.analyticsData.actions.today.reply;
                    }
                }
            }
            
            /**
             * Met à jour les informations des comptes
             */
            async function updateAccountsInfo() {
                try {
                    // Récupérer les données des comptes depuis l'API
                    const response = await fetch(`${API_BASE_URL}/api/accounts-status`);
                    const data = await response.json();
                    
                    const activeAccountsEl = document.getElementById('activeAccounts');
                    const pausedAccountsEl = document.getElementById('pausedAccounts');
                    const quotaUsageEl = document.getElementById('quotaUsageText');
                    const quotaNumbersEl = document.getElementById('quotaNumbers');
                    const quotaProgressEl = document.getElementById('quotaProgressBar');
                    
                    if (data.success && data.accounts) {
                        if (activeAccountsEl) activeAccountsEl.textContent = data.accounts.active;
                        if (pausedAccountsEl) pausedAccountsEl.textContent = data.accounts.paused;
                    }
                    
                    // Utiliser les données de quotas existantes
                    if (window.quotaData) {
                        const usagePercent = Math.round((window.quotaData.used / window.quotaData.total) * 100);
                        if (quotaUsageEl) quotaUsageEl.textContent = `${usagePercent}% Quota used`;
                        if (quotaNumbersEl) quotaNumbersEl.textContent = `${window.quotaData.remaining}/${window.quotaData.total}`;
                        if (quotaProgressEl) quotaProgressEl.style.width = `${usagePercent}%`;
                    }
                } catch (error) {
                    console.error('[DASHBOARD] Erreur updateAccountsInfo:', error);
                    // Valeurs par défaut en cas d'erreur
                    const activeAccountsEl = document.getElementById('activeAccounts');
                    const pausedAccountsEl = document.getElementById('pausedAccounts');
                    if (activeAccountsEl) activeAccountsEl.textContent = '3';
                    if (pausedAccountsEl) pausedAccountsEl.textContent = '1';
                }
            }
            
            /**
             * Met à jour les informations de la queue
             */
            async function updateQueueInfo() {
                try {
                    // Récupérer les données de la queue depuis l'API
                    const response = await fetch(`${API_BASE_URL}/api/automation-queue`);
                    const data = await response.json();
                    
                    const queueCountEl = document.getElementById('queueCount');
                    const nextScanEl = document.getElementById('nextScanTime');
                    
                    if (data.success) {
                        if (queueCountEl) queueCountEl.textContent = data.pendingActions || 0;
                        if (nextScanEl) nextScanEl.textContent = data.nextScanTime || 'Prochainement';
                    }
                } catch (error) {
                    console.error('[DASHBOARD] Erreur updateQueueInfo:', error);
                    // Valeurs par défaut en cas d'erreur
                    const queueCountEl = document.getElementById('queueCount');
                    const nextScanEl = document.getElementById('nextScanTime');
                    if (queueCountEl) queueCountEl.textContent = '0';
                    if (nextScanEl) nextScanEl.textContent = 'Prochainement';
                }
            }
            
            /**
             * Met à jour le live feed
             */
            function updateLiveFeed() {
                const lastActionEl = document.getElementById('lastActionTime');
                const aiAnalysisEl = document.getElementById('aiAnalysisStatus');
                const liveFeedQuotaEl = document.getElementById('liveFeedQuota');
                const liveTargetsEl = document.getElementById('liveTargetsList');
                
                // Dernière action
                if (lastActionEl && dashboardData.lastActionTime) {
                    const elapsed = Math.floor((Date.now() - dashboardData.lastActionTime) / 60000);
                    lastActionEl.textContent = `Last action ${elapsed}min ago`;
                }
                
                // Analyse IA
                if (aiAnalysisEl) {
                    aiAnalysisEl.textContent = `AI analyzing ${dashboardData.aiAnalysisCount} new tweets`;
                }
                
                // Quota live
                if (liveFeedQuotaEl && window.quotaData) {
                    liveFeedQuotaEl.textContent = `${window.quotaData.remaining}/${window.quotaData.total}`;
                }
                
                // Targets (utiliser les données existantes)
                if (liveTargetsEl && window.watchAccounts) {
                    const targets = window.watchAccounts.map(acc => `@${acc.username || acc}`).join(' ');
                    liveTargetsEl.textContent = targets || '@crypto_alpha @defi_news @nft_insider';
                }
            }
            
            /**
             * Met à jour le statut du moteur
             */
            function updateEngineStatus() {
                const engineStatusEl = document.getElementById('engineStatus');
                if (engineStatusEl) {
                    // Utiliser le statut d'automation existant
                    const automationStatusEl = document.getElementById('automationStatus');
                    if (automationStatusEl) {
                        const isActive = automationStatusEl.textContent.includes('ACTIVE') || 
                                       automationStatusEl.textContent.includes('ON');
                        engineStatusEl.textContent = isActive ? '●●● ONLINE' : '○○○ OFFLINE';
                        engineStatusEl.style.color = isActive ? '#38a169' : '#e53e3e';
                    }
                }
            }
            
            /**
             * Met à jour le statut de connexion du dashboard
             */
            function updateDashboardConnectionStatus(connected = true) {
                const statusElement = document.getElementById('dashboardConnectionStatus');
                const textElement = document.getElementById('connectionStatusText');
                const iconElement = statusElement?.querySelector('i');
                
                if (connected) {
                    if (iconElement) {
                        iconElement.className = 'fas fa-wifi';
                        iconElement.style.color = '#38a169';
                    }
                    if (textElement) textElement.textContent = 'Connecté';
                } else {
                    if (iconElement) {
                        iconElement.className = 'fas fa-wifi-slash';
                        iconElement.style.color = '#e53e3e';
                    }
                    if (textElement) textElement.textContent = 'Déconnecté';
                }
            }

            /**
             * Met à jour toutes les cards du dashboard
             */
            async function updateDashboardCards() {
                try {
                    updateDashboardConnectionStatus(true);
                    
                    await Promise.all([
                        updateTodayMetrics(),
                        updateAccountsInfo(),
                        updateQueueInfo(),
                        updateSuccessRate(),
                        updateNextScanCountdown()
                    ]);
                    
                    updateLiveFeed();
                } catch (error) {
                    console.error('[DASHBOARD] Erreur mise à jour:', error);
                    updateDashboardConnectionStatus(false);
                }
            }
            
            /**
             * Initialise le dashboard avec des données simulées
             */
            function initializeDashboard() {
                // Initialiser window.dashboardData si pas déjà fait
                if (!window.dashboardData) {
                    window.dashboardData = {
                        nextScanTime: 0,
                        successRate: 0,
                        queueCount: 0,
                        lastActionTime: null,
                        aiAnalysisCount: 0
                    };
                }
                
                // Données initiales simulées
                window.dashboardData.nextScanTime = Date.now() + 154000; // 2:34
                window.dashboardData.successRate = 80;
                window.dashboardData.queueCount = 7;
                window.dashboardData.lastActionTime = Date.now() - 120000; // 2min ago
                window.dashboardData.aiAnalysisCount = 3;
                
                // Première mise à jour
                updateDashboardCards();
                
                // Mise à jour du countdown chaque seconde
                setInterval(updateNextScanCountdown, 1000);
                
                // Mise à jour générale toutes les 30 secondes
                setInterval(updateDashboardCards, 30000);
            }
            
            // Rendre les fonctions accessibles globalement
            window.refreshQuotaData = refreshQuotaData;
            window.showQuotaHistory = showQuotaHistory;
            window.adjustGlobalPack = adjustGlobalPack;
            window.resetDailyQuotas = resetDailyQuotas;
            window.updateDashboardCards = updateDashboardCards;
            window.initializeDashboard = initializeDashboard;
            
            // ===== FONCTIONS SMART SCHEDULER (STUBS POUR ÉVITER LES ERREURS) =====
            
            /**
             * Charger la configuration du smart scheduler
             */
            async function loadSmartSchedulerConfig() {
                try {
                    // Pour l'instant, fonction vide pour éviter l'erreur
                    console.log('[SMART-SCHEDULER] Configuration chargée (stub)');
                } catch (error) {
                    console.error('[SMART-SCHEDULER] Erreur chargement config:', error);
                }
            }
            
            /**
             * Charger les statistiques du smart scheduler
             */
            async function loadSmartSchedulerStats() {
                try {
                    // Pour l'instant, fonction vide pour éviter l'erreur
                    console.log('[SMART-SCHEDULER] Statistiques chargées (stub)');
                } catch (error) {
                    console.error('[SMART-SCHEDULER] Erreur chargement stats:', error);
                }
            }
            
            /**
             * Charger la file d'attente du smart scheduler
             */
            async function loadSmartSchedulerQueue() {
                try {
                    // Pour l'instant, fonction vide pour éviter l'erreur
                    console.log('[SMART-SCHEDULER] File d\'attente chargée (stub)');
                } catch (error) {
                    console.error('[SMART-SCHEDULER] Erreur chargement queue:', error);
                }
            }
            
            /**
             * Basculer l'affichage du panneau d'actions avancées
             */
            function toggleAdvancedActions() {
                const panel = document.getElementById('advancedActionsPanel');
                const icon = document.getElementById('advancedToggleIcon');
                
                if (panel && icon) {
                    if (panel.style.display === 'none' || panel.style.display === '') {
                        panel.style.display = 'block';
                        icon.className = 'fas fa-chevron-up';
                    } else {
                        panel.style.display = 'none';
                        icon.className = 'fas fa-chevron-down';
                    }
                }
            }
            
            
            /**
             * Mettre à jour l'affichage unifié des comptes avec performances ET quotas
             */
            function updateUnifiedAccountsDisplay(accounts, analyticsData) {
                console.log('[ANALYTICS] updateUnifiedAccountsDisplay désactivée - comptes ignorés:', accounts?.length || 0);
                // Fonction désactivée pour simplifier le système
            }
            

            

            

            

            

            
            // Fonction utilitaire pour formater les nombres
            function formatNumber(num) {
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return num.toString();
            }
            
            // Fonction utilitaire pour le temps relatif (si pas déjà définie)
            function getRelativeTime(timestamp) {
                const now = new Date();
                const time = new Date(timestamp);
                const diffInSeconds = Math.floor((now - time) / 1000);
                
                if (diffInSeconds < 60) return 'Just now';
                if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
                if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
                return `${Math.floor(diffInSeconds / 86400)}d ago`;
            }
            
            // ===== TWITTER MONITORING FUNCTIONS =====
            
            function toggleTwitterConfig() {
                const panel = document.getElementById('twitterConfigPanel');
                if (panel.style.display === 'none' || panel.style.display === '') {
                    panel.style.display = 'block';
                    loadTwitterStatus();
                } else {
                    panel.style.display = 'none';
                }
            }
            
            async function checkTwitterStatus() {
                try {
                    // Vérifier le statut de l'API Twitter en tentant de récupérer la liste des tweets monitorés
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/monitor/list`);
                    const data = await response.json();
                    
                    if (data.success) {
                        updateTwitterStatus('connected', 'Twitter API opérationnelle (Bearer Token .env)');
                        updateMonitoredTweetsCount(data.tweets.length);
                        alert(`Twitter API opérationnelle!\n${data.tweets.length} tweets monitorés`);
                    } else {
                        updateTwitterStatus('error', `Erreur API: ${data.error}`);
                        alert(`Erreur: ${data.error}`);
                    }
                } catch (error) {
                    updateTwitterStatus('error', 'Erreur de connexion à l\'API');
                    alert('Erreur lors de la vérification: ' + error.message);
                }
            }
            
            async function startTwitterMonitoring() {
                const intervalMinutes = document.getElementById('monitoringInterval').value;
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/monitor/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ intervalMinutes: parseInt(intervalMinutes) })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        updateTwitterStatus('monitoring', `Monitoring actif (${intervalMinutes}min)`);
                        alert('Monitoring démarré avec succès!');
                    } else {
                        alert(`Erreur: ${data.error}`);
                    }
                } catch (error) {
                    alert('Erreur lors du démarrage: ' + error.message);
                }
            }
            
            async function stopTwitterMonitoring() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/monitor/stop`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        updateTwitterStatus('connected', 'Monitoring arrêté');
                        alert('Monitoring arrêté avec succès!');
                    } else {
                        alert(`Erreur: ${data.error}`);
                    }
                } catch (error) {
                    alert('Erreur lors de l\'arrêt: ' + error.message);
                }
            }
            
            async function viewMonitoredTweets() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/monitor/list`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const tweets = data.tweets;
                        let message = `Tweets monitorés (${tweets.length}):\n\n`;
                        
                        if (tweets.length === 0) {
                            message += 'Aucun tweet en cours de monitoring.';
                        } else {
                            tweets.forEach((tweet, index) => {
                                message += `${index + 1}. Tweet ID: ${tweet.id}\n`;
                                message += `   Ajouté: ${new Date(tweet.addedAt).toLocaleString()}\n`;
                                if (tweet.metadata.generatedBy) {
                                    message += `   Généré par: ${tweet.metadata.generatedBy}\n`;
                                }
                                message += '\n';
                            });
                        }
                        
                        alert(message);
                        updateMonitoredTweetsCount(tweets.length);
                    } else {
                        alert(`Erreur: ${data.error}`);
                    }
                } catch (error) {
                    alert('Erreur lors de la récupération: ' + error.message);
                }
            }
            
            async function loadTwitterStatus() {
                try {
                    // Charger le statut et la liste des tweets monitorés
                    const response = await fetch(`${API_BASE_URL}/api/influencer-detector/monitor/list`);
                    const data = await response.json();
                    
                    if (data.success) {
                        updateMonitoredTweetsCount(data.tweets.length);
                    }
                } catch (error) {
                    console.error('Erreur lors du chargement du statut Twitter:', error);
                }
            }
            
            function updateTwitterStatus(status, message) {
                const statusIcon = document.getElementById('twitterStatusIcon');
                const statusText = document.getElementById('twitterStatusText');
                
                const statusConfig = {
                    'disconnected': { icon: '⚪', color: '#95a5a6' },
                    'connected': { icon: '🟢', color: '#27ae60' },
                    'monitoring': { icon: '🔵', color: '#3498db' },
                    'error': { icon: '🔴', color: '#e74c3c' }
                };
                
                const config = statusConfig[status] || statusConfig.disconnected;
                
                statusIcon.textContent = config.icon;
                statusIcon.style.color = config.color;
                statusText.textContent = message;
            }
            
            function updateMonitoredTweetsCount(count) {
                const countElement = document.getElementById('monitoredTweetsCount');
                if (countElement) {
                    countElement.textContent = `${count} tweets monitorés`;
                }
            }
            

            

            
            // --- Fonction manquante pour générer les invitations ---
            function generateInvitationToken() {
                fetch(`${API_BASE_URL}/api/admin/projects/default/invite`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.inviteUrl) {
                        // Copier l'URL dans le presse-papiers
                        navigator.clipboard.writeText(data.inviteUrl).then(() => {
                            alert(`Lien d'invitation généré et copié dans le presse-papiers:\n\n${data.inviteUrl}`);
                        }).catch(() => {
                            // Fallback si le clipboard ne fonctionne pas
                            prompt('Lien d\'invitation généré (copiez-le manuellement):', data.inviteUrl);
                        });
                    } else {
                        alert('Error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error');
                });
            }

            // Mise à jour automatique de la répartition quand on change le quota global
            const quotaGlobalInput = document.getElementById('quotaGlobalInput');
            if (quotaGlobalInput) {
                quotaGlobalInput.addEventListener('input', function() {
                    const dailyLimit = parseInt(this.value) || 3000;
                    const distribution = { like: 45, retweet: 10, reply: 45 }; // Valeurs par défaut
                    updateQuotasDistribution({ dailyLimit, distribution });
                });
            }
            
            // Connect save button
            const saveQuotasBtn = document.getElementById('saveQuotasBtn');
            if (saveQuotasBtn) {
                saveQuotasBtn.addEventListener('click', saveQuotasSettings);
            }
            
            // Charger les quotas au démarrage
            loadQuotasSettings();
            
            // ===== SYSTÈME DE RAFRAÎCHISSEMENT AUTOMATIQUE =====
            
            let autoRefreshInterval = null;
            let isAutoRefreshEnabled = true;
            
            // Fonction de rafraîchissement automatique des analytics - VERSION SIMPLIFIÉE AVEC STATUT DYNAMIQUE
            function startAutoRefresh() {
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                }
                
                console.log('[AUTO-REFRESH] Démarrage du rafraîchissement automatique avec statut dynamique (20s)');
                
                // Rafraîchir immédiatement
                refreshAnalytics();
                refreshAccountStatus(); // Nouveau : rafraîchir le statut des comptes
                
                // Puis toutes les 20 secondes pour un statut plus dynamique
                autoRefreshInterval = setInterval(() => {
                    if (isAutoRefreshEnabled && !document.hidden) {
                        console.log('[AUTO-REFRESH] Rafraîchissement automatique des analytics et statuts...');
                        refreshAnalytics();
                        refreshAccountStatus();
                    }
                }, 20000); // 20 secondes pour un statut plus dynamique
            }
            
            // Fonction pour arrêter le rafraîchissement automatique
            function stopAutoRefresh() {
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                    console.log('[AUTO-REFRESH] Rafraîchissement automatique arrêté');
                }
            }
            
            // Fonction pour basculer le rafraîchissement automatique
            function toggleAutoRefresh() {
                isAutoRefreshEnabled = !isAutoRefreshEnabled;
                const toggleBtn = document.getElementById('autoRefreshToggle');
                
                if (isAutoRefreshEnabled) {
                    toggleBtn.innerHTML = '<i class="fas fa-pause"></i> Pause Auto-Refresh';
                    toggleBtn.className = 'btn btn-warning btn-sm';
                    console.log('[AUTO-REFRESH] Rafraîchissement automatique activé');
                } else {
                    toggleBtn.innerHTML = '<i class="fas fa-play"></i> Resume Auto-Refresh';
                    toggleBtn.className = 'btn btn-success btn-sm';
                    console.log('[AUTO-REFRESH] Rafraîchissement automatique mis en pause');
                }
            }
            
            // Nouvelle fonction pour rafraîchir uniquement le statut des comptes
            async function refreshAccountStatus() {
                try {
                    console.log('[STATUS-REFRESH] Rafraîchissement du statut des comptes...');
                    const response = await fetch(`${API_BASE_URL}/api/dashboard-stats`);
                    const data = await response.json();
                    
                    if (data.enrichedAccounts && Array.isArray(data.enrichedAccounts)) {
                        updateActiveAccountsDisplay(data.enrichedAccounts);
                        console.log('[STATUS-REFRESH] Statut des comptes mis à jour');
                    }
                } catch (error) {
                    console.error('[STATUS-REFRESH] Erreur lors du rafraîchissement du statut:', error);
                }
            }
            
            // Démarrer le rafraîchissement automatique au chargement de la page
            document.addEventListener('DOMContentLoaded', function() {
                console.log('[AUTO-REFRESH] Page chargée - démarrage du système automatique avec statut dynamique');
                
                // Démarrer après un délai pour laisser le temps à la page de se charger
                setTimeout(() => {
                    startAutoRefresh();
                }, 2000);
                
                // Arrêter le rafraîchissement quand l'utilisateur quitte la page
                window.addEventListener('beforeunload', stopAutoRefresh);
                
                // Reprendre le rafraîchissement quand la page redevient visible
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden) {
                        console.log('[AUTO-REFRESH] Page cachée - pause du rafraîchissement');
                        isAutoRefreshEnabled = false;
                    } else {
                        console.log('[AUTO-REFRESH] Page visible - reprise du rafraîchissement');
                        isAutoRefreshEnabled = true;
                        // Refresh immediately when page becomes visible
                        refreshAnalytics();
                    }
                });
            });
            
            // ===== EVENT LISTENERS POUR QUOTA GLOBAL PARTAGÉ =====
            
            // Bouton Recalculer
            const recalculateQuotasBtn = document.getElementById('recalculateQuotasBtn');
            if (recalculateQuotasBtn) {
                recalculateQuotasBtn.addEventListener('click', async function() {
                    try {
                        this.disabled = true;
                        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calcul...';
                        
                        const response = await fetch(`${API_BASE_URL}/api/shared-quota/recalculate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            console.log('[QUOTA-UI] Répartition recalculée:', result.allocation);
                            // Recharger les quotas pour afficher les nouvelles données
                            loadQuotasSettings();
                            alert('Répartition des quotas recalculée avec succès !');
                        } else {
                            alert('Erreur lors du recalcul: ' + result.error);
                        }
                    } catch (error) {
                        console.error('[QUOTA-UI] Erreur lors du recalcul:', error);
                        alert('Erreur lors du recalcul: ' + error.message);
                    } finally {
                        this.disabled = false;
                        this.innerHTML = '<i class="fas fa-calculator"></i> Recalculer';
                    }
                });
            }
            
            // Bouton Nouveau Pack supprimé pour des raisons de sécurité
            
            // Bouton Synchroniser Comptes
            const syncAccountsBtn = document.getElementById('syncAccountsBtn');
            if (syncAccountsBtn) {
                syncAccountsBtn.addEventListener('click', async function() {
                    try {
                        this.disabled = true;
                        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Synchronisation...';
                        
                        const response = await fetch(`${API_BASE_URL}/api/shared-quota/sync-accounts`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            console.log('[QUOTA-UI] Comptes synchronisés:', result.syncedCount);
                            // Recharger les quotas pour afficher les nouvelles données
                            loadQuotasSettings();
                            alert(`${result.syncedCount} compte(s) synchronisé(s) avec succès !`);
                        } else {
                            alert('Erreur lors de la synchronisation: ' + result.error);
                        }
                    } catch (error) {
                        console.error('[QUOTA-UI] Erreur lors de la synchronisation:', error);
                        alert('Erreur lors de la synchronisation: ' + error.message);
                    } finally {
                        this.disabled = false;
                        this.innerHTML = '<i class="fas fa-sync-alt"></i> Synchroniser Comptes';
                    }
                });
            }
            
            // Refresh Button
            const refreshQuotasBtn = document.getElementById('refreshQuotasBtn');
            if (refreshQuotasBtn) {
                refreshQuotasBtn.addEventListener('click', function() {
                    console.log('[QUOTA-UI] Actualisation des quotas demandée');
                    loadQuotasSettings();
                });
            }
            
            // Fonction updateGlobalPack supprimée pour des raisons de sécurité
            // Les utilisateurs ne peuvent plus modifier le pack global
            
            // --- Fonctions de planification intelligente ---
            async function loadSchedulerStats() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/smart-scheduler/stats`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    if (data.success === false) {
                        throw new Error(data.error || 'API error');
                    }
                    
                    // Mettre à jour les statistiques d'engagement
                    const actionsAnalyzed = data.engagementPatterns?.totalActionsAnalyzed || 0;
                    const queueLength = data.queueLength || 0;
                    
                    const totalActionsElement = document.getElementById('totalActionsAnalyzed');
                    const queueLengthElement = document.getElementById('queueLength');
                    
                    if (totalActionsElement) totalActionsElement.textContent = actionsAnalyzed;
                    if (queueLengthElement) queueLengthElement.textContent = queueLength;
                    
                    // Gérer la validation du Smart Scheduling
                    const validation = data.validation;
                    const enableCheckbox = document.getElementById('enableSmartScheduling');
                    const optimizationSelect = document.getElementById('optimizationLevel');
                    const validationMessage = document.getElementById('schedulerValidationMessage');
                    
                    if (validation) {
                        if (!validation.canEnable) {
                            // Bloquer l'interface si pas assez de données
                            enableCheckbox.disabled = true;
                            enableCheckbox.checked = false;
                            optimizationSelect.disabled = true;
                            
                            // Afficher le message de validation
                            const hoursLeft = Math.max(0, validation.hoursNeeded - validation.hoursCollected);
                            const progressPercent = Math.min(100, (validation.hoursCollected / validation.hoursNeeded) * 100);
                            
                            validationMessage.innerHTML = `
                                <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 12px; margin: 10px 0;">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                        <i class="fas fa-clock" style="color: #856404;"></i>
                                        <strong style="color: #856404;">Smart Scheduling Not Ready</strong>
                                    </div>
                                    <div style="font-size: 0.9em; color: #856404; margin-bottom: 8px;">
                                        ${validation.message}<br>
                                        <strong>Data collected:</strong> ${validation.hoursCollected}h / ${validation.hoursNeeded}h required
                                        ${validation.actionsCount > 0 ? `<br><strong>Actions recorded:</strong> ${validation.actionsCount}` : ''}
                                    </div>
                                    <div style="background: #f8f9fa; border-radius: 4px; height: 8px; overflow: hidden;">
                                        <div style="background: #28a745; height: 100%; width: ${progressPercent}%; transition: width 0.3s;"></div>
                                    </div>
                                    <div style="font-size: 0.8em; color: #6c757d; margin-top: 6px;">
                                        💡 <strong>Tip:</strong> For optimal results, wait 24h for a complete cycle analysis
                                    </div>
                                </div>
                            `;
                            validationMessage.style.display = 'block';
                        } else {
                            // Débloquer l'interface
                            enableCheckbox.disabled = false;
                            optimizationSelect.disabled = false;
                            
                            // Afficher un message de succès
                            if (validation.isRecommendedTime) {
                                validationMessage.innerHTML = `
                                    <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 12px; margin: 10px 0;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <i class="fas fa-check-circle" style="color: #155724;"></i>
                                            <strong style="color: #155724;">Smart Scheduling Ready!</strong>
                                        </div>
                                        <div style="font-size: 0.9em; color: #155724; margin-top: 4px;">
                                            ${validation.hoursCollected}h of data collected - Optimal analysis available
                                        </div>
                                    </div>
                                `;
                            } else {
                                validationMessage.innerHTML = `
                                    <div style="background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 8px; padding: 12px; margin: 10px 0;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <i class="fas fa-info-circle" style="color: #0c5460;"></i>
                                            <strong style="color: #0c5460;">Smart Scheduling Available</strong>
                                        </div>
                                        <div style="font-size: 0.9em; color: #0c5460; margin-top: 4px;">
                                            ${validation.hoursCollected}h collected - More data will improve accuracy
                                        </div>
                                    </div>
                                `;
                            }
                            validationMessage.style.display = 'block';
                        }
                    } else {
                        // Pas de données de validation, cacher le message
                        validationMessage.style.display = 'none';
                    }
                    
                    // Mettre à jour la configuration si l'interface n'est pas bloquée
                    if (data.config && !enableCheckbox.disabled) {
                        enableCheckbox.checked = data.config.enableSmartScheduling || false;
                        optimizationSelect.value = data.config.optimizationLevel || 'medium';
                    }
                    
                } catch (error) {
                    console.error('Erreur lors du chargement des stats du scheduler:', error);
                    // Afficher des valeurs par défaut en cas d'erreur
                    document.getElementById('totalActionsAnalyzed').textContent = '0';
                    document.getElementById('queueLength').textContent = '0';
                    
                    // Afficher un message d'erreur
                    const validationMessage = document.getElementById('schedulerValidationMessage');
                    validationMessage.innerHTML = `
                        <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 12px; margin: 10px 0;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-exclamation-triangle" style="color: #721c24;"></i>
                                <strong style="color: #721c24;">Error Loading Smart Scheduler</strong>
                            </div>
                            <div style="font-size: 0.9em; color: #721c24; margin-top: 4px;">
                                Unable to connect to scheduler service. Please try again.
                            </div>
                        </div>
                    `;
                    validationMessage.style.display = 'block';
                }
            }
            
            async function loadRecommendedTimeSlots() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/smart-scheduler/recommendations`);
                    const data = await response.json();
                    
                    if (data.success && data.recommendations) {
                        const container = document.getElementById('recommendedTimeSlots');
                        
                        if (data.recommendations.length === 0) {
                            container.innerHTML = '<div class="text-center text-muted">Not enough data to generate recommendations</div>';
                            return;
                        }
                        
                        let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">';
                        
                        data.recommendations.slice(0, 6).forEach(slot => {
                            const time = new Date(slot.time);
                            const timeStr = time.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                            const scoreColor = slot.recommendation === 'optimal' ? '#27ae60' : 
                                             slot.recommendation === 'good' ? '#f39c12' : '#e74c3c';
                            const icon = slot.recommendation === 'optimal' ? '⭐' : 
                                       slot.recommendation === 'good' ? '🟡' : '🔴';
                            
                            html += `
                                <div style="
                                    background: rgba(29, 161, 242, 0.05);
                                    border: 1px solid rgba(29, 161, 242, 0.2);
                                    border-radius: 8px;
                                    padding: 12px;
                                    text-align: center;
                                ">
                                    <div style="font-weight: bold; color: var(--primary-color);">${timeStr}</div>
                                    <div style="font-size: 0.9em; color: ${scoreColor}; margin-top: 4px;">
                                        ${icon} Score: ${slot.score}
                                    </div>
                                    <div style="font-size: 0.8em; color: var(--medium-gray); margin-top: 2px;">
                                        ${slot.recommendation}
                                    </div>
                                </div>
                            `;
                        });
                        
                        html += '</div>';
                        container.innerHTML = html;
                    }
                } catch (error) {
                    console.error('Error loading recommendations:', error);
                    document.getElementById('recommendedTimeSlots').innerHTML = 
                        '<div class="text-center text-muted">Error loading recommendations</div>';
                }
            }
            
            async function saveSchedulerConfig() {
                try {
                    const config = {
                        enableSmartScheduling: document.getElementById('enableSmartScheduling').checked,
                        optimizationLevel: document.getElementById('optimizationLevel').value,
                        maxDelayHours: document.getElementById('optimizationLevel').value === 'low' ? 6 :
                                     document.getElementById('optimizationLevel').value === 'medium' ? 24 : 48
                    };
                    
                    const response = await fetch(`${API_BASE_URL}/api/smart-scheduler/config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config })
                    });
                    
                    const data = await response.json();
                    const status = document.getElementById('schedulerStatus');
                    
                    if (data.success) {
                        status.innerHTML = '<div style="color: #27ae60; font-weight: bold;">✓ Configuration saved successfully!</div>';
                        
                        // Reload stats after update
                        setTimeout(() => {
                            loadSchedulerStats();
                            status.innerHTML = '';
                        }, 2000);
                    } else {
                        status.innerHTML = `<div style="color: #e74c3c; font-weight: bold;">❌ Error: ${data.error}</div>`;
                    }
                } catch (error) {
                    console.error('Error saving configuration:', error);
                    document.getElementById('schedulerStatus').innerHTML = 
                        '<div style="color: #e74c3c; font-weight: bold;">❌ Connection error</div>';
                }
            }
            
            async function forceAnalyzePatterns() {
                try {
                    const status = document.getElementById('schedulerStatus');
                    status.innerHTML = '<div style="color: #1da1f2; font-weight: bold;">🔄 Analysis in progress...</div>';
                    
                    const response = await fetch(`${API_BASE_URL}/api/smart-scheduler/analyze`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        status.innerHTML = `<div style="color: #27ae60; font-weight: bold;">✓ Analysis completed! ${data.totalActionsAnalyzed} actions analyzed</div>`;
                        
                        // Reload stats and recommendations
                        setTimeout(() => {
                            loadSchedulerStats();
                            status.innerHTML = '';
                        }, 3000);
                    } else {
                        status.innerHTML = `<div style="color: #e74c3c; font-weight: bold;">❌ Error: ${data.error}</div>`;
                    }
                } catch (error) {
                    console.error('Error during analysis:', error);
                    document.getElementById('schedulerStatus').innerHTML = 
                        '<div style="color: #e74c3c; font-weight: bold;">❌ Connection error</div>';
                }
            }
            
            // Charger les stats du scheduler au démarrage
            loadSchedulerStats();
            
            // IMPORTANT: Charger les quotas au démarrage pour éviter la perte des données après redémarrage
            loadQuotasSettings();
            
            // Charger l'affichage des allocations avec les vraies données
            updateAllocationDisplay();
            
            // Actualiser les stats du scheduler toutes les 30 secondes
            setInterval(loadSchedulerStats, 30000);
            
            // ========================================
            // SYSTÈME DE PRÉVISUALISATION DES TÂCHES À VENIR
            // ========================================
            
            // Variables globales pour la prévisualisation
            let upcomingTasksData = {
                tweetsFound: 0,
                actionsPlanned: 0,
                estimatedTime: 0,
                quotasRemaining: 0,
                activeAccounts: [],
                actionPlan: [],
                isVisible: false,
                refreshInterval: null
            };

            // Fonction pour afficher/masquer la section des tâches à venir
            function toggleUpcomingTasksPreview(show = true) {
                const preview = document.getElementById('upcomingTasksPreview');
                if (!preview) return;
                
                if (show && !upcomingTasksData.isVisible) {
                    preview.style.display = 'block';
                    upcomingTasksData.isVisible = true;
                    startUpcomingTasksRefresh();
                    console.log('📋 Upcoming Tasks Preview: Activé');
                } else if (!show && upcomingTasksData.isVisible) {
                    preview.style.display = 'none';
                    upcomingTasksData.isVisible = false;
                    stopUpcomingTasksRefresh();
                    console.log('📋 Upcoming Tasks Preview: Désactivé');
                }
            }

            // Fonction pour démarrer le rafraîchissement automatique
            function startUpcomingTasksRefresh() {
                if (upcomingTasksData.refreshInterval) {
                    clearInterval(upcomingTasksData.refreshInterval);
                }
                
                // Rafraîchir immédiatement puis toutes les 15 secondes
                refreshUpcomingTasks();
                upcomingTasksData.refreshInterval = setInterval(refreshUpcomingTasks, 15000);
            }

            // Fonction pour arrêter le rafraîchissement automatique
            function stopUpcomingTasksRefresh() {
                if (upcomingTasksData.refreshInterval) {
                    clearInterval(upcomingTasksData.refreshInterval);
                    upcomingTasksData.refreshInterval = null;
                }
            }

            // Fonction principale pour rafraîchir les données des tâches à venir
            async function refreshUpcomingTasks() {
                try {
                    console.log('🔄 Refreshing upcoming tasks data...');
                    upcomingTasksData.lastRefreshTime = Date.now();
                    
                    // Récupérer les données en parallèle avec gestion d'erreur
                    const [dashboardStatsResponse, accountsResponse, watchAccountsResponse] = await Promise.all([
                        fetch(`${API_BASE_URL}/api/dashboard-stats`).catch(e => ({ error: e.message })),
                        fetch(`${API_BASE_URL}/api/accounts`).catch(e => ({ error: e.message })),
                        fetch(`${API_BASE_URL}/api/watch-accounts`).catch(e => ({ error: e.message }))
                    ]);

                    // Parser les réponses avec gestion d'erreur
                    const dashboardStats = dashboardStatsResponse.error ? {} : await dashboardStatsResponse.json().catch(() => ({}));
                    const accounts = accountsResponse.error ? [] : await accountsResponse.json().catch(() => []);
                    const watchAccountsRaw = watchAccountsResponse.error ? [] : await watchAccountsResponse.json().catch(() => []);

                    // Corriger le parsing de watchAccounts - l'API retourne {success, watchAccounts: []}
                    let watchAccounts = [];
                    if (Array.isArray(watchAccountsRaw)) {
                        // Si c'est déjà un tableau (ancien format)
                        watchAccounts = watchAccountsRaw;
                    } else if (watchAccountsRaw && watchAccountsRaw.watchAccounts && Array.isArray(watchAccountsRaw.watchAccounts)) {
                        // Si c'est un objet avec la propriété watchAccounts (nouveau format)
                        watchAccounts = watchAccountsRaw.watchAccounts;
                    } else {
                        console.warn('⚠️ Format inattendu pour watchAccounts:', watchAccountsRaw);
                        watchAccounts = [];
                    }

                    console.log('📊 Raw API data:', { dashboardStats, accounts, watchAccountsRaw, watchAccounts });

                    // Calculer les métriques avec validation
                    const activeAccounts = Array.isArray(accounts) ? accounts.filter(acc => acc.status === 'active' || acc.status === 'working') : [];
                    const totalQuotas = calculateRemainingQuotas(dashboardStats);
                    const watchAccountsCount = Array.isArray(watchAccounts) ? watchAccounts.length : 0;
                    
                    // Calculs sécurisés pour éviter NaN
                    const estimatedActions = Math.min(totalQuotas, watchAccountsCount * 3); // Estimation: 3 actions par compte surveillé
                    const estimatedTimeMinutes = Math.ceil(estimatedActions / 10); // Estimation: 10 actions par minute
                    
                    console.log('📊 Upcoming tasks metrics:', {
                        watchAccountsCount,
                        activeAccountsCount: activeAccounts.length,
                        totalQuotas,
                        estimatedActions,
                        estimatedTimeMinutes
                    });

                    // Mettre à jour les données avec validation
                    upcomingTasksData = {
                        ...upcomingTasksData,
                        tweetsFound: watchAccountsCount || 0,
                        actionsPlanned: estimatedActions || 0,
                        estimatedTime: estimatedTimeMinutes || 0,
                        quotasRemaining: totalQuotas || 0,
                        activeAccounts: activeAccounts || []
                    };

                    // Générer le plan d'action détaillé
                    generateDetailedActionPlan(watchAccounts, activeAccounts);

                    // Mettre à jour l'affichage
                    updateUpcomingTasksDisplay();

                } catch (error) {
                    console.error('❌ Error refreshing upcoming tasks:', error);
                    showUpcomingTasksError('Failed to load mission data');
                }
            }

            // Fonction pour calculer les quotas restants
            function calculateRemainingQuotas(dashboardStats) {
                try {
                    // Utiliser les données réelles du dashboard
                    const actionLog = dashboardStats.actionLog || { today: { total: 0 } };
                    const usedToday = actionLog.today.total || 0;
                    
                    // Essayer de récupérer les limites réelles depuis les comptes enrichis
                    let totalDailyLimit = 300; // Valeur par défaut
                    
                    // 🎯 CORRECTION : Utiliser les données du système unifié
                    const quotaInfo = dashboardStats.quotaInfo || {};
                    const allocation = quotaInfo.allocation || {};
                    const activeAccounts = allocation.activeAccounts || dashboardStats.activeAccounts || 0;
                    
                    if (activeAccounts > 0) {
                        // Calculer la limite totale basée sur les comptes actifs du système unifié
                        const dailyPerAccount = allocation.dailyPerAccount || 600;
                        totalDailyLimit = activeAccounts * dailyPerAccount;
                    }
                    
                    const remaining = Math.max(0, totalDailyLimit - usedToday);
                    console.log(`📊 Quotas calculation: ${usedToday}/${totalDailyLimit} used, ${remaining} remaining`);
                    
                    return remaining;
                } catch (error) {
                    console.warn('⚠️ Error calculating quotas:', error);
                    return 100; // Valeur par défaut
                }
            }

            // Fonction pour générer le plan d'action détaillé
            function generateDetailedActionPlan(watchAccounts, activeAccounts) {
                const actionPlan = [];
                
                if (!watchAccounts || watchAccounts.length === 0) {
                    actionPlan.push('⚠️ No target accounts configured for monitoring');
                    actionPlan.push('💡 Add target accounts in the "Token & Surveillance Settings" section');
                } else if (!activeAccounts || activeAccounts.length === 0) {
                    actionPlan.push('❌ No active raid accounts available');
                    actionPlan.push('💡 Connect raid accounts using the invitation link generator');
                } else {
                    actionPlan.push(`🎯 Monitoring ${watchAccounts.length} target account(s)`);
                    actionPlan.push(`👥 Using ${activeAccounts.length} active raid account(s)`);
                    
                    const actionsPerTarget = Math.ceil(activeAccounts.length / watchAccounts.length);
                    watchAccounts.slice(0, 3).forEach((target, index) => {
                        const pseudo = target.pseudo || target.username || target;
                        actionPlan.push(`   • @${pseudo}: ${actionsPerTarget} planned actions (like, retweet, reply)`);
                    });
                    
                    if (watchAccounts.length > 3) {
                        actionPlan.push(`   • ... and ${watchAccounts.length - 3} more targets`);
                    }
                    
                    actionPlan.push(`⏱️ Estimated completion: ${upcomingTasksData.estimatedTime} minutes`);
                    actionPlan.push(`📊 Quotas remaining: ${upcomingTasksData.quotasRemaining} actions`);
                }
                
                upcomingTasksData.actionPlan = actionPlan;
            }

            // Fonction pour mettre à jour l'affichage de la section
            function updateUpcomingTasksDisplay() {
                // Mettre à jour les métriques principales
                updateElementText('tweetsFound', upcomingTasksData.tweetsFound);
                updateElementText('actionsPlanned', upcomingTasksData.actionsPlanned);
                updateElementText('estimatedTime', `${upcomingTasksData.estimatedTime}m`);
                updateElementText('quotasRemaining', upcomingTasksData.quotasRemaining);

                // Mettre à jour le plan d'action détaillé
                const actionPlanList = document.getElementById('actionPlanList');
                if (actionPlanList) {
                    actionPlanList.innerHTML = upcomingTasksData.actionPlan
                        .map(line => `<div style="margin-bottom: 4px;">${line}</div>`)
                        .join('');
                }

                // Mettre à jour la liste des comptes actifs
                updateActiveAccountsDisplay();

                // Mettre à jour le countdown
                updateMissionCountdown();
            }

            // Fonction pour mettre à jour l'affichage des comptes actifs
            function updateActiveAccountsDisplay() {
                const activeAccountsList = document.getElementById('activeAccountsList');
                if (!activeAccountsList) return;

                if (upcomingTasksData.activeAccounts.length === 0) {
                    activeAccountsList.innerHTML = '<span style="color: #dc3545; font-style: italic;">No active accounts</span>';
                    return;
                }

                const accountsHTML = upcomingTasksData.activeAccounts.map(account => {
                    const isWorking = account.status === 'working';
                    const badgeClass = isWorking ? 'account-badge working' : 'account-badge';
                    const icon = isWorking ? '🚀' : '👤';
                    
                    return `<span class="${badgeClass}">${icon} @${account.username}</span>`;
                }).join('');

                activeAccountsList.innerHTML = accountsHTML;
            }

            // Fonction pour mettre à jour le countdown de mission
            function updateMissionCountdown() {
                const missionCountdown = document.getElementById('missionCountdown');
                if (!missionCountdown) return;

                // Calculer le temps jusqu'au prochain rafraîchissement
                const refreshInterval = 15; // 15 secondes
                const now = Date.now();
                const lastRefresh = upcomingTasksData.lastRefreshTime || now;
                const timeSinceLastRefresh = Math.floor((now - lastRefresh) / 1000);
                const timeUntilUpdate = Math.max(0, refreshInterval - timeSinceLastRefresh);
                
                if (timeUntilUpdate > 0) {
                    missionCountdown.textContent = `Next update in ${timeUntilUpdate}s`;
                }
            }

            // Variables pour le countdown
            let nextScanTime = null;
            let countdownInterval = null;
            
            // Cette fonction est supprimée car elle fait doublon avec updateAutomationStatus ligne 2653
            
            // Fonction pour démarrer le countdown
            function startAutomationCountdown(cycleDuration) {
                nextScanTime = Date.now() + cycleDuration;
                
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                }
                
                countdownInterval = setInterval(() => {
                    const now = Date.now();
                    const remaining = Math.max(0, nextScanTime - now);
                    
                    if (remaining === 0) {
                        // Redémarrer le cycle
                        nextScanTime = now + cycleDuration;
                    }
                    
                    // Mettre à jour le countdown
                    const minutes = Math.floor(remaining / 60000);
                    const seconds = Math.floor((remaining % 60000) / 1000);
                    document.getElementById('nextScanCountdown').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    // Mettre à jour la barre de progression
                    const progress = ((cycleDuration - remaining) / cycleDuration) * 100;
                    document.getElementById('automationProgressBar').style.width = `${progress}%`;
                }, 1000);
            }
            
            // Fonction pour arrêter le countdown
            function stopAutomationCountdown() {
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                nextScanTime = null;
            }

            // Fonction utilitaire pour mettre à jour le texte d'un élément
            function updateElementText(elementId, value) {
                const element = document.getElementById(elementId);
                if (element) {
                    // Validation et formatage de la valeur
                    let displayValue = value;
                    
                    // Vérifier si c'est un nombre et éviter NaN
                    if (typeof value === 'number') {
                        if (isNaN(value) || !isFinite(value)) {
                            displayValue = '0';
                        } else {
                            displayValue = value.toString();
                        }
                    } else if (value === null || value === undefined) {
                        displayValue = '0';
                    }
                    
                    element.textContent = displayValue;
                    
                    // Animation de mise à jour seulement si la valeur a changé
                    if (element.dataset.lastValue !== displayValue) {
                        element.dataset.lastValue = displayValue;
                        element.style.transform = 'scale(1.1)';
                        element.style.transition = 'transform 0.2s ease';
                        setTimeout(() => {
                            element.style.transform = 'scale(1)';
                        }, 200);
                    }
                }
            }

            // Fonction pour afficher une erreur dans la section
            function showUpcomingTasksError(message) {
                const actionPlanList = document.getElementById('actionPlanList');
                if (actionPlanList) {
                    actionPlanList.innerHTML = `<div style="color: #dc3545; font-style: italic;">❌ ${message}</div>`;
                }
            }

            // ========================================
            // SYSTÈME DE VALIDATION SÉCURISÉE DE L'AUTOMATION
            // ========================================
            
            // Variables globales pour la validation (utilise la variable globale déjà déclarée)
            // automationValidationState déjà déclaré ligne 3159 - suppression de la duplication
            
            // Variables pour la validation automatique
            let validationInterval = null;
            let lastValidationState = { accounts: false, token: false, watchlist: false };
            
            // SUPPRIMÉ - Fonction dupliquée
            
            // Démarrer la validation automatique régulière
            function startAutomaticValidation() {
                // Validation initiale
                performAutomationValidation();
                
                // Validation toutes les 10 secondes
                if (validationInterval) {
                    clearInterval(validationInterval);
                }
                
                validationInterval = setInterval(async () => {
                    await performAutomationValidation();
                }, 30000); // 30 secondes - unifié avec autres intervalles
                
                console.log('[AUTOMATION] Validation automatique démarrée (toutes les 10s)');
            }
            
            // Arrêter la validation automatique
            function stopAutomaticValidation() {
                if (validationInterval) {
                    clearInterval(validationInterval);
                    validationInterval = null;
                    console.log('[AUTOMATION] Validation automatique arrêtée');
                }
            }
            
            // Fonction de validation complète
            async function performAutomationValidation() {
                console.log('[AUTOMATION] Début de la validation complète');
                
                // Sauvegarder l'état précédent
                const previousState = { ...automationValidationState };
                
                // Réinitialiser l'état
                automationValidationState = {
                    accounts: false,
                    token: false,
                    watchlist: false
                };
                
                // 1. Vérifier les comptes connectés
                await validateConnectedAccounts();
                
                // 2. Vérifier les informations du token
                await validateTokenSettings();
                
                // 3. Vérifier la liste de surveillance
                await validateWatchlist();
                
                // Mettre à jour l'affichage
                updateValidationDisplay();
                
                // Vérifier si tous les critères sont remplis
                const allValid = automationValidationState.accounts && 
                                automationValidationState.token && 
                                automationValidationState.watchlist;
                
                console.log('[AUTOMATION] Résultat final de validation:', {
                    accounts: automationValidationState.accounts,
                    token: automationValidationState.token,
                    watchlist: automationValidationState.watchlist,
                    allValid
                });
                
                // Vérifier si l'état a changé pour éviter les mises à jour inutiles
                const stateChanged = 
                    previousState.accounts !== automationValidationState.accounts ||
                    previousState.token !== automationValidationState.token ||
                    previousState.watchlist !== automationValidationState.watchlist;
                
                if (stateChanged) {
                    console.log('[AUTOMATION] État de validation changé, mise à jour de l\'interface');
                    
                    // Mettre à jour l'affichage
                    updateValidationDisplay();
                    
                    // CORRECTION : Ne synchroniser que si automation n'est PAS active
                    // Si automation active, ne pas écraser le bouton "Stop"
                    if (!globalAutomationState.isEnabled) {
                        await syncAutomationState();
                    }
                    
                    if (allValid) {
                        hideAutomationError();
                    } else {
                        showAutomationError();
                    }
                }
                
                return allValid;
            }
            
            // Validation des comptes connectés
            async function validateConnectedAccounts() {
                try {
                    console.log('[DEBUG] validateConnectedAccounts() DÉBUT');
                    console.log('[DEBUG] Appel API accounts...');
                    const response = await fetch(`${API_BASE_URL}/api/accounts`);
                    console.log('[DEBUG] Réponse API reçue:', response.status, response.ok);
                    
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('[DEBUG] Données API reçues:', data);
                    
                    // Vérifier le format des données et extraire les comptes
                    let connectedAccounts = [];
                    if (Array.isArray(data)) {
                        connectedAccounts = data;
                    } else if (data && Array.isArray(data.accounts)) {
                        connectedAccounts = data.accounts;
                    } else if (data && typeof data === 'object') {
                        // Si c'est un objet, essayer de l'utiliser directement comme tableau de comptes
                        connectedAccounts = data;
                    }
                    const totalConnectedAccounts = connectedAccounts.length;
                    const hasAccounts = totalConnectedAccounts > 0;
                    
                    console.log('[DEBUG] Calcul final des comptes:', {
                        connectedAccounts,
                        totalConnected: totalConnectedAccounts,
                        hasAccounts
                    });
                    
                    automationValidationState.accounts = hasAccounts;
                    
                    console.log('[AUTOMATION] Comptes connectés:', {
                        connectedAccounts,
                        totalConnected: totalConnectedAccounts,
                        hasAccounts
                    });
                    
                    updateValidationItem('accounts', hasAccounts, 
                        hasAccounts ? `${totalConnectedAccounts} account(s) connected` : 'No account connected');
                        
                } catch (error) {
                    console.error('[AUTOMATION] ERREUR CRITIQUE validation comptes:', error);
                    console.error('[AUTOMATION] Stack trace:', error.stack);
                    automationValidationState.accounts = false;
                    updateValidationItem('accounts', false, `Erreur API: ${error.message}`);
                }
                console.log('[DEBUG] validateConnectedAccounts() FIN');
            }
            
            // Validation des paramètres du token
            async function validateTokenSettings() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/token-settings`);
                    const data = await response.json();
                    
                    const hasValidToken = data.tokenSymbol && data.tokenName && data.tokenX && data.tokenChain;
                    automationValidationState.token = hasValidToken;
                    
                    console.log('[AUTOMATION] Token settings:', data);
                    
                    if (hasValidToken) {
                        updateValidationItem('token', true, `Token configured: ${data.tokenSymbol} (${data.tokenName})`);
                    } else {
                        const missing = [];
                        if (!data.tokenSymbol) missing.push('Symbol');
                        if (!data.tokenName) missing.push('Name');
                        if (!data.tokenX) missing.push('X');
                        if (!data.tokenChain) missing.push('Chain');
                        updateValidationItem('token', false, `Missing fields: ${missing.join(', ')}`);
                    }
                    
                } catch (error) {
                    console.error('[AUTOMATION] Error validating token:', error);
                    automationValidationState.token = false;
                    updateValidationItem('token', false, 'Error validating token');
                }
            }
            
            // Validation de la liste de surveillance
            async function validateWatchlist() {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/watch-accounts`);
                    const data = await response.json();
                    
                    const hasWatchAccounts = data.watchAccounts && data.watchAccounts.length > 0;
                    
                    console.log('[DEBUG] Données reçues:', {
                        hasWatchAccounts,
                        totalAccounts: data.watchAccounts?.length || 0,
                        firstAccount: data.watchAccounts?.[0] || null
                    });
                    
                    // Vérifier si les comptes sont enrichis (ont des données utilisateur)
                    let enrichedCount = 0;
                    if (hasWatchAccounts) {
                        // Un compte est valide s'il a un pseudo OU un username OU un nom valide
                        enrichedCount = data.watchAccounts.filter(acc => {
                            const hasPseudo = acc.pseudo && acc.pseudo.trim().length > 0;
                            const hasUsername = acc.username && acc.username.trim().length > 0;
                            const hasName = acc.name && acc.name.trim().length > 0;
                            return hasPseudo || hasUsername || hasName;
                        }).length;
                    }
                    
                    const isEnriched = enrichedCount > 0;
                    // Si on a des comptes surveillés, on considère que c'est valide même si pas tous sont "enrichis"
                    // Car avoir 29 comptes indique qu'ils ont été ajoutés correctement
                    const finalResult = hasWatchAccounts && (isEnriched || data.watchAccounts.length > 0);
                    
                    console.log('[DEBUG] Calculs de validation:', {
                        hasWatchAccounts,
                        enrichedCount,
                        isEnriched,
                        finalResult
                    });
                    
                    automationValidationState.watchlist = finalResult;
                    
                    console.log('[DEBUG] État après mise à jour:', automationValidationState);
                    console.log('[AUTOMATION] Watch accounts:', data.watchAccounts?.length || 0, 'enrichis:', enrichedCount);
                    
                    if (automationValidationState.watchlist) {
                        updateValidationItem('watchlist', true, `${data.watchAccounts.length} account(s) watched enriched`);
                    } else if (hasWatchAccounts && !isEnriched) {
                        updateValidationItem('watchlist', false, `${data.watchAccounts.length} account(s) added but not enriched`);
                    } else {
                        updateValidationItem('watchlist', false, 'No account to watch configured');
                    }
                    
                } catch (error) {
                    console.error('[AUTOMATION] Error validating watchlist:', error);
                    automationValidationState.watchlist = false;
                    updateValidationItem('watchlist', false, 'Error validating watchlist');
                }
            }
            
            // Update validation item in the interface
            function updateValidationItem(criterion, isValid, message) {
                const item = document.querySelector(`[data-criterion="${criterion}"]`);
                if (!item) return;
                
                const icon = item.querySelector('i');
                const text = item.querySelector('span');
                
                // Retirer les anciennes classes
                item.classList.remove('valid', 'invalid');
                
                if (isValid) {
                    item.classList.add('valid');
                    icon.className = 'fas fa-check-circle';
                    text.textContent = `✓ ${message}`;
                } else {
                    item.classList.add('invalid');
                    icon.className = 'fas fa-times-circle';
                    text.textContent = `✗ ${message}`;
                }
            }
            
            // Update global validation display
            function updateValidationDisplay() {
                const validationSection = document.getElementById('automationValidation');
                const allValid = automationValidationState.accounts && 
                                automationValidationState.token && 
                                automationValidationState.watchlist;
                
                if (allValid) {
                    validationSection.style.border = '2px solid #28a745';
                    validationSection.style.background = '#d4edda';
                    validationSection.querySelector('h4').style.color = '#155724';
                    validationSection.querySelector('h4 i').className = 'fas fa-shield-check';
                    validationSection.querySelector('h4').innerHTML = '<i class="fas fa-shield-check"></i> All Criteria Validated ✓';
                } else {
                    validationSection.style.border = '2px solid #ffc107';
                    validationSection.style.background = '#fff3cd';
                    validationSection.querySelector('h4').style.color = '#856404';
                    validationSection.querySelector('h4 i').className = 'fas fa-shield-alt';
                    validationSection.querySelector('h4').innerHTML = '<i class="fas fa-shield-alt"></i> Security Criteria Verification';
                }
            }
            
            // SUPPRIMÉ - Fonction dupliquée, remplacée par updateAutomationButtonFromGlobalState
            
            
            // Afficher l'erreur d'automation
            function showAutomationError() {
                const errorDiv = document.getElementById('automationError');
                const errorText = document.getElementById('automationErrorText');
                
                const errors = [];
                if (!automationValidationState.accounts) errors.push('No account connected');
                if (!automationValidationState.token) errors.push('Token information missing');
                if (!automationValidationState.watchlist) errors.push('Watchlist not configured');
                
                errorText.textContent = `Missing criteria: ${errors.join(', ')}`;
                errorDiv.style.display = 'block';
                
                // Masquer automatiquement après 5 secondes
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
            
            // Masquer l'erreur d'automation
            function hideAutomationError() {
                const errorDiv = document.getElementById('automationError');
                errorDiv.style.display = 'none';
            }
            
            // Initialisation du système de validation
            function initializeAutomationValidation() {
                console.log('[AUTOMATION] Initialisation du système de validation');
                
                // Effectuer une validation initiale
                performAutomationValidation();
                
                // Revalider toutes les 30 secondes (supprimé - déjà géré par l'intervalle unifié)
            }
            
            // ========================================
            // SYSTÈME D'ANALYTICS ET MÉTRIQUES D'ACTIONS
            // ========================================
            
            // Variables globales pour l'analytics
            window.analyticsData = {
                actions: {
                    likes: { total: 0, today: 0, thisHour: 0 },
                    retweets: { total: 0, today: 0, thisHour: 0 },
                    comments: { total: 0, today: 0, thisHour: 0 },
                    total: { total: 0, today: 0, thisHour: 0 }
                },
                lastUpdate: null
            };
            
            let analyticsAutoRefresh = true;
            let analyticsRefreshInterval = null;
            
            /**
             * Fonction principale pour actualiser les données analytics
             */
            async function refreshAnalytics() {
                try {
                    console.log('[ANALYTICS] Actualisation des données...');
                    
                    // Appeler l'API analytics pour récupérer les données
                    const response = await fetch(`${API_BASE_URL}/api/analytics/report/daily`);
                    const data = await response.json();
                    
                    if (data.success) {
                        // Mettre à jour les données locales
                        updateAnalyticsData(data.report);
                        
                        // Mettre à jour l'affichage
                        updateAnalyticsDisplay();
                        
                        console.log('[ANALYTICS] Données mises à jour avec succès');
                    } else {
                        console.error('[ANALYTICS] Erreur API:', data.error);
                        showAnalyticsError('Erreur lors de la récupération des données');
                    }
                } catch (error) {
                    console.error('[ANALYTICS] Erreur réseau:', error);
                    showAnalyticsError('Erreur de connexion au serveur');
                }
            }
            
            /**
             * Met à jour les données analytics locales
             */
            function updateAnalyticsData(reportData) {
                if (!reportData || !reportData.actions) {
                    console.warn('[ANALYTICS] Données de rapport invalides');
                    return;
                }
                
                const actions = reportData.actions;
                
                // Mettre à jour les données avec validation
                analyticsData.actions.likes.today = actions.likes?.today || 0;
                analyticsData.actions.likes.thisHour = actions.likes?.thisHour || 0;
                analyticsData.actions.likes.total = actions.likes?.total || 0;
                
                analyticsData.actions.retweets.today = actions.retweets?.today || 0;
                analyticsData.actions.retweets.thisHour = actions.retweets?.thisHour || 0;
                analyticsData.actions.retweets.total = actions.retweets?.total || 0;
                
                analyticsData.actions.comments.today = actions.comments?.today || 0;
                analyticsData.actions.comments.thisHour = actions.comments?.thisHour || 0;
                analyticsData.actions.comments.total = actions.comments?.total || 0;
                
                // Calculer les totaux
                analyticsData.actions.total.today = 
                    analyticsData.actions.likes.today + 
                    analyticsData.actions.retweets.today + 
                    analyticsData.actions.comments.today;
                    
                analyticsData.actions.total.thisHour = 
                    analyticsData.actions.likes.thisHour + 
                    analyticsData.actions.retweets.thisHour + 
                    analyticsData.actions.comments.thisHour;
                    
                analyticsData.actions.total.total = 
                    analyticsData.actions.likes.total + 
                    analyticsData.actions.retweets.total + 
                    analyticsData.actions.comments.total;
                
                analyticsData.lastUpdate = new Date().toISOString();
            }
            
            /**
             * Met à jour l'affichage des métriques dans l'interface
             */
            function updateAnalyticsDisplay() {
                // Vérifier que analyticsData est initialisé
                if (!window.analyticsData || !window.analyticsData.actions) {
                    console.warn('[ANALYTICS] analyticsData non initialisé');
                    return;
                }
                
                const analyticsData = window.analyticsData;
                
                // Likes
                updateElementText('analyticsLikesToday', analyticsData.actions.likes.today);
                updateElementText('analyticsLikesHour', analyticsData.actions.likes.thisHour);
                updateElementText('analyticsLikesTotal', analyticsData.actions.likes.total);
                
                // Retweets
                updateElementText('analyticsRetweetsToday', analyticsData.actions.retweets.today);
                updateElementText('analyticsRetweetsHour', analyticsData.actions.retweets.thisHour);
                updateElementText('analyticsRetweetsTotal', analyticsData.actions.retweets.total);
                
                // Comments
                updateElementText('analyticsCommentsToday', analyticsData.actions.comments.today);
                updateElementText('analyticsCommentsHour', analyticsData.actions.comments.thisHour);
                updateElementText('analyticsCommentsTotal', analyticsData.actions.comments.total);
                
                // Total
                updateElementText('analyticsTotalToday', analyticsData.actions.total.today);
                updateElementText('analyticsTotalHour', analyticsData.actions.total.thisHour);
                updateElementText('analyticsTotalTotal', analyticsData.actions.total.total);
                
                console.log('[ANALYTICS] Affichage mis à jour');
            }
            
            /**
             * Ouvre le détail des actions par type
             */
            async function openActionsDetail(actionType) {
                try {
                    console.log(`[ANALYTICS] Ouverture du détail pour: ${actionType}`);
                    
                    // Récupérer l'historique des actions
                    let apiUrl = `${API_BASE_URL}/api/actions-history?limit=200`;
                    
                    // Gérer les différents types d'actions
                    if (actionType === 'all-time' || actionType === 'all') {
                        // Pour 'all-time' ou 'all', récupérer toutes les actions sans filtre
                        // L'URL reste telle quelle (pas de paramètre actionType)
                    } else if (['like', 'retweet', 'reply'].includes(actionType)) {
                        // Pour les types d'actions spécifiques, ajouter le filtre
                        apiUrl += `&actionType=${actionType}`;
                    } else {
                        console.warn(`[ANALYTICS] Type d'action non reconnu: ${actionType}`);
                        // Traiter comme 'all' par défaut
                    }
                    
                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    
                    console.log('[ANALYTICS] Réponse API complète:', data);
                    console.log('[ANALYTICS] data.success:', data.success);
                    console.log('[ANALYTICS] data.history:', data.history);
                    console.log('[ANALYTICS] data.error:', data.error);
                    
                    if (data.success && (data.history || data.actions)) {
                        // Normaliser le type pour l'affichage
                        const displayType = actionType === 'all-time' ? 'all' : actionType;
                        const historyData = data.history || data.actions;
                        showActionsDetailModal(displayType, historyData);
                    } else {
                        console.error('[ANALYTICS] Erreur récupération historique:', data.error);
                        showAnalyticsError('Erreur lors de la récupération de l\'historique');
                    }
                } catch (error) {
                    console.error('[ANALYTICS] Erreur réseau historique:', error);
                    showAnalyticsError('Erreur de connexion pour l\'historique');
                }
            }
            
            /**
             * Affiche la modal avec le détail des actions
             */
            function showActionsDetailModal(actionType, history) {
                const actionTypeLabels = {
                    'like': '❤️ Likes',
                    'retweet': '🔄 Retweets', 
                    'reply': '💬 Replies',
                    'all': '📊 Toutes les Actions'
                };
                
                const title = actionTypeLabels[actionType] || '📊 Actions';
                
                // Créer la modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.7); z-index: 10000; display: flex; 
                    align-items: center; justify-content: center;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white; border-radius: 12px; padding: 25px; 
                    max-width: 800px; max-height: 80vh; overflow-y: auto; 
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                
                // Générer le contenu HTML
                let historyHTML = '';
                if (history.length === 0) {
                    historyHTML = '<div style="text-align: center; color: #666; padding: 20px;">Aucune action trouvée</div>';
                } else {
                    historyHTML = history.map(item => `
                        <div style="border-bottom: 1px solid #eee; padding: 12px 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <span style="font-weight: bold; color: #333;">
                                    ${getActionIcon(item.actionType)} ${item.actionType.toUpperCase()}
                                </span>
                                <span style="color: #666; font-size: 0.9em;">
                                    ${new Date(item.timestamp).toLocaleString('fr-FR')}
                                </span>
                            </div>
                            <div style="color: #28a745; font-weight: 500;">@${item.username}</div>
                            <div style="color: #666; font-size: 0.9em; margin-top: 5px;">${item.details}</div>
                        </div>
                    `).join('');
                }
                
                modalContent.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: #333;">${title} - Historique</h3>
                        <button onclick="this.closest('.modal-overlay').remove()" 
                                style="background: #dc3545; color: white; border: none; border-radius: 50%; 
                                       width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
                    </div>
                    <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                        <strong>Total: ${history.length} actions</strong>
                        ${actionType !== 'all' ? '' : `
                            <div style="margin-top: 8px; font-size: 0.9em; color: #666;">
                                Likes: ${history.filter(h => h.actionType === 'like').length} | 
                                Retweets: ${history.filter(h => h.actionType === 'retweet').length} | 
                                Replies: ${history.filter(h => h.actionType === 'reply').length}
                            </div>
                        `}
                    </div>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${historyHTML}
                    </div>
                `;
                
                modal.className = 'modal-overlay';
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Fermer en cliquant à l'extérieur
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }
            
            /**
             * Retourne l'icône pour un type d'action
             */
            function getActionIcon(actionType) {
                const icons = {
                    'like': '❤️',
                    'retweet': '🔄',
                    'reply': '💬'
                };
                return icons[actionType] || '📊';
            }
            
            /**
             * Basculer l'auto-refresh des analytics
             */
            function toggleAutoRefresh() {
                analyticsAutoRefresh = !analyticsAutoRefresh;
                const button = document.getElementById('autoRefreshToggle');
                const icon = button.querySelector('i');
                
                if (analyticsAutoRefresh) {
                    // Activer l'auto-refresh
                    button.innerHTML = '<i class="fas fa-pause"></i> Pause Auto-Refresh';
                    button.className = 'btn btn-warning btn-sm';
                    startAnalyticsAutoRefresh();
                    console.log('[ANALYTICS] Auto-refresh activé');
                } else {
                    // Désactiver l'auto-refresh
                    button.innerHTML = '<i class="fas fa-play"></i> Resume Auto-Refresh';
                    button.className = 'btn btn-success btn-sm';
                    stopAnalyticsAutoRefresh();
                    console.log('[ANALYTICS] Auto-refresh désactivé');
                }
            }
            
            /**
             * Démarre l'auto-refresh des analytics
             */
            function startAnalyticsAutoRefresh() {
                if (analyticsRefreshInterval) {
                    clearInterval(analyticsRefreshInterval);
                }
                
                // Refresh toutes les 30 secondes
                analyticsRefreshInterval = setInterval(() => {
                    if (analyticsAutoRefresh) {
                        refreshAnalytics();
                    }
                }, 30000);
            }
            
            /**
             * Arrête l'auto-refresh des analytics
             */
            function stopAnalyticsAutoRefresh() {
                if (analyticsRefreshInterval) {
                    clearInterval(analyticsRefreshInterval);
                    analyticsRefreshInterval = null;
                }
            }
            
            /**
             * Affiche une erreur analytics
             */
            function showAnalyticsError(message) {
                console.error('[ANALYTICS] Erreur:', message);
                
                // Créer une notification temporaire
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed; top: 20px; right: 20px; background: #dc3545; 
                    color: white; padding: 15px 20px; border-radius: 8px; 
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 9999;
                    font-weight: 500; max-width: 300px;
                `;
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>${message}</span>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Supprimer après 5 secondes
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 5000);
            }
            
            /**
             * Ouvre l'historique des actions pour un utilisateur spécifique
             */
            async function openUserActionsHistory(username, actionType = null) {
                try {
                    console.log(`[ANALYTICS] Ouverture historique utilisateur: ${username}, type: ${actionType || 'all'}`);
                    
                    // Construire l'URL de l'API avec les filtres
                    let apiUrl = `${API_BASE_URL}/api/actions-history?limit=200&accountId=${encodeURIComponent(username)}`;
                    if (actionType) {
                        apiUrl += `&actionType=${actionType}`;
                    }
                    
                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    
                    console.log(`[ANALYTICS] URL appelée: ${apiUrl}`);
                    console.log('[ANALYTICS] Réponse API utilisateur complète:', data);
                    console.log('[ANALYTICS] data.success:', data.success);
                    console.log('[ANALYTICS] data.history:', data.history);
                    console.log('[ANALYTICS] data.error:', data.error);
                    
                    if (data.success && (data.history || data.actions)) {
                        const historyData = data.history || data.actions;
                        showUserActionsDetailModal(username, actionType, historyData);
                    } else {
                        console.error('[ANALYTICS] Erreur récupération historique utilisateur:', data.error);
                        showAnalyticsError(`Erreur lors de la récupération de l'historique de @${username}`);
                    }
                } catch (error) {
                    console.error('[ANALYTICS] Erreur réseau historique utilisateur:', error);
                    showAnalyticsError(`Erreur de connexion pour l'historique de @${username}`);
                }
            }
            
            /**
             * Affiche la modal avec l'historique des actions d'un utilisateur
             */
            function showUserActionsDetailModal(username, actionType, history) {
                const actionTypeLabels = {
                    'like': '❤️ Likes',
                    'retweet': '🔄 Retweets', 
                    'reply': '💬 Replies'
                };
                
                // FILTRAGE PRÉCIS : Si un type d'action est spécifié, filtrer uniquement ces actions
                let filteredHistory = history;
                if (actionType && actionType !== 'all') {
                    filteredHistory = history.filter(item => item.actionType === actionType);
                    console.log(`[ANALYTICS] Filtrage pour ${actionType}: ${filteredHistory.length}/${history.length} actions`);
                }
                
                const typeLabel = actionType ? actionTypeLabels[actionType] : '📊 Toutes les Actions';
                const title = `@${username} - ${typeLabel}`;
                
                // Créer la modal
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.7); z-index: 10000; display: flex; 
                    align-items: center; justify-content: center;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white; border-radius: 12px; padding: 25px; 
                    max-width: 1000px; max-height: 85vh; overflow-y: auto; 
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                
                // Générer le contenu HTML enrichi
                let historyHTML = '';
                if (filteredHistory.length === 0) {
                    historyHTML = `
                        <div style="text-align: center; color: #666; padding: 40px;">
                            <i class="fas fa-inbox" style="font-size: 3em; margin-bottom: 15px; opacity: 0.5;"></i>
                            <div style="font-size: 1.1em;">Aucune action ${actionType ? actionTypeLabels[actionType] : ''} trouvée pour @${username}</div>
                            ${actionType ? `<div style="font-size: 0.9em; margin-top: 5px; color: #999;">Essayez de cliquer sur "Historique" pour voir toutes les actions</div>` : ''}
                        </div>
                    `;
                } else {
                    historyHTML = filteredHistory.map(item => {
                        // Construire le lien vers le tweet
                        const tweetUrl = item.tweetId ? `https://twitter.com/i/status/${item.tweetId}` : null;
                        const targetUserDisplay = item.targetUser ? `@${item.targetUser}` : 'Utilisateur inconnu';
                        
                        // Extraire le texte du tweet (limité à 100 caractères)
                        let tweetPreview = '';
                        if (item.tweetText) {
                            tweetPreview = item.tweetText.length > 100 
                                ? item.tweetText.substring(0, 100) + '...' 
                                : item.tweetText;
                        }
                        
                        // Couleur selon le type d'action
                        const actionColors = {
                            'like': '#e53e3e',
                            'retweet': '#38a169', 
                            'reply': '#d69e2e'
                        };
                        const actionColor = actionColors[item.actionType] || '#6c757d';
                        
                        return `
                            <div style="border: 1px solid #e9ecef; border-radius: 10px; padding: 18px; margin-bottom: 15px; background: #fafafa;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                    <div style="display: flex; align-items: center; gap: 12px;">
                                        <span style="font-weight: bold; color: white; background: ${actionColor}; padding: 6px 12px; border-radius: 20px; font-size: 0.85em;">
                                            ${getActionIcon(item.actionType)} ${item.actionType.toUpperCase()}
                                        </span>
                                        <span style="color: #1da1f2; font-weight: 600; font-size: 1.05em;">@${item.username}</span>
                                        <i class="fas fa-arrow-right" style="color: #ccc;"></i>
                                        <span style="color: #17a2b8; font-weight: 500;">${targetUserDisplay}</span>
                                    </div>
                                    <span style="color: #666; font-size: 0.85em;">
                                        ${getTimeAgo(new Date(item.timestamp))}
                                    </span>
                                </div>
                                
                                ${tweetPreview ? `
                                    <div style="background: white; border-left: 4px solid ${actionColor}; padding: 12px; margin: 10px 0; border-radius: 6px; font-style: italic; color: #555;">
                                        "${tweetPreview}"
                                    </div>
                                ` : ''}
                                
                                ${item.replyText ? `
                                    <div style="background: #e8f5e8; border-left: 4px solid #28a745; padding: 12px; margin: 10px 0; border-radius: 6px;">
                                        <strong>💬 Réponse générée:</strong><br>
                                        <em>"${item.replyText}"</em>
                                    </div>
                                ` : ''}
                                
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px; padding-top: 10px; border-top: 1px solid #eee;">
                                    <div style="font-size: 0.8em; color: #666;">
                                        <i class="fas fa-clock" style="margin-right: 5px;"></i>
                                        ${new Date(item.timestamp).toLocaleString('fr-FR')}
                                    </div>
                                    ${tweetUrl ? `
                                        <a href="${tweetUrl}" target="_blank" 
                                           style="background: #1da1f2; color: white; text-decoration: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8em; transition: all 0.3s;"
                                           onmouseover="this.style.background='#1991db'" 
                                           onmouseout="this.style.background='#1da1f2'">
                                            <i class="fas fa-external-link-alt" style="margin-right: 5px;"></i>
                                            Voir le Tweet
                                        </a>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                }
                
                // Calculer les statistiques
                const stats = {
                    total: filteredHistory.length,
                    totalAll: history.length,
                    likes: history.filter(h => h.actionType === 'like').length,
                    retweets: history.filter(h => h.actionType === 'retweet').length,
                    replies: history.filter(h => h.actionType === 'reply').length
                };
                
                modalContent.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #f8f9fa;">
                        <div>
                            <h3 style="margin: 0; color: #333;">${title}</h3>
                            <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                                ${actionType && actionType !== 'all' ? 
                                    `Affichage filtré: ${stats.total} ${typeLabel} sur ${stats.totalAll} actions totales` : 
                                    `Historique complet des actions (${stats.total} actions)`
                                }
                            </div>
                        </div>
                        <button onclick="this.closest('.modal-overlay').remove()" 
                                style="background: #dc3545; color: white; border: none; border-radius: 50%; 
                                       width: 35px; height: 35px; cursor: pointer; font-size: 18px; font-weight: bold;">×</button>
                    </div>
                    
                    ${actionType && actionType !== 'all' ? `
                        <div style="background: #e8f4f8; border: 1px solid #bee5eb; border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 8px; color: #0c5460;">
                                <i class="fas fa-filter"></i>
                                <strong>Filtre actif:</strong> Affichage uniquement des ${typeLabel} de @${username}
                                <button onclick="openUserActionsHistory('${username}')" 
                                        style="background: #17a2b8; color: white; border: none; border-radius: 4px; padding: 4px 8px; margin-left: auto; cursor: pointer; font-size: 0.8em;">
                                    Voir toutes les actions
                                </button>
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 10px; border: 2px solid ${actionType && actionType !== 'all' ? '#17a2b8' : '#dee2e6'};">
                            <div style="font-size: 1.8em; font-weight: bold; color: #495057;">${stats.total}</div>
                            <div style="font-size: 0.85em; color: #6c757d; font-weight: 600;">${actionType && actionType !== 'all' ? typeLabel : '📊 Total'}</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #fff5f5, #fed7d7); border-radius: 10px;">
                            <div style="font-size: 1.8em; font-weight: bold; color: #e53e3e;">${stats.likes}</div>
                            <div style="font-size: 0.85em; color: #6c757d; font-weight: 600;">❤️ Likes</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #f0fff4, #c6f6d5); border-radius: 10px;">
                            <div style="font-size: 1.8em; font-weight: bold; color: #38a169;">${stats.retweets}</div>
                            <div style="font-size: 0.8em; color: #6c757d;">🔄 Retweets</div>
                        </div>
                        <div style="text-align: center; padding: 12px; background: linear-gradient(135deg, #fffaf0, #feebc8); border-radius: 8px;">
                            <div style="font-size: 1.5em; font-weight: bold; color: #d69e2e;">${stats.replies}</div>
                            <div style="font-size: 0.8em; color: #6c757d;">💬 Replies</div>
                        </div>
                    </div>
                    
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px;">
                        ${historyHTML}
                    </div>
                    
                    <div style="margin-top: 15px; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 0.9em; color: #6c757d;">
                        💡 Cliquez sur les différents types d'actions dans les cards pour filtrer l'historique
                    </div>
                `;
                
                modal.className = 'modal-overlay';
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Fermer en cliquant à l'extérieur
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }
            
            /**
             * Initialise le système d'analytics
             */
            function initializeAnalytics() {
                console.log('[ANALYTICS] Initialisation du système d\'analytics');
                
                // Charger les données initiales
                refreshAnalytics();
                
                // Démarrer l'auto-refresh
                if (analyticsAutoRefresh) {
                    startAnalyticsAutoRefresh();
                }
            }

            // --- Exposition globale pour compatibilité UI ---
            window.validateAndToggleAutomation = validateAndToggleAutomation;
            window.performAutomationValidation = performAutomationValidation;
            window.refreshDashboard = refreshDashboard;
            window.addWatchAccount = addWatchAccount;
            window.removeWatchAccount = removeWatchAccount;
            window.loadQuotasSettings = loadQuotasSettings;
            window.saveQuotasSettings = saveQuotasSettings;
            window.generateInvitationToken = generateInvitationToken;
            window.openActionsDetail = openActionsDetail;
            window.openUserActionsHistory = openUserActionsHistory;
            window.refreshAnalytics = refreshAnalytics;
            window.toggleAutoRefresh = toggleAutoRefresh;
            window.saveSchedulerConfig = saveSchedulerConfig;
            window.forceAnalyzePatterns = forceAnalyzePatterns;
            window.loadSchedulerStats = loadSchedulerStats;
            window.toggleQuickStartGuide = toggleQuickStartGuide;
            window.refreshAutomationQueue = refreshAutomationQueue;
            // window.switchQueueTab = switchQueueTab; // Fonction définie plus bas
            
            // --- Initialisation du thème ---
            initializeTheme();
            console.log('[THEME] Theme system initialized');
            
            // --- Initialisation du Quick Start Guide ---
            initializeQuickStartGuide();
            console.log('[QUICK START] Quick Start Guide initialized');
            
            // --- Initialisation de la validation de l'automation ---
            initializeAutomationValidation();
            console.log('[AUTOMATION] Validation system initialized');
            
            // --- Initialisation du système d'analytics ---
            initializeAnalytics();
            console.log('[ANALYTICS] Analytics system initialized');
            
            // --- Initialisation de la file d'attente ---
            initializeAutomationQueue();
            console.log('[QUEUE] Automation queue system initialized');

        }); // Fermeture de document.addEventListener('DOMContentLoaded', ...)
        
        // ===== GESTION DE LA FILE D'ATTENTE D'ACTIONS =====
        
        // Fonction utilitaire pour afficher le temps relatif
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffSeconds = Math.floor(diffMs / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffSeconds < 60) {
                return 'à l\'instant';
            } else if (diffMinutes < 60) {
                return `il y a ${diffMinutes} min`;
            } else if (diffHours < 24) {
                return `il y a ${diffHours}h`;
            } else {
                return `il y a ${diffDays}j`;
            }
        }
        
        let queueRefreshInterval = null;
        let queueData = null;
        
        function initializeAutomationQueue() {
            refreshAutomationQueue();
            // Auto-refresh toutes les 30 secondes
            queueRefreshInterval = setInterval(refreshAutomationQueue, 30000);
        }
        
        async function refreshAutomationQueue() {
            try {
                const refreshIcon = document.getElementById('queueRefreshIcon');
                if (refreshIcon) {
                    refreshIcon.style.animation = 'spin 1s linear infinite';
                }
                
                const response = await fetch('/api/automation-queue');
                const result = await response.json();
                
                if (result.success) {
                    queueData = result.data;
                    updateAutomationStatusDisplay(queueData);
                    // Mise à jour du timestamp de dernière actualisation
                    const lastUpdateElement = document.getElementById('queueLastUpdate');
                    if (lastUpdateElement) {
                        lastUpdateElement.textContent = new Date().toLocaleTimeString('fr-FR');
                    }
                } else {
                    console.error('[QUEUE] Erreur API:', result.error);
                    showQueueError(result.error);
                }
            } catch (error) {
                console.error('[QUEUE] Erreur de connexion:', error);
                showQueueError('Erreur de connexion au serveur');
            } finally {
                const refreshIcon = document.getElementById('queueRefreshIcon');
                if (refreshIcon) {
                    refreshIcon.style.animation = '';
                }
            }
        // Fonction pour afficher des notifications discrètes
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107',
                info: '#17a2b8'
            };
            
            notification.style.backgroundColor = colors[type] || colors.info;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animation d'entrée
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Suppression automatique
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[INIT] Page chargée, initialisation...');
            
            // Charger les données initiales
            loadAutomationStatus();
            refreshDashboard();
            loadAccounts();
            loadRecentActivity();
            initializeUI();Index();
            loadTokenSettings();
            
            // Démarrer la validation automatique
            startAutomaticValidation();
            
            // Démarrer le rafraîchissement de l'activité récente
            setInterval(loadRecentActivity, 30000); // Toutes les 30 secondes
            
            // Démarrer les mises à jour périodiques
            setInterval(refreshDashboard, 60000); // Toutes les minutes
            
            console.log('[INIT] Initialisation terminée');
        });
        function getDashboardActionIcon(actionType) {
            const icons = {
                'like': 'heart',
                'retweet': 'retweet',
                'reply': 'reply',
                'follow': 'user-plus'
            };
            return icons[actionType] || 'bolt';
        }
        
        function getDashboardActionText(actionType) {
            const texts = {
                'like': 'Liked',
                'retweet': 'Retweeted',
                'reply': 'Replied',
                'follow': 'Followed'
            };
            return texts[actionType] || 'Action';
        }
        
        function formatTimeAgo(timestamp) {
            const now = new Date();
            const actionTime = new Date(timestamp);
            const diffMs = now - actionTime;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            
            if (diffMins < 1) return 'À l\'instant';
            if (diffMins < 60) return `Il y a ${diffMins}min`;
            if (diffHours < 24) return `Il y a ${diffHours}h`;
            return actionTime.toLocaleDateString('fr-FR');
        }
        
        function updateAutomationStatusDisplay(queueData) {
            const statusIndicator = document.getElementById('automationStatusIndicator');
            const statusText = document.getElementById('automationStatusText');
            const statusDetail = document.getElementById('automationStatusDetail');
            const nextScanCountdown = document.getElementById('nextScanCountdown');
            
            // Vérifier que queueData existe avant d'y accéder
            if (!queueData || !queueData.automationStatus) {
                if (statusIndicator) statusIndicator.style.background = '#6c757d';
                if (statusText) statusText.textContent = 'Chargement...';
                if (statusDetail) statusDetail.textContent = 'Récupération des données en cours';
                if (nextScanCountdown) nextScanCountdown.textContent = '--:--';
                return;
            }
            
            if (queueData.automationStatus.isEnabled) {
                if (queueData.automationStatus.isScanning) {
                    statusIndicator.style.background = '#ffc107';
                    statusText.textContent = 'Scan in progress...';
                    statusDetail.textContent = 'Searching for new tweets';
                } else {
                    statusIndicator.style.background = '#28a745';
                    statusText.textContent = 'Automation Active';
                    statusDetail.textContent = `Last scan: ${getTimeAgo(new Date(queueData.automationStatus.lastScanTime))}`;
                }
            } else {
                statusIndicator.style.background = '#dc3545';
                statusText.textContent = 'Automation Disabled';
                statusDetail.textContent = 'No scheduled actions';
            }
            
            // Countdown pour le prochain scan
            if (queueData.automationStatus.nextScanEstimate) {
                const timeLeft = queueData.automationStatus.nextScanEstimate - Date.now();
                if (timeLeft > 0) {
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000);
                    nextScanCountdown.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    nextScanCountdown.className = 'countdown-timer';
                } else {
                    nextScanCountdown.textContent = 'Imminent';
                }
            }
        }
        
        function updateQueueSummary() {
            if (!queueData || !queueData.summary) {
                document.getElementById('queueActiveAccounts').textContent = '--';
                document.getElementById('queuePausedAccounts').textContent = '--';
                document.getElementById('queueTweetsToProcess').textContent = '--';
                document.getElementById('queuePlannedActions').textContent = '--';
                return;
            }
            
            document.getElementById('queueActiveAccounts').textContent = queueData.summary.activeAccounts;
            document.getElementById('queuePausedAccounts').textContent = queueData.summary.pausedAccounts;
            document.getElementById('queueTweetsToProcess').textContent = queueData.summary.tweetsToProcess;
            document.getElementById('queuePlannedActions').textContent = queueData.summary.totalPlannedActions;
        }
        
        function updateQueueTabsContent() {
            if (!queueData) {
                showQueueError('Données non disponibles');
                return;
            }
            
            // Onglet comptes
            updateAccountsTab();
            // Onglet tweets
            updateTweetsTab();
            // Onglet actions
            updateActionsTab();
        }
        
        function updateAccountsTab() {
            const accountsList = document.getElementById('accountsStatusList');
            
            if (!queueData || !queueData.accountsStatus || !queueData.accountsStatus.length) {
                accountsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--medium-gray);">
                        <i class="fas fa-user-slash" style="font-size: 2em; margin-bottom: 15px;"></i><br>
                        No account connected
                    </div>
                `;
                return;
            }
            
            accountsList.innerHTML = queueData.accountsStatus.map(account => {
                // Sécuriser l'accès aux propriétés
                const status = account.status || 'unknown';
                const statusClass = status === 'active' ? 'active' : (status === 'rate_limited' ? 'error' : 'paused');
                const statusIcon = status === 'active' ? '✅' : (status === 'rate_limited' ? '❌' : '⏸️');
                const statusText = status === 'active' ? 'Actif' : (status === 'rate_limited' ? 'Rate Limited' : 'En Pause');
                
                let pauseInfo = '';
                if (account.pauseEndTime && account.pauseEndTime > Date.now()) {
                    const timeLeft = account.pauseEndTime - Date.now();
                    const minutes = Math.floor(timeLeft / 60000);
                    pauseInfo = `
                        <div style="margin-top: 8px; font-size: 0.85em; color: #666;">
                            <i class="fas fa-clock"></i> Réactivation dans ${minutes} minutes
                            ${account.pauseReason ? `<br><em>${account.pauseReason}</em>` : ''}
                        </div>
                    `;
                }
                
                return `
                    <div class="account-status-card ${statusClass}">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600; color: var(--dark-gray); margin-bottom: 5px;">
                                    ${statusIcon} ${account.username || '@compte_inconnu'}
                                </div>
                                <div style="font-size: 0.85em; color: var(--medium-gray);">
                                    ${statusText} • ${(account.authMethod || 'oauth1a').toUpperCase()}
                                    ${(account.errorCount || 0) > 0 ? ` • ${account.errorCount} erreurs` : ''}
                                </div>
                                ${pauseInfo}
                            </div>
                            <div style="text-align: right;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: ${statusClass === 'active' ? '#28a745' : (statusClass === 'error' ? '#dc3545' : '#ffc107')};"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateTweetsTab() {
            const tweetsList = document.getElementById('detectedTweetsList');
            
            if (!queueData || !queueData.detectedTweets || !queueData.detectedTweets.length) {
                tweetsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--medium-gray);">
                        <i class="fas fa-search" style="font-size: 2em; margin-bottom: 15px;"></i><br>
                        No new tweet detected
                    </div>
                `;
                return;
            }
            
            tweetsList.innerHTML = queueData.detectedTweets.map(tweet => `
                <div style="border: 1px solid #e9ecef; border-radius: 10px; padding: 15px; margin-bottom: 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 600; color: #1da1f2; margin-bottom: 5px;">
                                🐦 ${tweet.content || 'Tweet détecté'}
                            </div>
                            <div style="font-size: 0.85em; color: var(--medium-gray);">
                                Source: ${tweet.source || 'automation_scan'} • Par ${tweet.author || '@unknown'}
                            </div>
                        </div>
                        <div style="text-align: right; font-size: 0.8em; color: var(--medium-gray);">
                            ${getTimeAgo(new Date(tweet.timestamp))}
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function updateActionsTab() {
            const actionsList = document.getElementById('plannedActionsList');
            
            if (!queueData || !queueData.plannedActions || !queueData.plannedActions.length) {
                actionsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--medium-gray);">
                        <i class="fas fa-calendar-times" style="font-size: 2em; margin-bottom: 15px;"></i><br>
                        No action planned
                    </div>
                `;
                return;
            }
            
            // Filtrer les actions terminées et afficher seulement les actions à venir
            const pendingActions = queueData.plannedActions.filter(action => {
                const scheduledTime = new Date(action.scheduledTime || Date.now());
                const timeUntil = scheduledTime.getTime() - Date.now();
                // Masquer les actions passées ou terminées
                return timeUntil > -300000 && action.status !== 'completed' && action.status !== 'failed';
            });
            
            if (pendingActions.length === 0) {
                actionsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--medium-gray);">
                        <i class="fas fa-check-circle" style="font-size: 2em; margin-bottom: 15px; color: #28a745;"></i><br>
                        Toutes les actions ont été exécutées !<br>
                        <small>De nouvelles actions seront planifiées lors du prochain scan</small>
                    </div>
                `;
                return;
            }
            
            actionsList.innerHTML = pendingActions.map(action => {
                const actionIcons = { 'like': '❤️', 'retweet': '🔄', 'reply': '💬' };
                const actionColors = { 'like': '#e53e3e', 'retweet': '#28a745', 'reply': '#ffc107' };
                const priorityColors = { 'high': '#dc3545', 'normal': '#17a2b8', 'low': '#6c757d' };
                const statusColors = { 'pending': '#17a2b8', 'processing': '#ffc107', 'completed': '#28a745', 'failed': '#dc3545' };
                
                const scheduledTime = new Date(action.scheduledTime || Date.now());
                const timeUntil = scheduledTime.getTime() - Date.now();
                const hours = Math.floor(timeUntil / 3600000);
                const minutes = Math.floor((timeUntil % 3600000) / 60000);
                
                let timeText = 'Imminent';
                if (timeUntil > 3600000) {
                    timeText = `Dans ${hours}h ${minutes}min`;
                } else if (timeUntil > 60000) {
                    timeText = `Dans ${minutes} min`;
                } else if (timeUntil > 0) {
                    timeText = 'Imminent';
                } else if (action.status === 'processing') {
                    timeText = 'En cours...';
                } else {
                    timeText = 'Prêt';
                }
                
                const statusText = action.status === 'processing' ? '⏳ En cours' : '⏸️ Planifiée';
                const priorityText = action.priority === 'high' ? '🔥 Urgent' : 
                                   action.priority === 'low' ? '🔽 Faible' : '📋 Normal';
                
                return `
                    <div style="border: 1px solid #e9ecef; border-radius: 10px; padding: 15px; margin-bottom: 10px; background: white; border-left: 4px solid ${actionColors[action.type]}; ${action.status === 'processing' ? 'animation: pulse 2s infinite;' : ''}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.2em;">${actionIcons[action.type]}</span>
                                <span style="font-weight: 600; color: ${actionColors[action.type]};">
                                    ${action.type.toUpperCase()}
                                </span>
                                <span style="color: #1da1f2;">${action.accountUsername || '@compte_inconnu'}</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.75em; color: ${priorityColors[action.priority || 'normal']}; font-weight: 600;">
                                    ${priorityText}
                                </div>
                                <div style="font-size: 0.8em; color: ${statusColors[action.status || 'pending']}; margin-top: 2px;">
                                    ${statusText}
                                </div>
                            </div>
                        </div>
                        <div style="font-size: 0.85em; color: var(--medium-gray); text-align: right;">
                            ${timeText}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function switchQueueTab(tabName) {
            // Mettre à jour les onglets
            document.querySelectorAll('.queue-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            // Mettre à jour le contenu
            document.querySelectorAll('.queue-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`queue${tabName.charAt(0).toUpperCase() + tabName.slice(1)}Tab`).style.display = 'block';
        }
        
        // Exposer la fonction à l'objet window après sa définition
        window.switchQueueTab = switchQueueTab;
        
        // Fonction pour faire défiler vers une section avec effet visuel
        function scrollToSection(sectionId) {
            console.log('scrollToSection appelée avec:', sectionId);
            const element = document.getElementById(sectionId);
            console.log('Élément trouvé:', element);
            if (element) {
                // Scroll vers la section
                element.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
                
                // Effet visuel temporaire pour attirer l'attention
                element.style.transition = 'all 0.3s ease';
                element.style.transform = 'scale(1.02)';
                element.style.boxShadow = '0 8px 25px rgba(29, 161, 242, 0.3)';
                
                // Retour à la normale après 1 seconde
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                    element.style.boxShadow = '';
                }, 1000);
            } else {
                console.error('Élément non trouvé avec ID:', sectionId);
            }
        }
        
        // Exposer scrollToSection globalement
        window.scrollToSection = scrollToSection;
        
        
        function showQueueError(message) {
            // Afficher une erreur dans tous les onglets
            const errorHtml = `
                <div style="text-align: center; padding: 40px; color: #dc3545;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 2em; margin-bottom: 15px;"></i><br>
                    ${message}
                </div>
            `;
            
            const accountsList = document.getElementById('accountsStatusList');
            const tweetsList = document.getElementById('detectedTweetsList');
            const actionsList = document.getElementById('plannedActionsList');
            
            if (accountsList) accountsList.innerHTML = errorHtml;
            if (tweetsList) tweetsList.innerHTML = errorHtml;
            if (actionsList) actionsList.innerHTML = errorHtml;
        }
    }

    // --- LOGIQUE POUR LES CARTES DE STATISTIQUES ---
    async function loadStatsCards() {
        try {
            const overviewRes = await fetch(`${API_BASE_URL}/api/dashboard/overview`);
            const recentRes = await fetch(`${API_BASE_URL}/api/dashboard/recent-activity`);

            const overview = await overviewRes.json();
            const recent = await recentRes.json();

            if (overview.success) {
                updateActionsTotal(overview.data.actions);
            }
            if (recent.success) {
                updateRecentActivity(recent.data);
            }
        } catch (error) {
            console.error('Erreur lors du chargement des statistiques pour index.html:', error);
            const recentList = document.getElementById('recent-activity-list');
            if(recentList) recentList.innerHTML = '<div class="loading">Erreur de chargement.</div>';
        }
    }

    function updateActionsTotal(actions) {
        if (!actions || !actions.byType) return;
        document.getElementById('actions-total-count').textContent = actions.total.toLocaleString();
        document.getElementById('actions-total-likes').textContent = actions.byType.like.toLocaleString();
        document.getElementById('actions-total-replies').textContent = actions.byType.reply.toLocaleString();
        document.getElementById('actions-total-retweets').textContent = actions.byType.retweet.toLocaleString();
    }

    function updateRecentActivity(recentActions) {
        const recentList = document.getElementById('recent-activity-list');
        if (!recentList) return;

        if (!recentActions || recentActions.length === 0) {
            recentList.innerHTML = '<div class="loading">Aucune activité récente</div>';
            return;
        }

        recentList.innerHTML = recentActions.slice(0, 5).map(action => `
            <div class="activity-item">
                <div class="activity-icon activity-${action.actionType}">
                    <i class="fas fa-${getActionIcon(action.actionType)}"></i>
                </div>
                <div class="activity-details">
                    <div class="activity-user">@${action.username}</div>
                    <div class="activity-action">${getActionText(action.actionType)}</div>
                </div>
                <div class="activity-time">${action.timeAgo}</div>
                <div class="activity-link">
                    <a href="https://twitter.com/i/status/${action.tweetId}" target="_blank" class="tweet-link-btn">
                        <i class="fab fa-twitter"></i>
                    </a>
                </div>
            </div>
        `).join('');
    }

    function getActionIcon(actionType) {
        const icons = { like: 'heart', reply: 'reply', retweet: 'retweet' };
        return icons[actionType] || 'circle';
    }

    function getActionText(actionType) {
        const texts = { like: 'Liked', reply: 'Replied', retweet: 'Retweeted' };
        return texts[actionType] || 'Action';
    }

    // --- LOGIQUE POUR LA CARTE QUOTAS GLOBAUX ---
    async function loadQuotasOverview() {
        try {
            const res = await fetch(`${API_BASE_URL}/api/dashboard/overview`);
            const data = await res.json();

            if (data.success && data.data.quotas) {
                updateQuotas(data.data.quotas);
            }
        } catch (error) {
            console.error('Error loading quotas:', error);
        }
    }

    function updateQuotas(quotas) {
        const global = quotas.global;
        
        document.getElementById('global-total').textContent = global.total.toLocaleString();
        document.getElementById('global-used').textContent = global.used.toLocaleString();
        document.getElementById('global-remaining').textContent = global.remaining.toLocaleString();
        
        const globalPercent = global.total > 0 ? (global.used / global.total) * 100 : 0;
        document.getElementById('global-progress').style.width = `${globalPercent}%`;
        
        document.getElementById('daily-limit').textContent = global.dailyLimit.toLocaleString();
        document.getElementById('daily-used').textContent = global.dailyUsed.toLocaleString();
        
        const dailyPercent = global.dailyLimit > 0 ? (global.dailyUsed / global.dailyLimit) * 100 : 0;
        document.getElementById('daily-progress').style.width = `${dailyPercent}%`;
    }

    // 🔄 FONCTION FORCE REFRESH
    function forceRefreshPage() {
        const refreshIcon = document.getElementById('refreshIcon');
        const refreshBtn = document.getElementById('forceRefreshBtn');
        
        // Animation de rotation
        refreshIcon.style.animation = 'spin 1s linear infinite';
        refreshBtn.style.opacity = '0.7';
        refreshBtn.style.pointerEvents = 'none';
        
        // Actualiser toutes les données
        Promise.all([
            loadStatsCards(),
            loadQuotasOverview(),
            loadWatchAccounts()
        ]).then(() => {
            // Animation de succès
            setTimeout(() => {
                refreshIcon.style.animation = '';
                refreshBtn.style.opacity = '1';
                refreshBtn.style.pointerEvents = 'auto';
                
                // Feedback visuel de succès
                refreshIcon.className = 'fas fa-check';
                refreshIcon.style.color = '#17bf63';
                
                setTimeout(() => {
                    refreshIcon.className = 'fas fa-sync-alt';
                    refreshIcon.style.color = '';
                }, 1000);
            }, 500);
        }).catch(() => {
            // En cas d'erreur
            refreshIcon.style.animation = '';
            refreshBtn.style.opacity = '1';
            refreshBtn.style.pointerEvents = 'auto';
            
            refreshIcon.className = 'fas fa-exclamation-triangle';
            refreshIcon.style.color = '#e0245e';
            
            setTimeout(() => {
                refreshIcon.className = 'fas fa-sync-alt';
                refreshIcon.style.color = '';
            }, 2000);
        });
    }

    // Animation CSS pour la rotation
    const refreshStyle = document.createElement('style');
    refreshStyle.textContent = `
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    `;
    document.head.appendChild(refreshStyle);

    // --- AUTOMATION PROGRESS FUNCTIONS ---
    async function loadAutomationProgress() {
        try {
            console.log('[DEBUG] Fetching automation progress...');
            const res = await fetch(`${API_BASE_URL}/api/automation-progress`);
            const data = await res.json();
            
            console.log('[DEBUG] Automation progress response:', data);
            
            if (data.success) {
                updateAutomationProgress(data.data);
            } else {
                console.error('[DEBUG] API returned error:', data.error);
            }
        } catch (error) {
            console.error('Error loading automation progress:', error);
        }
    }

    function updateAutomationProgress(progressData) {
        console.log('[DEBUG] Updating automation progress with:', progressData);
        
        // Current Step
        const currentStepEl = document.getElementById('currentStepStatus');
        if (currentStepEl && progressData.currentStep) {
            currentStepEl.innerHTML = `${progressData.currentStep.icon} <span>${progressData.currentStep.text}</span>`;
            currentStepEl.className = `automation-status-item ${progressData.currentStep.status}`;
            console.log('[DEBUG] Updated currentStep:', progressData.currentStep);
        }

        // Last Success
        const lastSuccessEl = document.getElementById('lastSuccessStatus');
        if (lastSuccessEl && progressData.lastSuccess) {
            lastSuccessEl.innerHTML = `${progressData.lastSuccess.icon} <span>${progressData.lastSuccess.text}</span>`;
            lastSuccessEl.className = `automation-status-item ${progressData.lastSuccess.status}`;
        }

        // Errors
        const errorsEl = document.getElementById('errorsStatus');
        if (errorsEl && progressData.errors) {
            errorsEl.innerHTML = `${progressData.errors.icon} <span>${progressData.errors.text}</span>`;
            errorsEl.className = `automation-status-item ${progressData.errors.status}`;
        }

        // Tokens
        const tokenEl = document.getElementById('tokenStatus');
        if (tokenEl && progressData.tokens) {
            tokenEl.innerHTML = `${progressData.tokens.icon} <span>${progressData.tokens.text}</span>`;
            tokenEl.className = `automation-status-item ${progressData.tokens.status}`;
        }

        // Mutes
        const muteEl = document.getElementById('muteStatus');
        if (muteEl && progressData.mutes) {
            muteEl.innerHTML = `${progressData.mutes.icon} <span>${progressData.mutes.text}</span>`;
            muteEl.className = `automation-status-item ${progressData.mutes.status}`;
        }

        // Quota System
        const quotaSystemEl = document.getElementById('quotaSystemStatus');
        if (quotaSystemEl && progressData.quotaSystem) {
            quotaSystemEl.innerHTML = `${progressData.quotaSystem.icon} <span>${progressData.quotaSystem.text}</span>`;
            quotaSystemEl.className = `automation-status-item ${progressData.quotaSystem.status}`;
        }
    }

    // Auto-refresh automation progress every 10 seconds
    setInterval(loadAutomationProgress, 10000);

    // Chargement des données des cartes au chargement de la page
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            loadStatsCards();
            loadQuotasOverview();
            loadAutomationProgress();
        });
    } else {
        loadStatsCards();
        loadQuotasOverview();
        loadAutomationProgress();
    }

    // --- FONCTION POUR LE MENU HAMBURGER ---
    function toggleMobileMenu() {
        const hamburger = document.querySelector('.hamburger');
        const mobileMenu = document.getElementById('mobileMenu');
        
        hamburger.classList.toggle('active');
        mobileMenu.classList.toggle('active');
    }

    // Fermer le menu mobile si on clique en dehors
    document.addEventListener('click', function(event) {
        const hamburger = document.querySelector('.hamburger');
        const mobileMenu = document.getElementById('mobileMenu');
        const navbar = document.querySelector('.navbar');
        
        if (!navbar.contains(event.target)) {
            hamburger.classList.remove('active');
            mobileMenu.classList.remove('active');
        }
    });
    </script>

</body>

</html>